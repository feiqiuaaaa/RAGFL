------------------------------------------------
交易故障分析：
问题/异常点：该故障交易（0x90fb0c9976...）通过多个DEX流动性池进行超大规模代币兑换操作，涉及WBTC/WETH及自定义代币的异常销毁与铸造，最终导致高额资产转移。关键异常包括：1. 单笔交易销毁6.04亿单位自定义代币（SLP）并铸造新代币；2. WBTC池兑换出2.1万WETH（价值异常）；3. SUSHI转账量达9.38亿单位（占该代币总供应量33.2%）。

原因分析：攻击者利用了自定义代币合约（0x9a1386...）的铸造/销毁权限漏洞与DEX价格计算缺陷。具体攻击路径如下：首先通过合约的铸造功能（Mint）在零地址生成新代币，随后将大量代币注入流动性池，利用SLP代币在WBTC/WETH池中的异常高比例兑换（因未验证代币实际价值），完成WBTC到WETH的虚高兑换率套利。攻击者进一步通过销毁代币（Burn）操作人为改变流动性池储备量，触发价格预言机数据异常，在SUSHI/WETH池中完成超额兑换。根本原因在于：1. 自定义代币合约未限制零地址的铸造权限；2. DEX路由合约（0xe11fc0b4...）未对跨池兑换的滑点与流动性深度进行有效校验；3. WBTC合约（0x2260fac...）的转账事件未与实际资产锚定验证。

漏洞利用链条：攻击者地址（0x51841d9a...）→ 路由合约调用自定义代币铸造 → 向WBTC/WETH池注入虚假流动性 → 发起大额兑换扭曲价格 → 销毁代币重置流动性 → 通过SUSHI池完成最终资产提取。

Trace调用链：0x51841d9afe10（EOA）→ 0xe11fc0b43ab9（路由合约）→ 0x9a13867048e0（SLP代币合约）→ 0x2260fac5e554（WBTC合约）→ 0xceff51756c56（WBTC/WETH池）→ 0x798d1be841a8（DIGG代币合约）→ 0xf41e354eb138（DIGG/WETH池）→ 0x795065dcc9f6（SUSHI/WETH池）→ 0x8798249c2e60（SUSHI Treasury地址）。
------------------------------------------------
向量库匹配结果：
{'ids': [['SushiSwap.sol-UniswapV2ERC20.sol', 'Saddle Finance.sol-ISwap.sol', 'MonoX.sol-Monoswap.sol', 'SushiSwap.sol-SushiRoll.sol', 'SushiSwap.sol-SushiMaker.sol', 'MonoX.sol-IMonoXPool.sol', 'MonoX.sol-SafeERC20.sol', 'MonoX.sol-IERC1155.sol', 'SushiSwap.sol-IUniswapV2Factory.sol', 'Revest Finance.sol-IFNFTHandler.sol', 'SushiSwap.sol-SushiSwapPairMock.sol', 'SushiSwap.sol-Math.sol', 'Cover Protocol.sol-COVER.sol', 'Punk Protocol-2.sol-ModelInterface.sol', 'Rikkei Finance.sol-InterestRateModel.sol', 'Punk Protocol-2.sol-CompoundModel.sol', 'Formation.Fi.sol-ERC20.sol', 'Uranium Finance-4.sol-IUraniumPair.sol', 'MERLIN LABS.sol-ILottery.sol', 'Qubit Finance.sol-QBridgeToken.sol', 'Nmbplatform.sol-StakingRewardsFixedAPY.sol', 'SushiSwap.sol-IERC20.sol', 'Qubit Finance.sol-BEP20Upgradeable.sol', 'Indexed Finance.sol-IUniswapV2Pair.sol', 'Uranium Finance-4.sol-IUraniumFactory.sol', 'Rikkei Finance.sol-CarefulMath.sol', 'Nmbplatform.sol-SafeERC20.sol', 'Revest Finance.sol-IERC20.sol', 'Punk Protocol-2.sol-CTokenInterface.sol', 'Cover Protocol.sol-IBlacksmith.sol', 'Uranium Finance-2.sol-Math.sol', 'SushiSwap.sol-IUniswapV2Router02.sol', 'SushiSwap.sol-BoringERC20.sol', 'SushiSwap.sol-SushiToken.sol', 'MERLIN LABS.sol-MerlinMinter.sol', 'Uranium Finance-5.sol-Math.sol', 'Punk Protocol-1.sol-IUniswapV2Router.sol', 'Punk Protocol-2.sol-IUniswapV2Router.sol', 'Fortress Protocol.sol-SafeMath.sol', 'CreamFinance-1.sol-CarefulMath.sol']], 'distances': [[0.2214982509613037, 0.2460697889328003, 0.25263655185699463, 0.25392669439315796, 0.2757805585861206, 0.27727699279785156, 0.2902090549468994, 0.2944793105125427, 0.2967786192893982, 0.3028576970100403, 0.3064279556274414, 0.312419593334198, 0.31808996200561523, 0.31979191303253174, 0.319821834564209, 0.3206467628479004, 0.3251221179962158, 0.32588657561372436, 0.3260093331336975, 0.32692426443099976, 0.3272802233695984, 0.32736122608184814, 0.32896697521209717, 0.33120203018188477, 0.3337524479141357, 0.3347415328025818, 0.33518141508102417, 0.3371543288230896, 0.3372621536254883, 0.338409423828125, 0.3386971354484558, 0.3395059108734131, 0.34034204483032227, 0.3418440818786621, 0.34256118535995483, 0.3428901284939234, 0.34543824195861816, 0.3473528027534485, 0.34874212741851807, 0.3488219976425171]], 'embeddings': None, 'metadatas': None, 'documents': [['该智能合约是 SushiSwap 的流动性池代币（LP Token）实现，基于 ERC20 标准并扩展了离线授权功能。合约代币名称为"SushiSwap LP Token"(SLP)，提供基础代币转账、授权功能，同时通过 EIP-712 标准实现了 Permit 离线签名授权机制，允许用户通过数字签名完成代币授权操作，无需提前发送链上交易。合约包含代币铸造/销毁功能，但相关方法设为内部函数，需通过继承机制由外部合约调用，体现其作为流动性池代币的设计特性。\n\n函数列表：\n1. 构造函数：初始化代币基础信息并创建 EIP-712 域分隔符\n2. _mint（内部）：向指定地址增发代币并更新总供应量\n3. _burn（内部）：销毁指定地址的代币并减少总供应量\n4. _approve（私有）：处理代币授权逻辑并触发 Approval 事件\n5. _transfer（私有）：执行代币转账逻辑并触发 Transfer 事件\n6. approve（外部）：公开的授权接口，允许第三方操作指定数量的代币\n7. transfer（外部）：标准代币转账功能\n8. transferFrom（外部）：允许被授权方转移代币，支持无限授权优化\n9. permit（外部）：通过验证 EIP-712 签名实现离线授权，规避单独授权交易', '该智能合约可命名为"Swap流动性池管理合约"，主要实现多代币流动性池的创建、代币兑换及流动性管理功能。合约基于自动化做市商(AMC)机制，包含代币兑换、流动性添加/移除、资金池参数管理等核心功能，支持多代币池配置与白名单机制。关键功能包含：1）通过恒定乘积算法实现代币兑换 2）支持灵活添加/移除流动性的多种模式 3）内置手续费机制（常规费率和管理员费率）4）LP代币的铸造与销毁管理 5）提供多种资金池数据查询接口。\n\n函数列表：\ngetA：获取资金池放大系数\ngetAllowlist：读取白名单合约地址\ngetToken：根据索引获取对应代币\ngetTokenIndex：通过代币地址查询索引号\ngetTokenBalance：查询指定代币的池内余额\ngetVirtualPrice：获取LP代币的虚拟价格\nisGuarded：检查防护状态\ncalculateSwap：计算兑换预期获得量\ncalculateTokenAmount：计算添加流动性对应LP数量\ncalculateRemoveLiquidity：计算全额移除流动性所得代币\ncalculateRemoveLiquidityOneToken：计算单币种移除流动性可得数量\ninitialize：初始化资金池参数\nswap：执行代币兑换交易\naddLiquidity：添加流动性并铸造LP代币\nremoveLiquidity：移除流动性并销毁LP代币\nremoveLiquidityOneToken：单币种移除流动性\nremoveLiquidityImbalance：非对称移除流动性。', 'Monoswap 智能合约总结：该合约是基于 ERC1155 标准实现的去中心化交易所核心合约，采用单边流动性模型并支持多种代币交易。核心功能包括流动性池管理、代币兑换、动态价格调整和手续费机制。合约通过 vCash 虚拟代币实现流动性管理，支持 ETH/WETH 交易对，并包含官方池、合成池等多种池状态管理。关键特性包含：1. 支持创建/移除流动性池 2. 实现基于价格滑点的自动做市算法 3. 可调节的交易手续费和开发者费用 4. 池状态锁定机制防止重入攻击 5. 提供多种兑换路径处理 ETH 与代币交易。\n\n函数列表：\n- initialize：初始化合约基础配置\n- setFeeTo：设置手续费接收地址\n- setFees：设置交易手续费率\n- setDevFee：设置开发者费用率\n- setPoolSizeMinLimit：设置最小池规模限制\n- setTokenInsurance：设置代币保险金额\n- setTokenStatus：设置代币锁定状态\n- updatePoolStatus：更新池状态（仅管理员）\n- updatePoolPrice：更新池价格（需冷却期）\n- updatePriceAdjuster：设置价格调节权限\n- setSynthPoolPrice：设置合成池价格\n- rebalancePool：执行池再平衡\n- addSpecialToken：创建特殊状态池\n- listNewToken：创建新代币池\n- addLiquidityPair：添加双向流动性\n- addLiquidity：添加单边流动性\n- addLiquidityETH：添加 ETH 流动性\n- removeLiquidity：移除流动性\n- removeLiquidityETH：移除 ETH 流动性\n- swapExactETHForToken：ETH 兑换代币\n- swapExactTokenForETH：代币兑换 ETH\n- swapETHForExactToken：指定数量 ETH 兑换\n- swapTokenForExactETH：指定数量代币兑换\n- swapExactTokenForToken：代币间兑换\n- swapTokenForExactToken：指定数量代币兑换\n- getPool：获取池信息\n- getAmountIn：计算输入金额\n- getAmountOut：计算输出金额\n- getConfig：获取系统配置参数', '该智能合约名为SushiRoll，核心功能是帮助用户将Uniswap V2的流动性池（LP）代币迁移至SushiSwap。合约通过移除用户在Uniswap的流动性，并将代币重新注入SushiSwap的新流动性池中，完成LP代币的转换。迁移过程支持两种方式：带许可签名（permit）的授权迁移和常规授权迁移。合约关键点包括：1. 移除旧路由器的流动性时，需满足最小代币数量（amountAMin/amountBMin）和截止时间（deadline）；2. 添加流动性到新路由器时，自动计算最优代币比例，确保符合SushiSwap池的储备要求；3. 迁移后剩余代币会返还用户。合约通过UniswapV2Library进行地址排序、储备量查询等操作，并采用CREATE2方式计算旧路由器的Pair合约地址，避免外部调用。\n\n函数列表：\n1. 构造函数：初始化新旧路由器的地址（oldRouter和router）\n2. migrateWithPermit：通过许可签名授权后执行迁移，参数包含tokenA/B、流动性数量、最小代币量、截止时间及签名v/r/s\n3. migrate：核心迁移函数，处理流动性移除、添加及剩余代币返还\n4. removeLiquidity（internal）：从旧路由器移除流动性，返回实际获得的代币数量\n5. pairForOldRouter（internal view）：计算旧路由器中指定代币对的Pair合约地址\n6. addLiquidity（internal）：向新路由器添加流动性并铸造LP代币给用户\n7. _addLiquidity（internal）：计算添加流动性的最优代币量，必要时创建新Pair合约', '总结：该智能合约名为SushiMaker，核心功能是通过兑换流动性池中的代币为SUSHI代币，并将收益分配给xSushi持有者。合约通过销毁Uniswap V2 LP代币获取基础代币，再经过多步兑换逻辑将代币转换为SUSHI并发送至SushiBar合约。合约采用桥接代币机制处理非直接兑换路径，仅允许外部账户（EOA）调用关键函数以防止闪电贷攻击。主要流程包括获取LP代币、销毁LP代币获得基础资产、根据代币类型选择兑换路径（包括直接处理SUSHI/WETH、桥接代币兑换等），最终通过Uniswap V2交易对完成兑换。合约包含权限管理功能，仅允许所有者设置桥接代币地址。\n\n函数列表：\n1. bridgeFor(address token)：查询指定代币的桥接代币地址，默认返回WETH。\n2. setBridge(address token, address bridge)：所有者设置代币的桥接代币地址。\n3. convert(address token0, address token1)：外部EOA调用，处理单个交易对的代币转换。\n4. convertMultiple(address[] token0, address[] token1)：外部EOA调用，批量处理多个交易对的转换。\n5. _convert(address token0, address token1)：内部函数，执行LP代币销毁和基础代币提取。\n6. _convertStep(address token0, address token1, uint256 amount0, uint256 amount1)：内部函数，处理多路径代币兑换逻辑。\n7. _swap(address fromToken, address toToken, uint256 amountIn, address to)：内部函数，执行Uniswap V2交易对的实际兑换操作。\n8. _toSUSHI(address token, uint256 amountIn)：内部函数，将任意代币兑换为SUSHI并发送至Bar合约。', 'MonoX 流动性池管理合约接口总结：该合约为基于 ERC1155 标准的多代币流动性池管理接口，主要功能涵盖流动性代币铸造销毁、WETH 存取、资产转移及流动性提供者管理。合约通过 ERC1155 基础功能实现多池流动性代币管理，支持 ETH 与 ERC20 代币的安全转账机制，内置 WETH 封装代币操作接口。核心特性包含流动性供应时间记录、顶级流动性持有者查询功能，并设置了白名单权限控制系统，允许通过 _isOfficial 参数区分官方流动性池，实现差异化管理策略。\n\n函数列表如下：\nmint：铸造流动性代币至指定账户\nburn：销毁账户持有的流动性代币\ntotalSupplyOf：查询指定流动性池代币总供应量\ndepositWETH：存入 WETH 代币\nwithdrawWETH：提取 WETH 代币\nsafeTransferETH：安全转账 ETH 至目标地址\nsafeTransferERC20Token：安全转账 ERC20 代币\nWETH：查询 WETH 合约地址\nliquidityLastAddedOf：查询账户最近流动性添加时间\ntopLPHolderOf：查询指定池顶级流动性持有者\nmintLp：铸造流动性代币（带官方标识参数）\nsetWhitelist：设置白名单权限状态', 'SafeERC20 库合约总结：该智能合约是 OpenZeppelin 标准库中的 SafeERC20 安全封装库，主要提供针对 ERC20 代币操作的安全封装方法。通过强化标准 ERC20 接口调用的异常处理机制，有效防范代币转账失败风险。核心功能包含安全转账、授权额度控制及底层调用验证三部分，重点解决以下三类问题：(1) 处理返回 false 的非常规 ERC20 代币的失败回滚 (2) 避免 approve 授权操作的竞争条件问题 (3) 使用 SafeMath 进行安全的数值计算防止溢出。其通过 _callOptionalReturn 私有函数实现底层调用验证，强制要求代币合约调用必须成功，同时兼容符合 ERC20 标准与非常规实现的代币合约。\n\n函数列表：\n1. safeTransfer(IERC20,address,uint256)：安全转账函数，执行 token.transfer 调用并验证结果\n2. safeTransferFrom(IERC20,address,address,uint256)：安全转账函数，执行 token.transferFrom 调用并验证结果\n3. safeApprove(IERC20,address,uint256)：安全授权函数（已弃用），设置授权额度时要求从零值初始化\n4. safeIncreaseAllowance(IERC20,address,uint256)：安全增加授权额度，采用加法操作避免竞争条件\n5. safeDecreaseAllowance(IERC20,address,uint256)：安全减少授权额度，执行减法操作并防止负值\n6. _callOptionalReturn(IERC20,bytes)：内部核心验证函数，执行底层调用并强制验证操作结果', '该智能合约被命名为 IERC1155（ERC1155 标准接口），是基于 EIP-1155 标准定义的多代币管理接口合约，继承自 IERC165 接口。其主要功能为实现非同质化代币（NFT）和同质化代币（FT）的统一管理标准，支持批量转账、余额查询及操作员授权机制。合约通过事件记录代币转账、授权状态变更及元数据 URI 更新，要求实现代币接收方的安全验证回调。核心特性包括允许单次/批量转账、批量余额查询、操作员全局授权控制，并强制要求接收合约实现安全转账回调逻辑。\n\n函数列表如下：\n1. balanceOf：查询指定地址中特定代币 ID 的余额数量\n2. balanceOfBatch：批量查询多个地址对应多个代币 ID 的余额（原子性操作，全部成功或回滚）\n3. setApprovalForAll：授权或撤销某操作员对调用者所有代币的管理权限\n4. isApprovedForAll：检查指定操作员是否被授权管理某账户的全部代币\n5. safeTransferFrom：安全转账单个代币类型，需验证接收方合约的回调\n6. safeBatchTransferFrom：批量安全转账多个代币类型，需验证接收方合约的批量回调', '该智能合约为 Uniswap V2 工厂合约的接口定义（Interface），声明了 Factory 合约必须实现的功能方法及事件。其核心作用是创建并管理代币交易对（Pair），同时具备手续费管理权限设置功能。合约不包含具体逻辑实现，仅通过接口规范定义了其他合约调用时应遵循的函数原型。\n\n核心功能包括：1. 创建任意两种 ERC20 代币的交易对合约 2. 查询已创建的交易对信息 3. 设置协议手续费接收地址 4. 更新合约权限控制者地址 5. 设置迁移合约地址。关键机制是通过 createPair 函数生成新的 Pair 合约，并通过事件 PairCreated 广播交易对创建信息。\n\n函数列表：\n- feeTo()：查看手续费接收地址\n- feeToSetter()：查看手续费设置权限地址\n- migrator()：查看迁移管理器地址\n- getPair()：查询两个代币对应的交易对地址\n- allPairs()：通过索引查询已创建的交易对地址\n- allPairsLength()：获取已创建交易对总数\n- createPair()：创建新的代币交易对\n- setFeeTo()：设置手续费接收地址（需权限）\n- setFeeToSetter()：设置权限控制者地址（需权限）\n- setMigrator()：设置迁移合约地址（需权限）', '智能合约名称：FNFTHandler 接口合约（IFNFTHandler）。该合约定义了与可替代性非同质化代币（F-NFT）操作相关的核心功能接口，主要涵盖代币铸造、元数据管理、销毁机制及信息查询四大功能模块。合约通过标准化函数规范实现了批量铸造、跨地址分配、动态元数据更新等特性，支持单ID铸造与多ID批量操作两种模式，提供代币供应量追踪和唯一ID生成能力，为上层NFT应用提供基础操作接口。合约采用视图函数优化链上查询效率，所有函数均需外部合约具体实现。\n\n函数列表：\n1. mint() - 向指定账户铸造特定数量的单一ID代币\n2. mintBatchRec() - 批量向多个接收者分配指定数量的同ID代币\n3. mintBatch() - 向单个地址批量铸造多ID代币组合\n4. setURI() - 更新代币元数据存储标识符\n5. burn() - 销毁指定账户的特定ID代币\n6. burnBatch() - 批量销毁多ID代币组合\n7. getBalance() - 查询指定账户特定ID代币余额\n8. getSupply() - 获取特定ID代币的总供应量\n9. getNextId() - 获取下一个可用代币ID编号', '总结：该 SushiSwapPairMock 智能合约是一个模拟实现的流动性池合约，继承自 UniswapV2Pair 合约核心逻辑。其核心功能是作为去中心化交易所中的交易对池，处理代币兑换、流动性添加/移除等基础操作。代码未对父合约功能进行任何修改或扩展，仅通过构造函数调用父类初始化，属于基础逻辑复用型合约。其核心机制包括自动做市商算法、流动性代币铸造/销毁、交易手续费积累等原生 Uniswap V2 特性。\n\n函数列表：包含 UniswapV2Pair 全部函数：mint（铸造流动性代币给提供者）、burn（销毁流动性代币并返还代币）、swap（执行代币兑换）、sync（强制更新储备量）、skim（提取多余代币）、initialize（初始化交易对代币）、getReserves（获取当前储备量）、_update（内部储备量更新）、_mintFee（手续费铸造计算）、transfer（ERC20代币转账）、approve（授权额度）、transferFrom（授权转账）、permit（元交易许可）。具体函数实现细节需参考 UniswapV2Pair 源合约。', '该智能合约是一个名为 Math 的 Solidity 数学工具库，主要用于提供基础数学运算功能。其核心功能包含两个实用函数：1. min 函数用于比较两个无符号整数并返回较小值，通过三元运算符实现简洁判断逻辑；2. sqrt 函数实现巴比伦迭代算法计算平方根，特别优化了大于3的数值计算场景，通过循环迭代逼近精确值，处理了边界值情况（当输入为0时返回0，1-3时返回1）。整个库被声明为 internal pure 函数，表明其设计用于合约内部调用且不修改链上状态，适用于需要数学计算的合约模块化调用场景。函数列表：1. min(uint x, uint y)：比较两个无符号整数，返回较小的值。2. sqrt(uint y)：使用巴比伦方法计算输入参数的平方根，适用于较大的数值计算。', 'COVER代币合约总结：该合约是Cover Protocol项目的ERC20代币实现，具有挖矿和迁移功能控制机制。核心功能包括代币初始分配、权限管理和分阶段释放机制。合约部署时向指定地址铸造1枚代币用于创建资金池，通过release函数实现代币正式释放（需达到设定时间戳），向金库地址铸造950枚、归属地址铸造10800枚代币。代币铸造权仅限通过认证的迁移合约和矿工合约调用，且设置黑smith合约和迁移合约地址的权限采用链式验证模式（仅当前合约可修改自身地址）。合约包含严格的时间锁和一次性释放保护，防止重复初始化。\n\n函数列表：\n1. 构造函数：初始化代币名称符号，铸造1枚代币到固定地址\n2. mint：在代币释放后，允许迁移合约或矿工合约铸造代币给指定账户\n3. setBlacksmith：由当前黑smith合约调用，更新黑smith合约地址\n4. setMigrator：由当前迁移合约调用，更新迁移合约地址\n5. release：由合约所有者单次调用，激活代币系统并执行初始分配，设置黑smith和迁移合约地址（需达到设定时间且未释放过）', 'ModelInterface 智能合约总结：该合约是一个资金管理模型接口，定义了标准化资金投资与提现机制。核心功能包括查询资金余额、执行投资策略、控制资金流向三大部分。合约通过事件机制记录资金操作日志，要求提现操作必须通过 Forge 合约权限验证，确保资金操作安全性。主要特点体现在：1. 提供实时资金状态查询（已投资/总余额）；2. 强制投资策略执行入口；3. 分级提现控制（全额/指定金额/指定地址）；4. 权限隔离机制（OnlyForge 修饰符）。该接口为具体资金管理模型的实现提供了标准化规范，适用于需要资金托管与策略投资的 DeFi 应用场景。\n\n函数列表：\n1. underlyingBalanceInModel()：查询模型内未投资资金余额\n2. underlyingBalanceWithInvestment()：查询总投资余额（含已投资部分）\n3. invest()：执行投资策略，将未投资资金转入投资\n4. withdrawAllToForge()：全额提现至 Forge 合约\n5. withdrawToForge(uint256)：指定金额提现至 Forge 合约\n6. withdrawTo(uint256, address)：指定金额提现至目标地址', 'InterestRateModel 智能合约总结：该合约是由 Rifi 开发的利率模型接口合约，主要用于定义去中心化金融市场中的借贷利率计算标准。合约通过两个核心函数抽象化利率计算逻辑，为具体利率模型实现提供接口规范。关键特性包括：1. 包含 isInterestRateModel 标识常量用于合约类型验证；2. 声明借款利率计算函数 getBorrowRate，接收市场现金总量、未偿借款和准备金作为输入参数；3. 声明供应利率计算函数 getSupplyRate，额外接收储备因子参数。该合约作为抽象接口，需要具体实现合约继承后完善实际利率计算逻辑，支持不同利率模型策略的灵活扩展，其返回值均采用 1e18 精度标准，确保计算精度满足 DeFi 应用需求。\n\n函数列表：\n1. getBorrowRate：计算每个区块的借款利率，参数为市场现金总额(cash)、未偿借款总额(borrows)、准备金总额(reserves)，返回经过 1e18 缩放后的借款利率百分比\n2. getSupplyRate：计算每个区块的存款利率，参数增加储备因子(reserveFactorMantissa)，返回经过 1e18 缩放后的存款利率百分比', 'CompoundModel 智能合约总结：该合约是基于 Compound 协议和 Uniswap V2 构建的收益增强模型，主要实现资产存入 Compound 生息、自动复投 COMP 奖励的功能。合约通过连接 cToken 实现底层资产存入 Compound 协议获取利息，并定期将 COMP 奖励通过 Uniswap 兑换为底层资产进行复投。核心功能包含资金存入/赎回、COMP 奖励自动兑换、收益计算三个模块。合约采用 OnlyForge 权限控制，仅允许指定地址执行提款操作，确保资金安全。关键操作涉及与 Compound 协议的 cToken 交互（mint/redeem）和 Uniswap 的链上兑换（swapExactTokensForTokens），通过事件机制记录投资、提现和代币兑换行为。\n\n函数列表：\n1. initialize：初始化合约参数，设置 cToken、COMP 代币、Comptroller 和 Uniswap 路由地址\n2. underlyingBalanceInModel：查询合约持有的底层代币余额\n3. underlyingBalanceWithInvestment：计算包含投资利息的总资产价值\n4. invest：将全部底层代币存入 Compound 协议\n5. reInvest：组合操作：领取 COMP 奖励→兑换为底层代币→重新投资\n6. withdrawAllToForge：全额赎回资产并转账至 Forge 地址\n7. withdrawToForge：提取指定数量资产到 Forge 地址\n8. withdrawTo：提取指定数量资产到任意地址（仅限 Forge 调用）\n9. _cTokenBalanceOf（internal）：查询合约持有的 cToken 数量\n10. _claimComp（internal）：从 Compound 协议领取 COMP 奖励\n11. _swapCompToUnderlying（internal）：通过 Uniswap 将 COMP 兑换为底层代币', '智能合约名称：ERC20标准代币合约。该合约是基于OpenZeppelin框架实现的ERC20标准代币，提供通证基本功能的核心逻辑。合约包含代币名称、符号、总供应量、余额查询、转账、授权等标准功能，并通过内部函数实现代币铸造与销毁机制。关键特性包括：1. 遵循ERC20规范实现转账与授权逻辑 2. 采用SafeMath的unchecked模式处理算术运算 3. 提供增/减授权额度函数防止竞态条件 4. 包含转账前后的钩子函数供扩展 5. 通过内部_mint和_burn控制代币供应。合约需要派生合约实现具体的铸造逻辑，基础版本不包含公开的铸造方法。所有转账操作均进行零地址校验，余额变更采用先减后增的安全模式。\n\n函数列表：\n- constructor：初始化代币名称和符号\n- name：查询代币名称\n- symbol：查询代币符号\n- decimals：返回代币小数位数（固定18）\n- totalSupply：查询总供应量\n- balanceOf：查询指定地址余额\n- transfer：执行代币转账\n- allowance：查询授权额度\n- approve：设置代币授权\n- transferFrom：从授权地址执行转账\n- increaseAllowance：增加授权额度\n- decreaseAllowance：减少授权额度\n- _transfer：内部转账逻辑处理\n- _mint：内部代币铸造方法\n- _burn：内部代币销毁方法\n- _approve：内部授权处理\n- _beforeTokenTransfer：转账前钩子函数（空实现）\n- _afterTokenTransfer：转账后钩子函数（空实现）', '智能合约名称：IUraniumPair（铀交易对接口）。该合约是一个定义了去中心化交易所交易对核心功能的接口，同时兼容 ERC20 标准作为流动性代币凭证。合约主要包含四个模块功能：1）ERC20 标准代币功能，用于管理流动性提供者的份额凭证；2）流动性铸造/销毁机制，通过 mint/burn 函数处理流动性增减；3）代币交换功能，支持双向代币兑换并触发 Swap 事件；4）价格预言机相关功能，通过储备量记录和累计价格实现外部价格查询。特色功能包括支持 EIP-2612 离线授权许可（permit）、储备同步机制（sync/skim）以及最小流动性锁定机制（MINIMUM_LIQUIDITY）。\n\n函数列表：\n- ERC20 标准函数：name（代币名称）、symbol（代币符号）、decimals（小数位）、totalSupply（总供应量）、balanceOf（查询余额）、allowance（查询授权额度）、approve（设置授权）、transfer（转账）、transferFrom（授权转账）\n- 许可功能：DOMAIN_SEPARATOR（EIP712 域分隔符）、PERMIT_TYPEHASH（许可类型哈希）、nonces（地址 nonce 值）、permit（离线授权）\n- 流动性管理：mint（铸造流动性代币）、burn（销毁流动性代币）\n- 交易功能：swap（执行代币兑换）\n- 储备管理：sync（同步储备余额）、skim（调整余额差异）\n- 信息查询：factory（查询工厂地址）、token0（查询代币0）、token1（查询代币1）、getReserves（获取储备量）、price0CumulativeLast（代币0累计价格）、price1CumulativeLast（代币1累计价格）、kLast（最后储备乘积）\n- 初始化函数：initialize（初始化交易对）\n- 常量参数：MINIMUM_LIQUIDITY（最小流动性值）', 'ILottery 智能合约总结：该合约是一个彩票系统接口合约，定义了与彩票核心机制交互的标准函数规范。合约主要包含获取彩票参数和修改彩票状态两大类功能，通过接口形式规范了不同合约间的交互标准。核心功能围绕彩票开奖机制设计，包含获取最大号码范围、接收随机数开奖结果、增加奖池金额三个关键操作，为彩票业务提供了基础功能框架。\n\n函数列表：\n1. getMaxRange - 外部视图函数，获取彩票号码的最大取值范围\n2. numbersDrawn - 外部状态修改函数，接收随机数并处理彩票开奖结果（需传入彩票ID、请求ID和随机数）\n3. addMerlinPrize - 外部状态修改函数，向奖池增加指定数量的奖金', 'QBridgeToken 智能合约总结：该合约是基于 BEP20 标准构建的可升级代币合约，主要用于实现跨链桥接场景中的代币铸造和销毁功能。合约核心功能包含权限管理机制，通过维护铸币者白名单实现代币操作权限控制。合约所有者可通过 setMinter 函数动态管理具有铸币权限的地址，授权后的铸币者地址可执行代币铸造 mint 和带授权销毁 burnFrom 操作。合约继承自 BEP20Upgradeable 实现代币基础功能，并采用初始化函数 initialize 支持可升级合约模式，允许在部署后设置代币名称、符号和小数位。销毁功能采用从指定账户扣除授权额度的安全机制，通过校验用户对铸币者的授权额度防止超额燃烧代币。\n\n函数列表：\n1. initialize - 初始化函数，设置代币名称、符号和小数位\n2. setMinter - 设置/取消地址的铸币者权限（仅合约所有者可调用）\n3. mint - 向指定地址铸造代币（仅铸币者可调用）\n4. burnFrom - 从指定账户销毁代币并更新授权额度（仅铸币者可调用）\n5. isMinter - 查询指定地址是否具有铸币者权限', 'StakingRewardFixedAPY 智能合约总结：该合约是基于固定年化收益的质押奖励系统，支持多币种质押与奖励发放。合约通过非连续质押记录管理（nonce机制）实现用户多次质押独立核算，采用价格预言机与兑换路由实现跨代币价值转换。核心功能包括：1）支持带许可签名的质押操作 2）按时间段计算固定APY奖励 3）灵活切换奖励支付代币 4）动态调整APY参数 5）防重入与紧急暂停机制。质押资产与奖励代币可分离，通过价格预言机或DEX路由实现价值换算，奖励发放支持批量领取与指定用户领取功能。\n\n函数列表：\n1. 构造函数：初始化代币地址、路由合约与初始APY\n2. totalSupply：获取总质押量\n3. totalSupplyRewardEquivalent：获取奖励等价总质押量\n4. balanceOf：查询用户质押余额\n5. balanceOfRewardEquivalent：查询用户奖励等价余额\n6. earnedByNonce：计算指定nonce的应得奖励\n7. earned：计算用户总应得奖励\n8. stakeWithPermit：带EIP-2612许可的质押\n9. stake：普通质押\n10. stakeFor：为他人质押\n11. withdraw：按nonce提取质押\n12. getReward：领取奖励\n13. getRewardForUser：为指定用户领取奖励（仅管理员）\n14. withdrawAndGetReward：提取质押并领取奖励\n15. getTokenAmountForToken：代币兑换量计算\n16. exit：全额退出质押\n17. getEquivalentAmount：质押代币奖励等价转换\n18. setPaused：设置合约暂停状态\n19. updateRewardRate：更新APY参数\n20. updateSwapRouter：更新兑换路由\n21. updateRewardsPaymentToken：更新奖励支付代币\n22. updatePriceFeed：更新价格预言机\n23. updateUsePriceFeeds：切换价格源使用方式\n24. rescueEIP20：紧急代币提取', '该智能合约代码是 ERC20 标准的接口定义合约(IERC20)，规定了代币合约必须实现的基础函数和事件。其核心功能围绕代币的基本操作设计，包括代币总量查询、账户余额查询、代币转账、授权额度管理等功能。代码中未包含具体实现逻辑，仅通过接口形式定义了代币标准规范，其他合约可通过继承该接口来保证 ERC20 兼容性。代码中明确定义了转账和授权两个事件，为代币交易提供事件监听支持。该接口遵循 ERC20 标准要求，包含代币合约的标准函数签名和参数定义，是构建兼容性代币的基础模板。\n\n函数列表如下：\ntotalSupply()：查询代币总供应量，返回 uint256 类型数值\nbalanceOf(address)：查询指定地址的代币余额，参数为账户地址，返回 uint256\ntransfer(address,uint256)：向指定地址转账，参数为接收地址和转账金额，返回 bool 执行结果\nallowance(address,address)：查询授权额度，参数为拥有者地址和操作者地址，返回 uint256\napprove(address,uint256)：设置授权额度，参数为被授权地址和授权金额，返回 bool 执行结果\ntransferFrom(address,address,uint256)：通过授权机制转账，参数为发送地址、接收地址和转账金额，返回 bool 执行结果\n\n事件列表：\nTransfer(address,address,uint256)：代币转账时触发，记录发送方、接收方和转账金额\nApproval(address,address,uint256)：授权额度变更时触发，记录拥有者、被授权者和新授权额度', '智能合约命名：BEP20Upgradeable。该合约是基于 PancakeSwap 的 BEP20 标准和 OpenZeppelin 可升级合约框架实现的代币基础合约，支持代币升级功能。合约核心功能包括代币转账、余额查询、授权管理、供应量铸造/销毁等标准 BEP20 操作，同时通过 OwnableUpgradeable 实现所有权控制。关键特性包含可初始化参数设置（名称/符号/小数位）、安全数学运算防止溢出、支持代币燃烧功能，并通过预留 50 位存储间隙实现可扩展性。合约通过抽象化设计为后续具体代币合约提供基础模板，采用代理模式兼容合约升级需求。\n\n函数列表：\n1. __BEP20__init：初始化代币基础参数（名称/符号/小数位）\n2. getOwner：获取合约所有者地址\n3. decimals：查询代币小数位数\n4. symbol：查询代币符号\n5. name：查询代币名称\n6. totalSupply：获取代币总供应量\n7. balanceOf：查询指定地址余额\n8. transfer：执行代币转账\n9. allowance：查询授权额度\n10. approve：设置代币操作授权\n11. transferFrom：从授权账户执行转账\n12. increaseAllowance：增加授权额度\n13. decreaseAllowance：减少授权额度\n14. burn：销毁指定数量代币', 'UniswapV2Pair 智能合约接口总结：该智能合约定义了 Uniswap V2 去中心化交易所中流动性池的核心功能，作为 ERC20 标准代币实现交易对池化资产管理。合约通过自动化做市商机制实现代币兑换，包含流动性铸造/销毁、代币交换、储备金同步等核心功能，并集成 ERC2612 签名授权特性。关键功能包括通过 mint/burn 函数进行流动性增减管理，swap 函数执行代币兑换，以及通过 getReserves 获取实时资金池状态。合约通过事件流记录资金变动，维护价格累积变量实现链上价格追踪。\n\n函数列表如下：\n1. name() - 获取流动性代币名称\n2. symbol() - 获取代币符号\n3. decimals() - 返回代币精度\n4. totalSupply() - 查询代币总供应量\n5. balanceOf() - 查询指定地址余额\n6. allowance() - 查询授权额度\n7. approve() - 设置代币操作权限\n8. transfer() - 转账代币\n9. transferFrom() - 从指定地址转账\n10. DOMAIN_SEPARATOR() - 获取 EIP712 域分隔符\n11. PERMIT_TYPEHASH() - 返回许可类型哈希\n12. nonces() - 查询地址的许可随机数\n13. permit() - 通过签名执行授权\n14. MINIMUM_LIQUIDITY() - 获取最小流动性限制\n15. factory() - 查询所属工厂地址\n16. token0() - 获取第一个代币地址\n17. token1() - 获取第二个代币地址\n18. getReserves() - 返回当前储备量及时间戳\n19. price0CumulativeLast() - 获取代币0价格累积值\n20. price1CumulativeLast() - 获取代币1价格累积值\n21. kLast() - 查询最后储备乘积值\n22. mint() - 铸造流动性代币\n23. burn() - 销毁流动性代币并提取基础资产\n24. swap() - 执行代币兑换交易\n25. skim() - 调整储备与余额的差异\n26. sync() - 强制同步储备数据\n27. initialize() - 初始化交易对代币地址', 'UraniumFactory接口合约总结：该智能合约是一个工厂合约接口，定义了去中心化交易所中代币交易对创建及费用管理的核心功能。合约主要用于创建和管理流动性交易对，包含费用地址设置、交易对查询、动态费用参数控制等机制。通过createPair函数可创建新的代币交易对，同时维护所有已创建交易对的列表。合约包含管理员权限体系，通过feeToSetter和owner进行协议参数控制，支持动态调整手续费接收地址和权限转移功能。该接口遵循类似Uniswap V2的工厂合约模式，但增加了feeAmount费用比例参数，表明可能采用动态手续费机制。\n\n函数列表：\n1. feeTo()：查询手续费接收地址\n2. feeToSetter()：查询手续费设置权限地址\n3. feeAmount()：查询当前交易手续费比例\n4. owner()：查询合约所有者地址\n5. getPair()：根据代币地址查询已存在的交易对\n6. allPairs()：通过索引获取已创建交易对地址\n7. allPairsLength()：获取已创建交易对总数\n8. createPair()：创建新的代币交易对\n9. setFeeTo()：设置新的手续费接收地址\n10. setFeeToSetter()：转移手续费设置权限', 'CarefulMath 智能合约总结：该合约是基于 OpenZeppelin 的 SafeMath 库改进的安全数学运算库，主要用于处理基础算术运算的溢出/下溢保护。合约通过枚举类型 MathError 定义了四种错误状态（除零错误、整数溢出、整数下溢），在执行算术运算时会返回包含错误码和计算结果的元组，为上层调用提供更灵活的错误处理机制。合约实现了基础四则运算及组合运算的安全校验：乘法通过反向除法验证溢出，减法检查被减数关系，加法通过结果反推验证，并通过 addThenSubUInt 实现加法减法链式调用。该合约所有函数均为 internal 权限且不修改状态，适用于作为其他合约的基础运算模块。\n\n函数列表：\n1. mulUInt(uint,uint) 执行安全乘法运算，返回错误码和乘积结果\n2. divUInt(uint,uint) 执行安全除法运算，返回错误码和整除结果\n3. subUInt(uint,uint) 执行安全减法运算，返回错误码和差值结果\n4. addUInt(uint,uint) 执行安全加法运算，返回错误码和求和结果\n5. addThenSubUInt(uint,uint,uint) 先执行加法再执行减法的链式运算，返回最终错误码和运算结果', 'SafeERC20 库总结：该智能合约是 OpenZeppelin 提供的 SafeERC20 安全操作库，主要用于增强 ERC20 代币操作的安全性。其核心功能是通过封装标准的 ERC20 操作（如转账、授权等），统一处理可能出现的调用失败情况，并对兼容 EIP-2612 的 ERC20Permit 代币提供许可签名验证功能。关键特性包括：1. 对所有 ERC20 操作添加返回值验证，防止忽略返回 false 的失败情况；2. 提供安全的授权额度调整方法，避免常见的前后授权竞争问题；3. 集成 permit 签名验证功能，支持免转账手续费授权操作；4. 通过低级调用实现兼容性处理，支持无返回值类型的代币合约。该库通过引入安全封装方法（如 safeTransfer、safeIncreaseAllowance 等），显著降低开发者直接调用 ERC20 接口时的潜在风险。\n\n函数列表：  \n- safeTransfer(IERC20,address,uint256)：安全转账函数，验证 ERC20 转账操作结果  \n- safeTransferFrom(IERC20,address,address,uint256)：安全跨账户转账，验证 transferFrom 结果  \n- safeApprove(IERC20,address,uint256)：授权操作（已弃用），强制要求从零地址开始授权  \n- safeIncreaseAllowance(IERC20,address,uint256)：安全增加授权额度，采用增量方式避免竞争条件  \n- safeDecreaseAllowance(IERC20,address,uint256)：安全减少授权额度，防止额度减至负数  \n- safePermit(IERC20Permit,address,address,uint256,uint256,uint8,bytes32,bytes32)：执行 EIP-2612 许可签名验证，包含 nonce 校验  \n- _callOptionalReturn(IERC20,bytes)：内部基础方法，执行低级调用并验证返回数据', '智能合约名称：IERC20接口合约。该合约为ERC20代币标准接口定义，规定了代币合约必须实现的基本函数和事件，用于实现同质化代币的转账、余额查询和授权管理功能。合约定义了代币总量查询、账户余额查询、代币转账、授权额度设置与查询等核心功能，包含2个事件用于记录代币转移和授权变更。该接口作为ERC20代币合约的交互规范，所有符合标准的代币合约必须实现这些函数定义，确保不同代币之间的兼容性。接口未包含具体实现逻辑，仅定义函数签名和事件结构，供具体代币合约继承并实现。\n\n函数列表：totalSupply函数用于查询代币总供应量；balanceOf函数用于查询指定账户余额；transfer函数用于向指定地址转账；allowance函数用于查询授权额度；approve函数用于设置第三方操作权限；transferFrom函数用于通过授权机制执行转账。事件部分包含Transfer转账事件和Approval授权事件。', 'CTokenInterface 智能合约总结：该合约是一个定义 cToken 标准操作的接口合约，主要用于 DeFi 借贷协议中的抵押代币交互。合约核心功能包含代币铸造/赎回、借贷偿还、底层资产交互及奖励申领四大模块，支持用户通过 cToken 进行存款生息、资产抵押借贷等操作。关键特性包括支持 ETH 和 ERC20 双模式铸造、分层赎回机制（按代币数量或底层资产数量）、实时汇率查询功能，并内置 COMP 奖励分配接口。该合约作为标准接口层，为上层协议提供与 cToken 交互的规范化函数定义。\n\n函数列表：\n1. mint() payable：接收 ETH 铸造 cToken\n2. mint(uint256)：使用指定数量底层代币铸造 cToken\n3. redeem(uint256)：按 cToken 数量赎回底层资产\n4. redeemUnderlying(uint256)：按底层资产数量赎回 cToken\n5. borrow(uint256)：借出底层资产\n6. repayBorrow(uint256)：偿还借款本金\n7. exchangeRateStored() view：查询当前 cToken 与底层资产的汇率\n8. balanceOf(address) view：查询指定地址的 cToken 余额\n9. underlying() view：获取底层资产合约地址\n10. claimComp(address)：为指定持有者申领 COMP 奖励', '智能合约名称：IBlacksmith（COVER shield mining 接口合约） 基本元数据：遵循 SPDX 许可证标识，使用 Solidity 0.7.4 版本编写，定义流动性挖矿系统的核心接口。该合约管理多个质押池的 COVER 代币挖矿与额外奖励分配机制，支持多币种奖励、动态权重调整和紧急提款功能。\n\n核心功能包含：1. 多质押池管理系统，支持动态调整池权重 2. COVER 代币与第三方代币（如 CRV）双重奖励机制 3. 时间窗口控制的奖励分配系统 4. 矿工质押量跟踪与奖励计算 5. 治理功能包括池参数调整和权限转移。\n\n函数列表： \n\n视图函数：\n- getPoolList()：获取所有流动池地址列表\n- viewMined()：查询指定矿工在特定池中的COVER和奖励代币收益\n\n用户操作函数：\n- claimRewardsForPools()：批量领取多个池的奖励\n- claimRewards()：领取单个池的奖励\n- deposit()：存入流动性代币\n- withdraw()：提取流动性代币\n- emergencyWithdraw()：紧急提取（放弃奖励）\n\n合作伙伴函数：\n- addBonusToken()：为指定池添加额外奖励代币\n\n挖矿维护函数：\n- updatePool()：更新单个池的奖励累计值\n- updatePools()：批量更新多个池的奖励累计值\n- collectDust()：回收残留代币\n- collectBonusDust()：回收奖励代币残留\n\n开发者函数：\n- addPool()：添加新流动池\n- addPools()：批量添加流动池\n- updateBonusTokenStatus()：更新奖励代币状态\n\n治理函数：\n- updatePoolWeights()：调整池权重配置\n- updateWeeklyTotal()：更新周奖励总量\n- transferMintingRights()：转移铸币权限', 'Math库智能合约总结：该合约是一个提供数学运算功能的工具库，主要包含两个核心函数。min()函数实现基础数值比较功能，用于获取两个无符号整数中的较小值。sqrt()函数采用巴比伦迭代法计算平方根，该算法通过循环迭代逼近实现高效开方运算，特别针对输入值>3的情况进行优化处理，当输入值为0时返回0，其他小于等于3的数值返回1。该库合约采用Solidity 0.5.16版本编写，所有函数均为internal可见性且标记为pure，确保无状态修改且只能在合约内部调用，适用于需要基础数学运算的智能合约进行功能扩展。函数列表：1. min(uint x, uint y)：比较并返回两个无符号整数中的较小值。2. sqrt(uint y)：采用巴比伦迭代法计算输入值的平方根整数部分。', '该智能合约是 Uniswap V2 路由器的扩展接口合约，主要用于支持转账时带有手续费代币的交易场景。合约继承自 IUniswapV2Router01 并新增了五个关键函数，核心功能围绕流动性移除和代币兑换操作进行优化，允许用户在执行交易时自动处理转账扣费代币的余额计算问题。其中移除流动性函数支持直接返还 ETH，并提供带数字签名授权（Permit）的版本以简化用户操作流程。swap 系列函数均支持精确输入金额的交易模式，并适配转账扣费机制，覆盖代币与代币、ETH 与代币之间的兑换场景。\n\n函数列表：\n1. removeLiquidityETHSupportingFeeOnTransferTokens：移除流动性并返还 ETH，支持转账扣费代币\n2. removeLiquidityETHWithPermitSupportingFeeOnTransferTokens：通过签名授权移除流动性并返 ETH，支持扣费代币\n3. swapExactTokensForTokensSupportingFeeOnTransferTokens：精确输入代币兑换代币，支持扣费代币\n4. swapExactETHForTokensSupportingFeeOnTransferTokens：精确输入 ETH 兑换代币，支持扣费代币\n5. swapExactTokensForETHSupportingFeeOnTransferTokens：精确输入代币兑换 ETH，支持扣费代币\n\n（注意：继承自 IUniswapV2Router01 的父接口函数未在本列表重复列出）', '该智能合约是一个名为BoringERC20的工具库，旨在增强与ERC20代币交互的安全性，通过封装底层调用并添加错误处理机制来防止常见问题。其核心功能包括安全获取代币信息（符号、名称、小数位数）以及执行安全的转账操作。关键点在于处理外部调用失败时提供默认返回值或触发交易回滚，例如在查询代币符号时返回"???"替代错误，转账失败时抛出明确错误信息。该库不依赖具体代币实现，而是通过低级调用动态适配不同ERC20合约，适用于需要兼容多种代币的场景。\n\n函数列表如下：\n1. safeSymbol：内部视图函数，安全查询代币符号，失败返回"???"\n2. safeName：内部视图函数，安全查询代币名称，失败返回"???"\n3. safeDecimals：公开视图函数，安全查询代币小数位，失败默认返回18\n4. safeTransfer：内部函数，执行代币转账并验证结果，失败回滚交易\n5. safeTransferFrom：内部函数，执行代币授权转账并验证结果，失败回滚交易', '该智能合约是一个兼具代币功能和治理机制的SUSHI代币合约，基于ERC20标准并继承Ownable权限控制。核心功能包括代币铸造和委托投票治理系统。合约通过检查点机制记录每个地址在不同区块的投票权重，并支持通过签名进行委托授权。关键特性如下：1. 仅合约所有者可调用mint函数进行代币铸造，铸造时自动更新委托人的投票权重。2. 实现链上治理功能，允许用户委托投票权，采用类似Compound的投票委托机制。3. 使用检查点(Checkpoint)结构记录历史投票数据，支持查询任意历史区块的投票余额。4. 集成EIP-712标准签名验证，允许离线签署委托授权。5. 通过事件监控委托关系变更和投票权重变化。\n\n函数列表：\nmint：所有者铸造新代币并更新委托投票\ndelegates：查询指定地址的委托对象\ndelegate：将调用者的投票权委托给指定地址\ndelegateBySig：通过签名验证实现委托授权\ngetCurrentVotes：获取指定地址的当前投票余额\ngetPriorVotes：查询指定地址在历史区块的投票余额\n_delegate：内部处理委托逻辑\n_moveDelegates：内部转移委托投票权重\n_writeCheckpoint：内部写入检查点数据\nsafe32：安全转换为32位无符号整数\ngetChainId：获取当前链ID', 'MerlinMinter 智能合约总结：该合约是用于管理 MERLIN 代币铸造及收益分配的核心协议，主要功能包含代币铸造权限控制、手续费管理、流动性池激励分配以及与外部 DeFi 协议（如 PancakeSwap）的交互。合约通过多角色权限系统（Owner/Minter/MerlinChef）实现分级控制，采用绩效费（最高 51%）和提现费（最高 5%）机制，支持将收益自动转换为 MERLIN-BNB LP 代币注入质押池，同时集成代币销毁、彩票奖金池和回购机制。核心逻辑涉及资产跨协议转换（Zap 功能）、自动复利奖励计算和代币经济模型维护。\n\n函数列表：\n1. initialize - 初始化合约参数及关联地址\n2. transferMerlinOwner - 转移 MERLIN 代币所有权\n3. setWithdrawalFee - 设置提现手续费比例\n4. setPerformanceFee - 设置绩效手续费比例\n5. setWithdrawalFeeFreePeriod - 设置免提现费周期\n6. setMinter - 设置/移除铸造权限地址\n7. setMerlinPerProfitBNB - 调整 BNB 利润与 MERLIN 的铸造比例\n8. setMerlinChef - 设置 MerlinChef 合约地址\n9. setTimelock - 设置时间锁合约地址\n10. setBurnContribution - 设置销毁贡献比例\n11. setLottery - 设置彩票合约地址\n12. setLotteryRatio - 设置彩票分配比例\n13. setBuybacker - 设置回购地址\n14. setPriceCalculator - 设置价格计算器\n15. isMinter - 查询地址是否具有铸造权限\n16. amountMerlinToMint - 计算应铸造 MERLIN 数量\n17. withdrawalFee - 计算提现手续费\n18. performanceFee - 计算绩效手续费\n19. mintFor - 核心铸造函数（仅 Minter 可调用）\n20. mint - 常规铸造函数（仅 MerlinChef 可调用）\n21. safeMerlinTransfer - 安全转账 MERLIN（仅 MerlinChef 可调用）\n22. mintGov - 治理铸造函数（转移至 Timelock）', 'Math库智能合约是一个提供数学运算功能的工具库，主要用于处理无符号整数的基本运算。合约包含两个核心函数：min函数用于比较两个数值并返回较小值，通过三元运算符直接实现；sqrt函数采用巴比伦方法（牛顿迭代法）计算平方根，通过循环迭代逼近精确结果，并针对小数值（y≤3）进行条件优化处理。该库所有函数均为pure类型且内部可见，不涉及状态变量操作，适用于其他合约的数学计算辅助工具。代码特点包括高效迭代算法设计、分支条件优化处理以及纯函数特性。  \n\n函数列表：  \n1. min(uint x, uint y) internal pure：返回两个无符号整数中的较小值  \n2. sqrt(uint y) internal pure：通过巴比伦迭代法计算无符号整数的平方根', '智能合约名称：Uniswap V2 路由接口合约 (IUniswapV2Router02)。该合约为 Uniswap V2 去中心化交易所的核心路由接口，定义了流动性管理、代币兑换及价格计算等功能。主要功能包括添加/移除流动性池、支持 ETH 与代币间的兑换操作、处理转账手续费代币的特定交易，以及提供代币兑换价格预测工具。合约通过工厂模式关联交易对合约，支持带许可签名的元交易授权方式，并包含针对不同兑换方向的 18 个交易函数。\n\n函数列表如下：\n1. factory() - 获取工厂合约地址\n2. WETH() - 获取 WETH 代币地址\n3. addLiquidity() - 添加两种代币的流动性\n4. addLiquidityETH() - 添加 ETH 与代币的流动性\n5. removeLiquidity() - 移除两种代币的流动性\n6. removeLiquidityETH() - 移除 ETH 与代币的流动性\n7. removeLiquidityWithPermit() - 带签名授权移除流动性\n8. removeLiquidityETHWithPermit() - 带签名授权移除 ETH 流动性\n9. swapExactTokensForTokens() - 精确输入代币兑换\n10. swapTokensForExactTokens() - 精确输出代币兑换\n11. swapExactETHForTokens() - ETH 兑换精确输出代币\n12. swapTokensForExactETH() - 代币兑换精确输出 ETH\n13. swapExactTokensForETH() - 代币兑换精确输出 ETH\n14. swapETHForExactTokens() - ETH 兑换精确输出代币\n15. quote() - 计算理论兑换量\n16. getAmountOut() - 根据输入量计算输出\n17. getAmountIn() - 根据输出量计算所需输入\n18. getAmountsOut() - 获取兑换路径输出量数组\n19. getAmountsIn() - 获取兑换路径输入量数组\n20. removeLiquidityETHSupportingFeeOnTransferTokens() - 移除支持手续费代币的流动性\n21. removeLiquidityETHWithPermitSupportingFeeOnTransferTokens() - 带签名移除手续费代币流动性\n22. swapExactTokensForTokensSupportingFeeOnTransferTokens() - 支持手续费代币的精确输入兑换\n23. swapExactETHForTokensSupportingFeeOnTransferTokens() - ETH 兑换支持手续费代币\n24. swapExactTokensForETHSupportingFeeOnTransferTokens() - 支持手续费代币兑换 ETH', '智能合约名称：UniswapV2Router02接口合约。该合约为Uniswap V2去中心化交易所的路由器接口，定义了流动性管理和代币兑换的核心功能模块。主要功能包括添加/移除流动性池、代币间兑换交易、滑点计算以及支持转账手续费代币的特殊交易处理。合约通过工厂模式与交易对合约交互，支持ETH与ERC20代币的直接兑换操作，提供精确输入与精确输出两种交易模式，并包含带许可签名的流动性移除方法以优化用户体验。\n\n函数列表如下：\nfactory() - 获取Uniswap工厂合约地址\nWETH() - 获取WETH代币地址\naddLiquidity() - 添加两种代币的流动性\naddLiquidityETH() - 添加ETH与代币的流动性\nremoveLiquidity() - 移除两种代币的流动性\nremoveLiquidityETH() - 移除ETH与代币的流动性\nremoveLiquidityWithPermit() - 带许可签名的流动性移除\nremoveLiquidityETHWithPermit() - 带许可签名的ETH流动性移除\nswapExactTokensForTokens() - 精确输入代币兑换\nswapTokensForExactTokens() - 精确输出代币兑换\nswapExactETHForTokens() - 精确ETH兑换代币\nswapTokensForExactETH() - 精确代币兑换ETH\nswapExactTokensForETH() - 精确代币兑换ETH\nswapETHForExactTokens() - 精确ETH兑换指定数量代币\nquote() - 计算理论兑换量\ngetAmountOut() - 根据输入量计算输出量\ngetAmountIn() - 根据输出量计算所需输入量\ngetAmountsOut() - 获取路径兑换输出量数组\ngetAmountsIn() - 获取路径兑换输入量数组\nremoveLiquidityETHSupportingFeeOnTransferTokens() - 支持手续费代币的流动性移除\nremoveLiquidityETHWithPermitSupportingFeeOnTransferTokens() - 带许可的手续费代币流动性移除\nswapExactTokensForTokensSupportingFeeOnTransferTokens() - 支持手续费代币的精确兑换\nswapExactETHForTokensSupportingFeeOnTransferTokens() - 支持手续费代币的ETH精确兑换\nswapExactTokensForETHSupportingFeeOnTransferTokens() - 支持手续费代币兑换ETH', '智能合约名称：SafeMath。该智能合约是一个数学运算安全库，旨在提供安全的算术操作，防止整数溢出和下溢问题。作为基础工具库，它封装了加法、减法、乘法、除法与取模运算，在所有算术操作执行前进行有效性检查。合约通过require语句实现运行时校验机制，当检测到溢出或非法操作（如除以零）时立即终止交易并回滚状态，确保运算结果始终处于有效范围。该库专门针对uint256类型设计，采用纯函数实现无状态计算，所有函数声明为internal且pure，说明其仅支持合约内部调用且不读取/修改链上状态。典型应用场景包括代币合约中的余额计算、拍卖合约中的价格运算等需要严格算术验证的场景。通过引入该库，开发者可有效避免因Solidity原生算术运算符自动截断导致的逻辑漏洞，提升智能合约的安全性。\n\n函数列表如下：add函数执行安全加法运算，检查结果是否溢出。sub函数提供两种重载，基础版本执行安全减法并检查下溢，带错误信息版本允许自定义异常提示。mul函数实现安全乘法，通过反向除法验证结果有效性。div函数分两种形式，基础版本检测除数零值错误，带消息版本支持自定义报错。mod函数处理取模运算，两个版本分别检查模数零值并返回标准或自定义错误信息。所有函数均返回uint256类型结果，并在异常发生时触发交易回滚。', 'CarefulMath 安全数学运算合约总结：该智能合约是基于 OpenZeppelin 的 SafeMath 库改进的安全数学运算模块，主要用于防止算术运算中的常见错误。合约通过枚举类型定义四种数学错误类型（除零错误、整数溢出/下溢），提供安全的加减乘除运算方法。所有函数均采用错误码返回机制替代直接交易回滚，在执行算术运算时会主动检测边界条件，当检测到溢出、下溢或除零操作时返回对应错误码而非中断交易，这种设计为上层调用合约提供了灵活的错误处理空间。合约包含基础四则运算及组合运算，所有函数均为 pure 类型且仅内部可见，确保模块安全性和低 gas 消耗特性。\n\n函数列表：\n1. mulUInt - 安全乘法运算，检测整数溢出\n2. divUInt - 安全除法运算，检测除零错误\n3. subUInt - 安全减法运算，检测整数下溢\n4. addUInt - 安全加法运算，检测整数溢出\n5. addThenSubUInt - 组合运算，先执行加法再执行减法并检测错误链式传递']], 'uris': None, 'data': None, 'included': ['distances', 'documents']}
------------------------------------------------
重排序结果：
['SushiSwap.sol-UniswapV2ERC20.sol', 'SushiSwap.sol-SushiMaker.sol', 'SushiSwap.sol-SushiToken.sol', 'SushiSwap.sol-IUniswapV2Router02.sol', 'SushiSwap.sol-IUniswapV2Factory.sol', 'SushiSwap.sol-SushiSwapPairMock.sol', 'SushiSwap.sol-IERC20.sol', 'SushiSwap.sol-BoringERC20.sol', 'SushiSwap.sol-SushiRoll.sol', 'SushiSwap.sol-Math.sol', 'MonoX.sol-Monoswap.sol', 'MonoX.sol-IMonoXPool.sol', 'MonoX.sol-SafeERC20.sol', 'MonoX.sol-IERC1155.sol', 'Indexed Finance.sol-IUniswapV2Pair.sol', 'Uranium Finance-4.sol-IUraniumPair.sol', 'Uranium Finance-4.sol-IUraniumFactory.sol', 'Punk Protocol-2.sol-IUniswapV2Router.sol', 'Punk Protocol-1.sol-IUniswapV2Router.sol', 'Fortress Protocol.sol-SafeMath.sol']
------------------------------------------------
函数切片：

------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_mint-0
元数据:{'block索引': 0, '函数名': '_mint', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _mint(address to, uint value) internal {
totalSupply = totalSupply.add(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(address(0), to, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_burn-1
元数据:{'block索引': 1, '函数名': '_burn', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _burn(address from, uint value) internal {
balanceOf[from] = balanceOf[from].sub(value);
totalSupply = totalSupply.sub(value);
emit Transfer(from, address(0), value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_approve-2
元数据:{'block索引': 2, '函数名': '_approve', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address owner, address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Approval']", '返回值': ''}
函数切片:
function _approve(address owner, address spender, uint value) private {
allowance[owner][spender] = value;
emit Approval(owner, spender, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_transfer-3
元数据:{'block索引': 3, '函数名': '_transfer', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _transfer(address from, address to, uint value) private {
balanceOf[from] = balanceOf[from].sub(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(from, to, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-approve-4
元数据:{'block索引': 4, '函数名': 'approve', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool) {
_approve(msg.sender, spender, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-transfer-5
元数据:{'block索引': 5, '函数名': 'transfer', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool) {
_transfer(msg.sender, to, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-transferFrom-6
元数据:{'block索引': 6, '函数名': 'transferFrom', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool) {
if (allowance[from][msg.sender] != uint(-1)) {
allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
}
_transfer(from, to, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-permit-7
元数据:{'block索引': 7, '函数名': 'permit', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
bytes32 digest = keccak256(
abi.encodePacked(
'\x19\x01',
DOMAIN_SEPARATOR,
keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
)
);
address recoveredAddress = ecrecover(digest, v, r, s);
require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
_approve(owner, spender, value);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-bridgeFor-0
元数据:{'block索引': 0, '函数名': 'bridgeFor', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function bridgeFor(address token) public view returns (address bridge) {
bridge = _bridges[token];
if (bridge == address(0)) {
bridge = weth;
}
}
// F1 - F10: OK
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-setBridge-1
元数据:{'block索引': 1, '函数名': 'setBridge', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token, address bridge', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LogBridgeSet']", '返回值': ''}
函数切片:
function setBridge(address token, address bridge) external onlyOwner {
// Checks
require(token != sushi && token != weth && token != bridge, "SushiMaker: Invalid bridge");
// Effects
_bridges[token] = bridge;
emit LogBridgeSet(token, bridge);
}
// M1 - M5: OK
// C1 - C24: OK
// C6: It's not a fool proof solution, but it prevents flash loans, so here it's ok to use tx.origin
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-onlyEOA-2
元数据:{'block索引': 2, '函数名': 'onlyEOA', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyEOA() {
// Try to make flash-loan exploit harder to do.
require(msg.sender == tx.origin, "SushiMaker: must use EOA");
_;
}
// F1 - F10: OK
// F3: _convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple
// F6: There is an exploit to add lots of SUSHI to the bar, run convert, then remove the SUSHI again.
//     As the size of the SushiBar has grown, this requires large amounts of funds and isn't super profitable anymore
//     The onlyEOA modifier prevents this being done with a flash loan.
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-convert-3
元数据:{'block索引': 3, '函数名': 'convert', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function convert(address token0, address token1) external onlyEOA() {
_convert(token0, token1);
}
// F1 - F10: OK, see convert
// C1 - C24: OK
// C3: Loop is under control of the caller
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-convertMultiple-4
元数据:{'block索引': 4, '函数名': 'convertMultiple', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address[] calldata token0, address[] calldata token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function convertMultiple(address[] calldata token0, address[] calldata token1) external onlyEOA() {
// TODO: This can be optimized a fair bit, but this is safer and simpler for now
uint256 len = token0.length;
for(uint256 i=0; i < len; i++) {
_convert(token0[i], token1[i]);
}
}
// F1 - F10: OK
// C1- C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_convert-5
元数据:{'block索引': 5, '函数名': '_convert', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LogConvert']", '返回值': ''}
函数切片:
function _convert(address token0, address token1) internal {
// Interactions
// S1 - S4: OK
IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));
require(address(pair) != address(0), "SushiMaker: Invalid pair");
// balanceOf: S1 - S4: OK
// transfer: X1 - X5: OK
IERC20(address(pair)).safeTransfer(address(pair), pair.balanceOf(address(this)));
// X1 - X5: OK
(uint256 amount0, uint256 amount1) = pair.burn(address(this));
if (token0 != pair.token0()) {
(amount0, amount1) = (amount1, amount0);
}
emit LogConvert(msg.sender, token0, token1, amount0, amount1, _convertStep(token0, token1, amount0, amount1));
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, _swap, _toSUSHI, _convertStep: X1 - X5: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_convertStep-6
元数据:{'block索引': 6, '函数名': '_convertStep', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1, uint256 amount0, uint256 amount1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _convertStep(address token0, address token1, uint256 amount0, uint256 amount1) internal returns(uint256 sushiOut) {
// Interactions
if (token0 == token1) {
uint256 amount = amount0.add(amount1);
if (token0 == sushi) {
IERC20(sushi).safeTransfer(bar, amount);
sushiOut = amount;
} else if (token0 == weth) {
sushiOut = _toSUSHI(weth, amount);
} else {
address bridge = bridgeFor(token0);
amount = _swap(token0, bridge, amount, address(this));
sushiOut = _convertStep(bridge, bridge, amount, 0);
}
} else if (token0 == sushi) { // eg. SUSHI - ETH
IERC20(sushi).safeTransfer(bar, amount0);
sushiOut = _toSUSHI(token1, amount1).add(amount0);
} else if (token1 == sushi) { // eg. USDT - SUSHI
IERC20(sushi).safeTransfer(bar, amount1);
sushiOut = _toSUSHI(token0, amount0).add(amount1);
} else if (token0 == weth) { // eg. ETH - USDC
sushiOut = _toSUSHI(weth, _swap(token1, weth, amount1, address(this)).add(amount0));
} else if (token1 == weth) { // eg. USDT - ETH
sushiOut = _toSUSHI(weth, _swap(token0, weth, amount0, address(this)).add(amount1));
} else { // eg. MIC - USDT
address bridge0 = bridgeFor(token0);
address bridge1 = bridgeFor(token1);
if (bridge0 == token1) { // eg. MIC - USDT - and bridgeFor(MIC) = USDT
sushiOut = _convertStep(bridge0, token1,
_swap(token0, bridge0, amount0, address(this)),
amount1
);
} else if (bridge1 == token0) { // eg. WBTC - DSD - and bridgeFor(DSD) = WBTC
sushiOut = _convertStep(token0, bridge1,
amount0,
_swap(token1, bridge1, amount1, address(this))
);
} else {
sushiOut = _convertStep(bridge0, bridge1, // eg. USDT - DSD - and bridgeFor(DSD) = WBTC
_swap(token0, bridge0, amount0, address(this)),
_swap(token1, bridge1, amount1, address(this))
);
}
}
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, swap: X1 - X5: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_swap-7
元数据:{'block索引': 7, '函数名': '_swap', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address fromToken, address toToken, uint256 amountIn, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _swap(address fromToken, address toToken, uint256 amountIn, address to) internal returns (uint256 amountOut) {
// Checks
// X1 - X5: OK
IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(fromToken, toToken));
require(address(pair) != address(0), "SushiMaker: Cannot convert");
// Interactions
// X1 - X5: OK
(uint256 reserve0, uint256 reserve1,) = pair.getReserves();
uint256 amountInWithFee = amountIn.mul(997);
if (fromToken == pair.token0()) {
amountOut = amountIn.mul(997).mul(reserve1) / reserve0.mul(1000).add(amountInWithFee);
IERC20(fromToken).safeTransfer(address(pair), amountIn);
pair.swap(0, amountOut, to, new bytes(0));
// TODO: Add maximum slippage?
} else {
amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);
IERC20(fromToken).safeTransfer(address(pair), amountIn);
pair.swap(amountOut, 0, to, new bytes(0));
// TODO: Add maximum slippage?
}
}
// F1 - F10: OK
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_toSUSHI-8
元数据:{'block索引': 8, '函数名': '_toSUSHI', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token, uint256 amountIn', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _toSUSHI(address token, uint256 amountIn) internal returns(uint256 amountOut) {
// X1 - X5: OK
amountOut = _swap(token, sushi, amountIn, bar);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-mint-0
元数据:{'block索引': 0, '函数名': 'mint', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'address _to, uint256 _amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address _to, uint256 _amount) public onlyOwner {
_mint(_to, _amount);
_moveDelegates(address(0), _delegates[_to], _amount);
}
// Copied and modified from YAM code:
// https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol
// https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol
// Which is copied and modified from COMPOUND:
// https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol
/// @notice A record of each accounts delegate
mapping (address => address) internal _delegates;
/// @notice A checkpoint for marking number of votes from a given block
struct Checkpoint {
uint32 fromBlock;
uint256 votes;
}
/// @notice A record of votes checkpoints for each account, by index
mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;
/// @notice The number of checkpoints for each account
mapping (address => uint32) public numCheckpoints;
/// @notice The EIP-712 typehash for the contract's domain
bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
/// @notice The EIP-712 typehash for the delegation struct used by the contract
bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
/// @notice A record of states for signing / validating signatures
mapping (address => uint) public nonces;
/// @notice An event thats emitted when an account changes its delegate
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
/// @notice An event thats emitted when a delegate account's vote balance changes
event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);
/**
* @notice Delegate votes from `msg.sender` to `delegatee`
* @param delegator The address to get delegatee for
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-delegates-1
元数据:{'block索引': 1, '函数名': 'delegates', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'address delegator', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function delegates(address delegator)
external
view
returns (address)
{
return _delegates[delegator];
}
/**
* @notice Delegate votes from `msg.sender` to `delegatee`
* @param delegatee The address to delegate votes to
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-delegate-2
元数据:{'block索引': 2, '函数名': 'delegate', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'address delegatee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function delegate(address delegatee) external {
return _delegate(msg.sender, delegatee);
}
/**
* @notice Delegates votes from signatory to `delegatee`
* @param delegatee The address to delegate votes to
* @param nonce The contract state required to match the signature
* @param expiry The time at which to expire the signature
* @param v The recovery byte of the signature
* @param r Half of the ECDSA signature pair
* @param s Half of the ECDSA signature pair
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function delegateBySig(
address delegatee,
uint nonce,
uint expiry,
uint8 v,
bytes32 r,
bytes32 s
)
external
{
bytes32 domainSeparator = keccak256(
abi.encode(
DOMAIN_TYPEHASH,
keccak256(bytes(name())),
getChainId(),
address(this)
)
);
bytes32 structHash = keccak256(
abi.encode(
DELEGATION_TYPEHASH,
delegatee,
nonce,
expiry
)
);
bytes32 digest = keccak256(
abi.encodePacked(
"\x19\x01",
domainSeparator,
structHash
)
);
address signatory = ecrecover(digest, v, r, s);
require(signatory != address(0), "SUSHI::delegateBySig: invalid signature");
require(nonce == nonces[signatory]++, "SUSHI::delegateBySig: invalid nonce");
require(now <= expiry, "SUSHI::delegateBySig: signature expired");
return _delegate(signatory, delegatee);
}
/**
* @notice Gets the current votes balance for `account`
* @param account The address to get votes balance
* @return The number of current votes for `account`
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-getCurrentVotes-4
元数据:{'block索引': 4, '函数名': 'getCurrentVotes', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'address account', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getCurrentVotes(address account)
external
view
returns (uint256)
{
uint32 nCheckpoints = numCheckpoints[account];
return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
}
/**
* @notice Determine the prior number of votes for an account as of a block number
* @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
* @param account The address of the account to check
* @param blockNumber The block number to get the vote balance at
* @return The number of votes the account had as of the given block
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-getPriorVotes-5
元数据:{'block索引': 5, '函数名': 'getPriorVotes', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'address account, uint blockNumber', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPriorVotes(address account, uint blockNumber)
external
view
returns (uint256)
{
require(blockNumber < block.number, "SUSHI::getPriorVotes: not yet determined");
uint32 nCheckpoints = numCheckpoints[account];
if (nCheckpoints == 0) {
return 0;
}
// First check most recent balance
if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
return checkpoints[account][nCheckpoints - 1].votes;
}
// Next check implicit zero balance
if (checkpoints[account][0].fromBlock > blockNumber) {
return 0;
}
uint32 lower = 0;
uint32 upper = nCheckpoints - 1;
while (upper > lower) {
uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
Checkpoint memory cp = checkpoints[account][center];
if (cp.fromBlock == blockNumber) {
return cp.votes;
} else if (cp.fromBlock < blockNumber) {
lower = center;
} else {
upper = center - 1;
}
}
return checkpoints[account][lower].votes;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-_delegate-6
元数据:{'block索引': 6, '函数名': '_delegate', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'address delegator, address delegatee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['DelegateChanged']", '返回值': ''}
函数切片:
function _delegate(address delegator, address delegatee)
internal
{
address currentDelegate = _delegates[delegator];
uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);
_delegates[delegator] = delegatee;
emit DelegateChanged(delegator, currentDelegate, delegatee);
_moveDelegates(currentDelegate, delegatee, delegatorBalance);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-_moveDelegates-7
元数据:{'block索引': 7, '函数名': '_moveDelegates', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'address srcRep, address dstRep, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {
if (srcRep != dstRep && amount > 0) {
if (srcRep != address(0)) {
// decrease old representative
uint32 srcRepNum = numCheckpoints[srcRep];
uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
uint256 srcRepNew = srcRepOld.sub(amount);
_writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
}
if (dstRep != address(0)) {
// increase new representative
uint32 dstRepNum = numCheckpoints[dstRep];
uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
uint256 dstRepNew = dstRepOld.add(amount);
_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
}
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-8
元数据:{'block索引': 8, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['DelegateVotesChanged']", '返回值': ''}
函数切片:
function _writeCheckpoint(
address delegatee,
uint32 nCheckpoints,
uint256 oldVotes,
uint256 newVotes
)
internal
{
uint32 blockNumber = safe32(block.number, "SUSHI::_writeCheckpoint: block number exceeds 32 bits");
if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
} else {
checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
numCheckpoints[delegatee] = nCheckpoints + 1;
}
emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-safe32-9
元数据:{'block索引': 9, '函数名': 'safe32', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': 'uint n, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
require(n < 2**32, errorMessage);
return uint32(n);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiToken.sol-getChainId-10
元数据:{'block索引': 10, '函数名': 'getChainId', '函数所属的合约或接口': 'SushiSwap.sol-SushiToken.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getChainId() internal pure returns (uint) {
uint256 chainId;
assembly { chainId := chainid() }
return chainId;
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-0
元数据:{'block索引': 0, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHSupportingFeeOnTransferTokens(
address token,
uint liquidity,
uint amountTokenMin,
uint amountETHMin,
address to,
uint deadline
) external returns (uint amountETH);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
address token,
uint liquidity,
uint amountTokenMin,
uint amountETHMin,
address to,
uint deadline,
bool approveMax, uint8 v, bytes32 r, bytes32 s
) external returns (uint amountETH);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForTokensSupportingFeeOnTransferTokens(
uint amountIn,
uint amountOutMin,
address[] calldata path,
address to,
uint deadline
) external;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForTokensSupportingFeeOnTransferTokens(
uint amountOutMin,
address[] calldata path,
address to,
uint deadline
) external payable;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForETHSupportingFeeOnTransferTokens(
uint amountIn,
uint amountOutMin,
address[] calldata path,
address to,
uint deadline
) external;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-feeTo-0
元数据:{'block索引': 0, '函数名': 'feeTo', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeTo() external view returns (address);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-feeToSetter-1
元数据:{'block索引': 1, '函数名': 'feeToSetter', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeToSetter() external view returns (address);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-migrator-2
元数据:{'block索引': 2, '函数名': 'migrator', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function migrator() external view returns (address);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-getPair-3
元数据:{'block索引': 3, '函数名': 'getPair', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPair(address tokenA, address tokenB) external view returns (address pair);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-allPairs-4
元数据:{'block索引': 4, '函数名': 'allPairs', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'uint', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairs(uint) external view returns (address pair);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-allPairsLength-5
元数据:{'block索引': 5, '函数名': 'allPairsLength', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairsLength() external view returns (uint);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-createPair-6
元数据:{'block索引': 6, '函数名': 'createPair', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function createPair(address tokenA, address tokenB) external returns (address pair);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-setFeeTo-7
元数据:{'block索引': 7, '函数名': 'setFeeTo', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo(address) external;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-setFeeToSetter-8
元数据:{'block索引': 8, '函数名': 'setFeeToSetter', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeToSetter(address) external;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-setMigrator-9
元数据:{'block索引': 9, '函数名': 'setMigrator', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setMigrator(address) external;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-IERC20.sol-totalSupply-0
元数据:{'block索引': 0, '函数名': 'totalSupply', '函数所属的合约或接口': 'SushiSwap.sol-IERC20.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() external view returns (uint256);
/**
* @dev Returns the amount of tokens owned by `account`.
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-IERC20.sol-balanceOf-1
元数据:{'block索引': 1, '函数名': 'balanceOf', '函数所属的合约或接口': 'SushiSwap.sol-IERC20.sol', '参数': 'address account', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address account) external view returns (uint256);
/**
* @dev Moves `amount` tokens from the caller's account to `recipient`.
*
* Returns a boolean value indicating whether the operation succeeded.
*
* Emits a {Transfer} event.
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-IERC20.sol-transfer-2
元数据:{'block索引': 2, '函数名': 'transfer', '函数所属的合约或接口': 'SushiSwap.sol-IERC20.sol', '参数': 'address recipient, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address recipient, uint256 amount) external returns (bool);
/**
* @dev Returns the remaining number of tokens that `spender` will be
* allowed to spend on behalf of `owner` through {transferFrom}. This is
* zero by default.
*
* This value changes when {approve} or {transferFrom} are called.
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-IERC20.sol-allowance-3
元数据:{'block索引': 3, '函数名': 'allowance', '函数所属的合约或接口': 'SushiSwap.sol-IERC20.sol', '参数': 'address owner, address spender', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allowance(address owner, address spender) external view returns (uint256);
/**
* @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
*
* Returns a boolean value indicating whether the operation succeeded.
*
* IMPORTANT: Beware that changing an allowance with this method brings the risk
* that someone may use both the old and the new allowance by unfortunate
* transaction ordering. One possible solution to mitigate this race
* condition is to first reduce the spender's allowance to 0 and set the
* desired value afterwards:
* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
*
* Emits an {Approval} event.
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-IERC20.sol-approve-4
元数据:{'block索引': 4, '函数名': 'approve', '函数所属的合约或接口': 'SushiSwap.sol-IERC20.sol', '参数': 'address spender, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint256 amount) external returns (bool);
/**
* @dev Moves `amount` tokens from `sender` to `recipient` using the
* allowance mechanism. `amount` is then deducted from the caller's
* allowance.
*
* Returns a boolean value indicating whether the operation succeeded.
*
* Emits a {Transfer} event.
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-IERC20.sol-transferFrom-5
元数据:{'block索引': 5, '函数名': 'transferFrom', '函数所属的合约或接口': 'SushiSwap.sol-IERC20.sol', '参数': 'address sender, address recipient, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
/**
* @dev Emitted when `value` tokens are moved from one account (`from`) to
* another (`to`).
*
* Note that `value` may be zero.
*/
event Transfer(address indexed from, address indexed to, uint256 value);
/**
* @dev Emitted when the allowance of a `spender` for an `owner` is set by
* a call to {approve}. `value` is the new allowance.
*/
event Approval(address indexed owner, address indexed spender, uint256 value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-BoringERC20.sol-safeSymbol-0
元数据:{'block索引': 0, '函数名': 'safeSymbol', '函数所属的合约或接口': 'SushiSwap.sol-BoringERC20.sol', '参数': 'IERC20 token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeSymbol(IERC20 token) internal view returns(string memory) {
(bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));
return success && data.length > 0 ? abi.decode(data, (string)) : "???";
}
------------------------------------------------
函数切片ID: SushiSwap.sol-BoringERC20.sol-safeName-1
元数据:{'block索引': 1, '函数名': 'safeName', '函数所属的合约或接口': 'SushiSwap.sol-BoringERC20.sol', '参数': 'IERC20 token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeName(IERC20 token) internal view returns(string memory) {
(bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));
return success && data.length > 0 ? abi.decode(data, (string)) : "???";
}
------------------------------------------------
函数切片ID: SushiSwap.sol-BoringERC20.sol-safeDecimals-2
元数据:{'block索引': 2, '函数名': 'safeDecimals', '函数所属的合约或接口': 'SushiSwap.sol-BoringERC20.sol', '参数': 'IERC20 token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeDecimals(IERC20 token) public view returns (uint8) {
(bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));
return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-BoringERC20.sol-safeTransfer-3
元数据:{'block索引': 3, '函数名': 'safeTransfer', '函数所属的合约或接口': 'SushiSwap.sol-BoringERC20.sol', '参数': 'IERC20 token, address to, uint256 amount', '可见性': 'public', '外部调用': True, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransfer(IERC20 token, address to, uint256 amount) internal {
(bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));
require(success && (data.length == 0 || abi.decode(data, (bool))), "BentoBox: Transfer failed");
}
------------------------------------------------
函数切片ID: SushiSwap.sol-BoringERC20.sol-safeTransferFrom-4
元数据:{'block索引': 4, '函数名': 'safeTransferFrom', '函数所属的合约或接口': 'SushiSwap.sol-BoringERC20.sol', '参数': 'IERC20 token, address from, uint256 amount', '可见性': 'public', '外部调用': True, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {
(bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));
require(success && (data.length == 0 || abi.decode(data, (bool))), "BentoBox: TransferFrom failed");
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-0
元数据:{'block索引': 0, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function migrateWithPermit(
address tokenA,
address tokenB,
uint256 liquidity,
uint256 amountAMin,
uint256 amountBMin,
uint256 deadline,
uint8 v,
bytes32 r,
bytes32 s
) public {
IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
pair.permit(msg.sender, address(this), liquidity, deadline, v, r, s);
migrate(tokenA, tokenB, liquidity, amountAMin, amountBMin, deadline);
}
// msg.sender should have approved 'liquidity' amount of LP token of 'tokenA' and 'tokenB'
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function migrate(
address tokenA,
address tokenB,
uint256 liquidity,
uint256 amountAMin,
uint256 amountBMin,
uint256 deadline
) public {
require(deadline >= block.timestamp, 'SushiSwap: EXPIRED');
// Remove liquidity from the old router with permit
(uint256 amountA, uint256 amountB) = removeLiquidity(
tokenA,
tokenB,
liquidity,
amountAMin,
amountBMin,
deadline
);
// Add liquidity to the new router
(uint256 pooledAmountA, uint256 pooledAmountB) = addLiquidity(tokenA, tokenB, amountA, amountB);
// Send remaining tokens to msg.sender
if (amountA > pooledAmountA) {
IERC20(tokenA).safeTransfer(msg.sender, amountA - pooledAmountA);
}
if (amountB > pooledAmountB) {
IERC20(tokenB).safeTransfer(msg.sender, amountB - pooledAmountB);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity(
address tokenA,
address tokenB,
uint256 liquidity,
uint256 amountAMin,
uint256 amountBMin,
uint256 deadline
) internal returns (uint256 amountA, uint256 amountB) {
IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
pair.transferFrom(msg.sender, address(pair), liquidity);
(uint256 amount0, uint256 amount1) = pair.burn(address(this));
(address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
(amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
require(amountA >= amountAMin, 'SushiRoll: INSUFFICIENT_A_AMOUNT');
require(amountB >= amountBMin, 'SushiRoll: INSUFFICIENT_B_AMOUNT');
}
// calculates the CREATE2 address for a pair without making any external calls
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-pairForOldRouter-3
元数据:{'block索引': 3, '函数名': 'pairForOldRouter', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function pairForOldRouter(address tokenA, address tokenB) internal view returns (address pair) {
(address token0, address token1) = UniswapV2Library.sortTokens(tokenA, tokenB);
pair = address(uint(keccak256(abi.encodePacked(
hex'ff',
oldRouter.factory(),
keccak256(abi.encodePacked(token0, token1)),
hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
))));
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity(
address tokenA,
address tokenB,
uint256 amountADesired,
uint256 amountBDesired
) internal returns (uint amountA, uint amountB) {
(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired);
address pair = UniswapV2Library.pairFor(router.factory(), tokenA, tokenB);
IERC20(tokenA).safeTransfer(pair, amountA);
IERC20(tokenB).safeTransfer(pair, amountB);
IUniswapV2Pair(pair).mint(msg.sender);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-5
元数据:{'block索引': 5, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _addLiquidity(
address tokenA,
address tokenB,
uint256 amountADesired,
uint256 amountBDesired
) internal returns (uint256 amountA, uint256 amountB) {
// create the pair if it doesn't exist yet
IUniswapV2Factory factory = IUniswapV2Factory(router.factory());
if (factory.getPair(tokenA, tokenB) == address(0)) {
factory.createPair(tokenA, tokenB);
}
(uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(address(factory), tokenA, tokenB);
if (reserveA == 0 && reserveB == 0) {
(amountA, amountB) = (amountADesired, amountBDesired);
} else {
uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
if (amountBOptimal <= amountBDesired) {
(amountA, amountB) = (amountADesired, amountBOptimal);
} else {
uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
assert(amountAOptimal <= amountADesired);
(amountA, amountB) = (amountAOptimal, amountBDesired);
}
}
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-Math.sol-min-0
元数据:{'block索引': 0, '函数名': 'min', '函数所属的合约或接口': 'SushiSwap.sol-Math.sol', '参数': 'uint x, uint y', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function min(uint x, uint y) internal pure returns (uint z) {
z = x < y ? x : y;
}
// babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
------------------------------------------------
函数切片ID: SushiSwap.sol-Math.sol-sqrt-1
元数据:{'block索引': 1, '函数名': 'sqrt', '函数所属的合约或接口': 'SushiSwap.sol-Math.sol', '参数': 'uint y', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sqrt(uint y) internal pure returns (uint z) {
if (y > 3) {
z = y;
uint x = y / 2 + 1;
while (x < z) {
z = x;
x = (y / x + x) / 2;
}
} else if (y != 0) {
z = 1;
}
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-mint-0
元数据:{'block索引': 0, '函数名': 'mint', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint (address account, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-burn-1
元数据:{'block索引': 1, '函数名': 'burn', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn (address account, uint256 amount) external;
}
/**
* The Monoswap is ERC1155 contract does this and that...
*/
contract Monoswap is Initializable, OwnableUpgradeable {
using SafeMath for uint256;
using SafeMath for uint112;
using SafeERC20 for IERC20;
using SafeERC20 for IvCash;
IvCash vCash;
address WETH;
address feeTo;
uint16 fees; // over 1e5, 300 means 0.3%
uint16 devFee; // over 1e5, 50 means 0.05%
uint256 constant MINIMUM_LIQUIDITY=100;
struct PoolInfo {
uint256 pid;
uint256 lastPoolValue;
address token;
PoolStatus status;
uint112 vcashDebt;
uint112 vcashCredit;
uint112 tokenBalance;
uint256 price; // over 1e18
uint256 createdAt; // timestamp
}
enum TxType {
SELL,
BUY
}
enum PoolStatus {
UNLISTED,
LISTED,
OFFICIAL,
SYNTHETIC,
PAUSED
}
mapping (address => PoolInfo) public pools;
// tokenStatus is for token lock/transfer. exempt means no need to verify post tx
mapping (address => uint8) private tokenStatus; //0=unlocked, 1=locked, 2=exempt
// token poool status is to track if the pool has already been created for the token
mapping (address => uint8) public tokenPoolStatus; //0=undefined, 1=exists
// negative vCash balance allowed for each token
mapping (address => uint) public tokenInsurance;
uint256 public poolSize;
uint private unlocked;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-lock-2
元数据:{'block索引': 2, '函数名': 'lock', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier lock() {
require(unlocked == 1, 'MonoX:LOCKED');
unlocked = 0;
_;
unlocked = 1;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-lockToken-3
元数据:{'block索引': 3, '函数名': 'lockToken', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier lockToken(address _token) {
uint8 originalState = tokenStatus[_token];
require(originalState!=1, 'MonoX:POOL_LOCKED');
if(originalState==0) {
tokenStatus[_token] = 1;
}
_;
if(originalState==0) {
tokenStatus[_token] = 0;
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-ensure-4
元数据:{'block索引': 4, '函数名': 'ensure', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier ensure(uint deadline) {
require(deadline >= block.timestamp, 'MonoX:EXPIRED');
_;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-onlyPriceAdjuster-5
元数据:{'block索引': 5, '函数名': 'onlyPriceAdjuster', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyPriceAdjuster(){
require(priceAdjusterRole[msg.sender]==true,"MonoX:BAD_ROLE");
_;
}
event AddLiquidity(address indexed provider,
uint indexed pid,
address indexed token,
uint liquidityAmount,
uint vcashAmount, uint tokenAmount, uint price);
event RemoveLiquidity(address indexed provider,
uint indexed pid,
address indexed token,
uint liquidityAmount,
uint vcashAmount, uint tokenAmount, uint price);
event Swap(
address indexed user,
address indexed tokenIn,
address indexed tokenOut,
uint amountIn,
uint amountOut,
uint swapVcashValue
);
// event PriceAdjusterChanged(
//   address indexed priceAdjuster,
//   bool added
// );
event PoolBalanced(
address _token,
uint vcashIn
);
event SyntheticPoolPriceChanged(
address _token,
uint price
);
event PoolStatusChanged(
address _token,
PoolStatus oldStatus,
PoolStatus newStatus
);
IMonoXPool public monoXPool;
// mapping (token address => block number of the last trade)
mapping (address => uint) public lastTradedBlock;
uint256 constant MINIMUM_POOL_VALUE = 10000 * 1e18;
mapping (address=>bool) public priceAdjusterRole;
// ------------
uint public poolSizeMinLimit;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-initialize-6
元数据:{'block索引': 6, '函数名': 'initialize', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'IMonoXPool _monoXPool, IvCash _vcash', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(IMonoXPool _monoXPool, IvCash _vcash) public initializer {
OwnableUpgradeable.__Ownable_init();
monoXPool = _monoXPool;
vCash = _vcash;
WETH = _monoXPool.WETH();
fees = 300;
devFee = 50;
poolSize = 0;
unlocked = 1;
}
// receive() external payable {
//   assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
// }
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setFeeTo-7
元数据:{'block索引': 7, '函数名': 'setFeeTo', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _feeTo', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo (address _feeTo) onlyOwner external {
feeTo = _feeTo;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setFees-8
元数据:{'block索引': 8, '函数名': 'setFees', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint16 _fees', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFees (uint16 _fees) onlyOwner external {
require(_fees<1e3);
fees = _fees;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setDevFee-9
元数据:{'block索引': 9, '函数名': 'setDevFee', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint16 _devFee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setDevFee (uint16 _devFee) onlyOwner external {
require(_devFee<1e3);
devFee = _devFee;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setPoolSizeMinLimit-10
元数据:{'block索引': 10, '函数名': 'setPoolSizeMinLimit', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint _poolSizeMinLimit', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setPoolSizeMinLimit(uint _poolSizeMinLimit) onlyOwner external {
poolSizeMinLimit = _poolSizeMinLimit;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setTokenInsurance-11
元数据:{'block索引': 11, '函数名': 'setTokenInsurance', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _insurance', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setTokenInsurance (address _token, uint _insurance) onlyOwner external {
tokenInsurance[_token] = _insurance;
}
// when safu, setting token status to 2 can achieve significant gas savings
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setTokenStatus-12
元数据:{'block索引': 12, '函数名': 'setTokenStatus', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint8 _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setTokenStatus (address _token, uint8 _status) onlyOwner external {
tokenStatus[_token] = _status;
}
// update status of a pool. onlyOwner.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePoolStatus-13
元数据:{'block索引': 13, '函数名': 'updatePoolStatus', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolStatusChanged']", '返回值': ''}
函数切片:
function updatePoolStatus(address _token, PoolStatus _status) external onlyOwner {
PoolStatus poolStatus = pools[_token].status;
if(poolStatus==PoolStatus.PAUSED){
require(block.number > lastTradedBlock[_token].add(6000), "MonoX:TOO_EARLY");
}
else{
// okay to pause an official pool, wait 6k blocks and then convert it to synthetic
require(_status!=PoolStatus.SYNTHETIC,"MonoX:NO_SYNT");
}
emit PoolStatusChanged(_token, poolStatus,_status);
pools[_token].status = _status;
// unlisting a token allows creating a new pool of the same token.
// should move it to PAUSED if the goal is to blacklist the token forever
if(_status==PoolStatus.UNLISTED) {
tokenPoolStatus[_token] = 0;
}
}
/**
@dev update pools price if there were no active trading for the last 6000 blocks
@notice Only owner callable, new price can neither be 0 nor be equal to old one
@param _token pool identifider (token address)
@param _newPrice new price in wei (uint112)
*/
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePoolPrice-14
元数据:{'block索引': 14, '函数名': 'updatePoolPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _newPrice', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function updatePoolPrice(address _token, uint _newPrice) external onlyOwner {
require(_newPrice > 0, 'MonoX:0_PRICE');
require(tokenPoolStatus[_token] != 0, "MonoX:NO_POOL");
require(block.number > lastTradedBlock[_token].add(6000), "MonoX:TOO_EARLY");
pools[_token].price = _newPrice;
lastTradedBlock[_token] = block.number;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePriceAdjuster-15
元数据:{'block索引': 15, '函数名': 'updatePriceAdjuster', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, bool _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PriceAdjusterChanged']", '返回值': ''}
函数切片:
function updatePriceAdjuster(address account, bool _status) external onlyOwner{
priceAdjusterRole[account]=_status;
//emit PriceAdjusterChanged(account,_status);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setSynthPoolPrice-16
元数据:{'block索引': 16, '函数名': 'setSynthPoolPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint price', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['SyntheticPoolPriceChanged']", '返回值': ''}
函数切片:
function setSynthPoolPrice(address _token, uint price) external onlyPriceAdjuster {
require(pools[_token].status==PoolStatus.SYNTHETIC,"MonoX:NOT_SYNT");
require(price > 0, "MonoX:ZERO_PRICE");
pools[_token].price=price;
emit SyntheticPoolPriceChanged(_token,price);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-rebalancePool-17
元数据:{'block索引': 17, '函数名': 'rebalancePool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolBalanced']", '返回值': ''}
函数切片:
function rebalancePool(address _token) external lockToken(_token) onlyOwner{
// // PoolInfo memory pool = pools[_token];
// uint poolPrice = pools[_token].price;
// require(vcashIn <= pools[_token].vcashDebt,"MonoX:NO_CREDIT");
// require((pools[_token].tokenBalance * poolPrice).div(1e18) >= vcashIn,"MonoX:INSUF_TOKEN_VAL");
// // uint rebalancedAmount = vcashIn.mul(1e18).div(pool.price);
// monoXPool.safeTransferERC20Token(_token, msg.sender, vcashIn.mul(1e18).div(poolPrice));
// _syncPoolInfo(_token, vcashIn, 0);
// emit PoolBalanced(_token, vcashIn);
_internalRebalance(_token);
}
// must be called from a method with token lock to prevent reentry
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_internalRebalance-18
元数据:{'block索引': 18, '函数名': '_internalRebalance', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolBalanced']", '返回值': ''}
函数切片:
function _internalRebalance(address _token) internal {
uint poolPrice = pools[_token].price;
uint vcashIn = pools[_token].vcashDebt;
if(poolPrice.mul(pools[_token].tokenBalance) / 1e18 < vcashIn){
vcashIn = poolPrice.mul(pools[_token].tokenBalance) / 1e18;
}
if(tokenStatus[_token]==2){
monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));
}else{
uint256 balanceIn0 = IERC20(_token).balanceOf(address(monoXPool));
monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));
uint256 balanceIn1 = IERC20(_token).balanceOf(address(monoXPool));
uint realAmount = balanceIn0.sub(balanceIn1);
vcashIn = realAmount.mul(poolPrice) / 1e18;
}
_syncPoolInfo(_token, vcashIn, 0);
emit PoolBalanced(_token,vcashIn);
}
// creates a pool
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_createPool-19
元数据:{'block索引': 19, '函数名': '_createPool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _price, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _createPool (address _token, uint _price, PoolStatus _status) lock internal returns(uint256 _pid)  {
require(tokenPoolStatus[_token]==0, "MonoX:POOL_EXISTS");
require (_token != address(vCash), "MonoX:NO_vCash");
_pid = poolSize;
pools[_token] = PoolInfo({
token: _token,
pid: _pid,
vcashCredit: 0,
vcashDebt: 0,
tokenBalance: 0,
lastPoolValue: 0,
status: _status,
price: _price,
createdAt: block.timestamp
});
poolSize = _pid.add(1);
tokenPoolStatus[_token]=1;
// initialze pool's lasttradingblocknumber as the block number on which the pool is created
lastTradedBlock[_token] = block.number;
}
// creates a pool with special status
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addSpecialToken-20
元数据:{'block索引': 20, '函数名': 'addSpecialToken', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _price, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addSpecialToken (address _token, uint _price, PoolStatus _status) onlyOwner external returns(uint256 _pid)  {
_pid = _createPool(_token, _price, _status);
}
// internal func to pay contract owner
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_mintFee-21
元数据:{'block索引': 21, '函数名': '_mintFee', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint256 pid, uint256 lastPoolValue, uint256 newPoolValue', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _mintFee (uint256 pid, uint256 lastPoolValue, uint256 newPoolValue) internal {
// dropping tx fees for now
return;
}
// util func to get some basic pool info
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-getPool-22
元数据:{'block索引': 22, '函数名': 'getPool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPool (address _token) view public returns (uint256 poolValue,
uint256 tokenBalanceVcashValue, uint256 vcashCredit, uint256 vcashDebt) {
// PoolInfo memory pool = pools[_token];
vcashCredit = pools[_token].vcashCredit;
vcashDebt = pools[_token].vcashDebt;
tokenBalanceVcashValue = pools[_token].price.mul(pools[_token].tokenBalance)/1e18;
poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
}
// trustless listing pool creation. always creates unofficial pool
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-23
元数据:{'block索引': 23, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function listNewToken (address _token, uint _price,
uint256 vcashAmount,
uint256 tokenAmount,
address to) external returns(uint _pid, uint256 liquidity) {
_pid = _createPool(_token, _price, PoolStatus.LISTED);
liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);
}
// add liquidity pair to a pool. allows adding vcash.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-24
元数据:{'block索引': 24, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityPair (address _token,
uint256 vcashAmount,
uint256 tokenAmount,
address to) external returns(uint256 liquidity) {
liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);
}
// add liquidity pair to a pool. allows adding vcash.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-25
元数据:{'block索引': 25, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['AddLiquidity']", '返回值': ''}
函数切片:
function _addLiquidityPair (address _token,
uint256 vcashAmount,
uint256 tokenAmount,
address from,
address to) internal lockToken(_token) returns(uint256 liquidity) {
require (tokenAmount>0, "MonoX:BAD_AMOUNT");
require(tokenPoolStatus[_token]==1, "MonoX:NO_POOL");
// (uint256 poolValue, , ,) = getPool(_token);
PoolInfo memory pool = pools[_token];
IMonoXPool monoXPoolLocal = monoXPool;
uint256 poolValue = pool.price.mul(pool.tokenBalance)/1e18;
poolValue = poolValue.add(pool.vcashCredit).sub(pool.vcashDebt);
_mintFee(pool.pid, pool.lastPoolValue, poolValue);
tokenAmount = transferAndCheck(from,address(monoXPoolLocal),_token,tokenAmount);
if(vcashAmount>0){
vCash.safeTransferFrom(msg.sender, address(monoXPoolLocal), vcashAmount);
vCash.burn(address(monoXPool), vcashAmount);
}
// this is to avoid stack too deep
{
uint256 _totalSupply = monoXPoolLocal.totalSupplyOf(pool.pid);
uint256 liquidityVcashValue = vcashAmount.add(tokenAmount.mul(pool.price)/1e18);
if(_totalSupply==0){
liquidityVcashValue = liquidityVcashValue/1e6; // so $1m would get you 1e18
liquidity = liquidityVcashValue.sub(MINIMUM_LIQUIDITY);
// sorry, oz doesn't allow minting to address(0)
monoXPoolLocal.mintLp(feeTo, pool.pid, MINIMUM_LIQUIDITY, pool.status == PoolStatus.LISTED);
}else{
liquidity = _totalSupply.mul(liquidityVcashValue).div(poolValue);
}
}
monoXPoolLocal.mintLp(to, pool.pid, liquidity, pool.status == PoolStatus.LISTED);
_syncPoolInfo(_token, vcashAmount, 0);
emit AddLiquidity(to,
pool.pid,
_token,
liquidity,
vcashAmount, tokenAmount, pool.price);
}
// add one-sided liquidity to a pool. no vcash
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addLiquidity-26
元数据:{'block索引': 26, '函数名': 'addLiquidity', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint256 _amount, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity (address _token, uint256 _amount, address to) external returns(uint256 liquidity)  {
liquidity = _addLiquidityPair(_token, 0, _amount, msg.sender, to);
}
// add one-sided ETH liquidity to a pool. no vcash
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addLiquidityETH-27
元数据:{'block索引': 27, '函数名': 'addLiquidityETH', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityETH (address to) external payable returns(uint256 liquidity)  {
MonoXLibrary.safeTransferETH(address(monoXPool), msg.value);
monoXPool.depositWETH(msg.value);
liquidity = _addLiquidityPair(WETH, 0, msg.value, address(this), to);
}
// updates pool vcash balance, token balance and last pool value.
// this function requires others to do the input validation
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_syncPoolInfo-28
元数据:{'block索引': 28, '函数名': '_syncPoolInfo', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint256 vcashIn, uint256 vcashOut', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _syncPoolInfo (address _token, uint256 vcashIn, uint256 vcashOut) internal {
// PoolInfo memory pool = pools[_token];
uint256 tokenPoolPrice = pools[_token].price;
(uint256 vcashCredit, uint256 vcashDebt) = _updateVcashBalance(_token, vcashIn, vcashOut);
uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));
uint256 tokenBalanceVcashValue = tokenPoolPrice.mul(tokenReserve)/1e18;
require(tokenReserve <= uint112(-1));
pools[_token].tokenBalance = uint112(tokenReserve);
// poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
pools[_token].lastPoolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
}
// view func for removing liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-29
元数据:{'block索引': 29, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _removeLiquidity (address _token, uint256 liquidity,
address to) view public returns(
uint256 poolValue, uint256 liquidityIn, uint256 vcashOut, uint256 tokenOut) {
require (liquidity>0, "MonoX:BAD_AMOUNT");
uint256 tokenBalanceVcashValue;
uint256 vcashCredit;
uint256 vcashDebt;
PoolInfo memory pool = pools[_token];
IMonoXPool monoXPoolLocal = monoXPool;
uint256 lastAdded = monoXPoolLocal.liquidityLastAddedOf(pool.pid, msg.sender);
require((lastAdded + (pool.status == PoolStatus.OFFICIAL ? 4 hours : pool.status == PoolStatus.LISTED ? 24 hours : 0)) <= block.timestamp, "MonoX:WRONG_TIME"); // Users are not allowed to remove liquidity right after adding
address topLPHolder = monoXPoolLocal.topLPHolderOf(pool.pid);
require(pool.status != PoolStatus.LISTED || msg.sender != topLPHolder || pool.createdAt + 90 days < block.timestamp, "MonoX:TOP_HOLDER & WRONG_TIME"); // largest LP holder is not allowed to remove LP within 90 days after pool creation
(poolValue, tokenBalanceVcashValue, vcashCredit, vcashDebt) = getPool(_token);
uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);
liquidityIn = monoXPool.balanceOf(to, pool.pid)>liquidity?liquidity:monoXPool.balanceOf(to, pool.pid);
uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));
if(tokenReserve < pool.tokenBalance){
tokenBalanceVcashValue = tokenReserve.mul(pool.price)/1e18;
}
if(vcashDebt>0){
tokenReserve = (tokenBalanceVcashValue.sub(vcashDebt)).mul(1e18).div(pool.price);
}
// if vcashCredit==0, vcashOut will be 0 as well
vcashOut = liquidityIn.mul(vcashCredit).div(_totalSupply);
tokenOut = liquidityIn.mul(tokenReserve).div(_totalSupply);
}
// actually removes liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-30
元数据:{'block索引': 30, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {
(vcashOut, tokenOut) = _removeLiquidityHelper (_token, liquidity, to, minVcashOut, minTokenOut, false);
}
// actually removes liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-31
元数据:{'block索引': 31, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidity']", '返回值': ''}
函数切片:
function _removeLiquidityHelper (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut,
bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut)  {
require (tokenPoolStatus[_token]==1, "MonoX:NO_TOKEN");
PoolInfo memory pool = pools[_token];
uint256 poolValue;
uint256 liquidityIn;
(poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to);
_mintFee(pool.pid, pool.lastPoolValue, poolValue);
require (vcashOut>=minVcashOut, "MonoX:INSUFF_vCash");
require (tokenOut>=minTokenOut, "MonoX:INSUFF_TOKEN");
if (vcashOut>0){
vCash.mint(to, vcashOut);
}
if (!isETH) {
monoXPool.safeTransferERC20Token(_token, to, tokenOut);
} else {
monoXPool.withdrawWETH(tokenOut);
monoXPool.safeTransferETH(to, tokenOut);
}
monoXPool.burn(to, pool.pid, liquidityIn);
_syncPoolInfo(_token, 0, vcashOut);
emit RemoveLiquidity(to,
pool.pid,
_token,
liquidityIn,
vcashOut, tokenOut, pool.price);
}
// actually removes ETH liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-32
元数据:{'block索引': 32, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETH (uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {
(vcashOut, tokenOut) = _removeLiquidityHelper (WETH, liquidity, to, minVcashOut, minTokenOut, true);
}
// util func to compute new price
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-33
元数据:{'block索引': 33, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getNewPrice (uint256 originalPrice, uint256 reserve,
uint256 delta, uint256 deltaBlocks, TxType txType) pure internal returns(uint256 price) {
if(txType==TxType.SELL) {
// no risk of being div by 0
price = originalPrice.mul(reserve)/(reserve.add(delta));
}else{ // BUY
price = originalPrice.mul(reserve).div(reserve.sub(delta));
}
}
// util func to compute new price
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_getAvgPrice-34
元数据:{'block索引': 34, '函数名': '_getAvgPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint256 originalPrice, uint256 newPrice', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getAvgPrice (uint256 originalPrice, uint256 newPrice) pure internal returns(uint256 price) {
price = originalPrice.add(newPrice.mul(4))/5;
}
// standard swap interface implementing uniswap router V2
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-35
元数据:{'block索引': 35, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForToken(
address tokenOut,
uint amountOutMin,
address to,
uint deadline
) external virtual payable ensure(deadline) returns (uint amountOut) {
uint amountIn = msg.value;
MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);
monoXPool.depositWETH(amountIn);
amountOut = swapIn(WETH, tokenOut, address(this), to, amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-36
元数据:{'block索引': 36, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokenForETH(
address tokenIn,
uint amountIn,
uint amountOutMin,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountOut) {
IMonoXPool monoXPoolLocal = monoXPool;
amountOut = swapIn(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
monoXPoolLocal.withdrawWETH(amountOut);
monoXPoolLocal.safeTransferETH(to, amountOut);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-37
元数据:{'block索引': 37, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapETHForExactToken(
address tokenOut,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual payable ensure(deadline) returns (uint amountIn) {
uint amountSentIn = msg.value;
( , , amountIn, ) = getAmountIn(WETH, tokenOut, amountOut);
MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);
monoXPool.depositWETH(amountIn);
amountIn = swapOut(WETH, tokenOut, address(this), to, amountOut);
require(amountIn <= amountSentIn, 'MonoX:BAD_INPUT');
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
if (amountSentIn > amountIn) {
MonoXLibrary.safeTransferETH(msg.sender, amountSentIn.sub(amountIn));
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-38
元数据:{'block索引': 38, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokenForExactETH(
address tokenIn,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountIn) {
IMonoXPool monoXPoolLocal = monoXPool;
amountIn = swapOut(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountOut);
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
monoXPoolLocal.withdrawWETH(amountOut);
monoXPoolLocal.safeTransferETH(to, amountOut);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-39
元数据:{'block索引': 39, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokenForToken(
address tokenIn,
address tokenOut,
uint amountIn,
uint amountOutMin,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountOut) {
amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-40
元数据:{'block索引': 40, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokenForExactToken(
address tokenIn,
address tokenOut,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountIn) {
amountIn = swapOut(tokenIn, tokenOut, msg.sender, to, amountOut);
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
}
// util func to manipulate vcash balance
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-41
元数据:{'block索引': 41, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _updateVcashBalance (address _token,
uint _vcashIn, uint _vcashOut) internal returns (uint _vcashCredit, uint _vcashDebt) {
if(_vcashIn>_vcashOut){
_vcashIn = _vcashIn - _vcashOut;
_vcashOut = 0;
}else{
_vcashOut = _vcashOut - _vcashIn;
_vcashIn = 0;
}
// PoolInfo memory _pool = pools[_token];
uint _poolVcashCredit = pools[_token].vcashCredit;
uint _poolVcashDebt = pools[_token].vcashDebt;
PoolStatus _poolStatus = pools[_token].status;
if(_vcashOut>0){
(_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceSub(
_poolVcashCredit, _poolVcashDebt, _vcashOut);
require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));
pools[_token].vcashCredit = uint112(_vcashCredit);
pools[_token].vcashDebt = uint112(_vcashDebt);
}
if(_vcashIn>0){
(_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceAdd(
_poolVcashCredit, _poolVcashDebt, _vcashIn);
require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));
pools[_token].vcashCredit = uint112(_vcashCredit);
pools[_token].vcashDebt = uint112(_vcashDebt);
}
if(_poolStatus == PoolStatus.LISTED){
require (_vcashDebt<=tokenInsurance[_token], "MonoX:INSUFF_vCash");
}
}
// updates pool token balance and price.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-42
元数据:{'block索引': 42, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _updateTokenInfo (address _token, uint256 _price,
uint256 _vcashIn, uint256 _vcashOut, uint256 _ETHDebt) internal {
uint256 _balance = IERC20(_token).balanceOf(address(monoXPool));
_balance = _balance.sub(_ETHDebt);
require(pools[_token].status!=PoolStatus.PAUSED,"MonoX:PAUSED");
require(_balance <= uint112(-1));
(uint initialPoolValue, , ,) = getPool(_token);
pools[_token].tokenBalance = uint112(_balance);
pools[_token].price = _price;
// record last trade's block number in mapping: lastTradedBlock
lastTradedBlock[_token] = block.number;
_updateVcashBalance(_token, _vcashIn, _vcashOut);
(uint poolValue, , ,) = getPool(_token);
require(initialPoolValue <= poolValue || poolValue >= poolSizeMinLimit,
"MonoX:MIN_POOL_SIZE");
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-43
元数据:{'block索引': 43, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function directSwapAllowed(uint tokenInPoolPrice,uint tokenOutPoolPrice,
uint tokenInPoolTokenBalance, uint tokenOutPoolTokenBalance, PoolStatus status, bool getsAmountOut) internal pure returns(bool){
uint tokenInValue  = tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18);
uint tokenOutValue = tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18);
bool priceExists   = getsAmountOut?tokenInPoolPrice>0:tokenOutPoolPrice>0;
// only if it's official pool with similar size
return priceExists&&status==PoolStatus.OFFICIAL&&tokenInValue>0&&tokenOutValue>0&&
((tokenInValue/tokenOutValue)+(tokenOutValue/tokenInValue)==1);
}
// view func to compute amount required for tokenIn to get fixed amount of tokenOut
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-44
元数据:{'block索引': 44, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountIn(address tokenIn, address tokenOut,
uint256 amountOut) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice,
uint256 amountIn, uint256 tradeVcashValue) {
require(amountOut > 0, 'MonoX:INSUFF_INPUT');
uint256 amountOutWithFee = amountOut.mul(1e5).div(1e5 - fees);
address vcashAddress = address(vCash);
uint tokenOutPoolPrice = pools[tokenOut].price;
uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;
if(tokenOut==vcashAddress){
tradeVcashValue = amountOutWithFee;
tokenOutPrice = 1e18;
}else{
require (tokenPoolStatus[tokenOut]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenOutPool = pools[tokenOut];
PoolStatus tokenOutPoolStatus = pools[tokenOut].status;
require (tokenOutPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance,
amountOutWithFee, 0, TxType.BUY);
tradeVcashValue = _getAvgPrice(tokenOutPoolPrice, tokenOutPrice).mul(amountOutWithFee)/1e18;
}
if(tokenIn==vcashAddress){
amountIn = tradeVcashValue;
tokenInPrice = 1e18;
}else{
require (tokenPoolStatus[tokenIn]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenInPool = pools[tokenIn];
PoolStatus tokenInPoolStatus = pools[tokenIn].status;
uint tokenInPoolPrice = pools[tokenIn].price;
uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;
require (tokenInPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
amountIn = tradeVcashValue.add(tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18));
amountIn = tradeVcashValue.mul(tokenInPoolTokenBalance).div(amountIn);
bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenInPoolStatus,false);
// assuming p1*p2 = k, equivalent to uniswap's x * y = k
uint directSwapTokenInPrice = allowDirectSwap?tokenOutPoolPrice.mul(tokenInPoolPrice).div(tokenOutPrice):1;
tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance,
amountIn, 0, TxType.SELL);
tokenInPrice = directSwapTokenInPrice > tokenInPrice?directSwapTokenInPrice:tokenInPrice;
amountIn = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenInPoolPrice, tokenInPrice));
}
}
// view func to compute amount required for tokenOut to get fixed amount of tokenIn
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-45
元数据:{'block索引': 45, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountOut(address tokenIn, address tokenOut,
uint256 amountIn) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice,
uint256 amountOut, uint256 tradeVcashValue) {
require(amountIn > 0, 'MonoX:INSUFF_INPUT');
uint256 amountInWithFee = amountIn.mul(1e5-fees)/1e5;
address vcashAddress = address(vCash);
uint tokenInPoolPrice = pools[tokenIn].price;
uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;
if(tokenIn==vcashAddress){
tradeVcashValue = amountInWithFee;
tokenInPrice = 1e18;
}else{
require (tokenPoolStatus[tokenIn]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenInPool = pools[tokenIn];
PoolStatus tokenInPoolStatus = pools[tokenIn].status;
require (tokenInPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance,
amountInWithFee, 0, TxType.SELL);
tradeVcashValue = _getAvgPrice(tokenInPoolPrice, tokenInPrice).mul(amountInWithFee)/1e18;
}
if(tokenOut==vcashAddress){
amountOut = tradeVcashValue;
tokenOutPrice = 1e18;
}else{
require (tokenPoolStatus[tokenOut]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenOutPool = pools[tokenOut];
PoolStatus tokenOutPoolStatus = pools[tokenOut].status;
uint tokenOutPoolPrice = pools[tokenOut].price;
uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;
require (tokenOutPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
amountOut = tradeVcashValue.add(tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18));
amountOut = tradeVcashValue.mul(tokenOutPoolTokenBalance).div(amountOut);
bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenOutPoolStatus,true);
// assuming p1*p2 = k, equivalent to uniswap's x * y = k
uint directSwapTokenOutPrice = allowDirectSwap?tokenInPoolPrice.mul(tokenOutPoolPrice).div(tokenInPrice):uint(-1);
// prevent the attack where user can use a small pool to update price in a much larger pool
tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance,
amountOut, 0, TxType.BUY);
tokenOutPrice = directSwapTokenOutPrice < tokenOutPrice?directSwapTokenOutPrice:tokenOutPrice;
amountOut = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenOutPoolPrice, tokenOutPrice));
}
}
// swap from tokenIn to tokenOut with fixed tokenIn amount.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-46
元数据:{'block索引': 46, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Swap']", '返回值': ''}
函数切片:
function swapIn (address tokenIn, address tokenOut, address from, address to,
uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {
address monoXPoolLocal = address(monoXPool);
amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);
// uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;
uint256 tokenInPrice;
uint256 tokenOutPrice;
uint256 tradeVcashValue;
(tokenInPrice, tokenOutPrice, amountOut, tradeVcashValue) = getAmountOut(tokenIn, tokenOut, amountIn);
uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;
// trading in
if(tokenIn==address(vCash)){
vCash.burn(monoXPoolLocal, amountIn);
// all fees go to the other side
oneSideFeesInVcash = oneSideFeesInVcash.mul(2);
}else{
_updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);
}
// trading out
if(tokenOut==address(vCash)){
vCash.mint(to, amountOut);
}else{
if (to != monoXPoolLocal) {
IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);
}
_updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0,
to == monoXPoolLocal ? amountOut : 0);
}
if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){
_internalRebalance(tokenIn);
}
emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);
}
// swap from tokenIn to tokenOut with fixed tokenOut amount.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-47
元数据:{'block索引': 47, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Swap']", '返回值': ''}
函数切片:
function swapOut (address tokenIn, address tokenOut, address from, address to,
uint256 amountOut) internal lockToken(tokenIn) returns(uint256 amountIn)  {
uint256 tokenInPrice;
uint256 tokenOutPrice;
uint256 tradeVcashValue;
(tokenInPrice, tokenOutPrice, amountIn, tradeVcashValue) = getAmountIn(tokenIn, tokenOut, amountOut);
address monoXPoolLocal = address(monoXPool);
amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);
// uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;
uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;
// trading in
if(tokenIn==address(vCash)){
vCash.burn(monoXPoolLocal, amountIn);
// all fees go to buy side
oneSideFeesInVcash = oneSideFeesInVcash.mul(2);
}else {
_updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);
}
// trading out
if(tokenOut==address(vCash)){
vCash.mint(to, amountOut);
// all fees go to sell side
_updateVcashBalance(tokenIn, oneSideFeesInVcash, 0);
}else{
if (to != monoXPoolLocal) {
IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);
}
_updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0,
to == monoXPoolLocal ? amountOut:0 );
}
if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){
_internalRebalance(tokenIn);
}
emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);
}
// function balanceOf(address account, uint256 id) public view returns (uint256) {
//   return monoXPool.balanceOf(account, id);
// }
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-getConfig-48
元数据:{'block索引': 48, '函数名': 'getConfig', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getConfig() public view returns (address _vCash, address _weth, address _feeTo, uint16 _fees, uint16 _devFee) {
_vCash = address(vCash);
_weth = WETH;
_feeTo = feeTo;
_fees = fees;
_devFee = devFee;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-transferAndCheck-49
元数据:{'block索引': 49, '函数名': 'transferAndCheck', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address from,address to,address _token,uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferAndCheck(address from,address to,address _token,uint amount) internal returns (uint256){
if(from == address(this)){
return amount; // if it's ETH
}
// if it's not ETH
if(tokenStatus[_token]==2){
IERC20(_token).safeTransferFrom(from, to, amount);
return amount;
}else{
uint256 balanceIn0 = IERC20(_token).balanceOf(to);
IERC20(_token).safeTransferFrom(from, to, amount);
uint256 balanceIn1 = IERC20(_token).balanceOf(to);
return balanceIn1.sub(balanceIn0);
}
}
}
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-mint-0
元数据:{'block索引': 0, '函数名': 'mint', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address account, uint256 id, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint (address account, uint256 id, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-burn-1
元数据:{'block索引': 1, '函数名': 'burn', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address account, uint256 id, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn (address account, uint256 id, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-totalSupplyOf-2
元数据:{'block索引': 2, '函数名': 'totalSupplyOf', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 pid', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupplyOf(uint256 pid) external view returns (uint256);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-depositWETH-3
元数据:{'block索引': 3, '函数名': 'depositWETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function depositWETH(uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-withdrawWETH-4
元数据:{'block索引': 4, '函数名': 'withdrawWETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdrawWETH(uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-safeTransferETH-5
元数据:{'block索引': 5, '函数名': 'safeTransferETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address to, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferETH(address to, uint amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-safeTransferERC20Token-6
元数据:{'block索引': 6, '函数名': 'safeTransferERC20Token', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address token, address to, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferERC20Token(address token, address to, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-WETH-7
元数据:{'block索引': 7, '函数名': 'WETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function WETH() external view returns (address);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-liquidityLastAddedOf-8
元数据:{'block索引': 8, '函数名': 'liquidityLastAddedOf', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 pid, address account', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function liquidityLastAddedOf(uint256 pid, address account) external view returns(uint256);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-topLPHolderOf-9
元数据:{'block索引': 9, '函数名': 'topLPHolderOf', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 pid', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function topLPHolderOf(uint256 pid) external view returns (address);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-mintLp-10
元数据:{'block索引': 10, '函数名': 'mintLp', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address account, uint256 id, uint256 amount, bool _isOfficial', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mintLp(address account, uint256 id, uint256 amount, bool _isOfficial) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-setWhitelist-11
元数据:{'block索引': 11, '函数名': 'setWhitelist', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address _whitelister, bool _isWhitelister', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setWhitelist(address _whitelister, bool _isWhitelister) external;
}
------------------------------------------------
函数切片ID: MonoX.sol-SafeERC20.sol-safeTransfer-0
元数据:{'block索引': 0, '函数名': 'safeTransfer', '函数所属的合约或接口': 'MonoX.sol-SafeERC20.sol', '参数': 'IERC20 token, address to, uint256 value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransfer(IERC20 token, address to, uint256 value) internal {
_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
}
------------------------------------------------
函数切片ID: MonoX.sol-SafeERC20.sol-safeTransferFrom-1
元数据:{'block索引': 1, '函数名': 'safeTransferFrom', '函数所属的合约或接口': 'MonoX.sol-SafeERC20.sol', '参数': 'IERC20 token, address from, address to, uint256 value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
}
/**
* @dev Deprecated. This function has issues similar to the ones found in
* {IERC20-approve}, and its usage is discouraged.
*
* Whenever possible, use {safeIncreaseAllowance} and
* {safeDecreaseAllowance} instead.
*/
------------------------------------------------
函数切片ID: MonoX.sol-SafeERC20.sol-safeApprove-2
元数据:{'block索引': 2, '函数名': 'safeApprove', '函数所属的合约或接口': 'MonoX.sol-SafeERC20.sol', '参数': 'IERC20 token, address spender, uint256 value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeApprove(IERC20 token, address spender, uint256 value) internal {
// safeApprove should only be called when setting an initial allowance,
// or when resetting it to zero. To increase and decrease it, use
// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
// solhint-disable-next-line max-line-length
require((value == 0) || (token.allowance(address(this), spender) == 0),
"SafeERC20: approve from non-zero to non-zero allowance"
);
_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
}
------------------------------------------------
函数切片ID: MonoX.sol-SafeERC20.sol-safeIncreaseAllowance-3
元数据:{'block索引': 3, '函数名': 'safeIncreaseAllowance', '函数所属的合约或接口': 'MonoX.sol-SafeERC20.sol', '参数': 'IERC20 token, address spender, uint256 value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
uint256 newAllowance = token.allowance(address(this), spender).add(value);
_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
}
------------------------------------------------
函数切片ID: MonoX.sol-SafeERC20.sol-safeDecreaseAllowance-4
元数据:{'block索引': 4, '函数名': 'safeDecreaseAllowance', '函数所属的合约或接口': 'MonoX.sol-SafeERC20.sol', '参数': 'IERC20 token, address spender, uint256 value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");
_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
}
/**
* @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
* on the return value: the return value is optional (but if data is returned, it must not be false).
* @param token The token targeted by the call.
* @param data The call data (encoded using abi.encode or one of its variants).
*/
------------------------------------------------
函数切片ID: MonoX.sol-SafeERC20.sol-_callOptionalReturn-5
元数据:{'block索引': 5, '函数名': '_callOptionalReturn', '函数所属的合约或接口': 'MonoX.sol-SafeERC20.sol', '参数': 'IERC20 token, bytes memory data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _callOptionalReturn(IERC20 token, bytes memory data) private {
// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
// the target address contains contract code and also asserts for success in the low-level call.
bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
if (returndata.length > 0) { // Return data is optional
// solhint-disable-next-line max-line-length
require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
}
}
}
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-balanceOf-0
元数据:{'block索引': 0, '函数名': 'balanceOf', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address account, uint256 id', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address account, uint256 id) external view returns (uint256);
/**
* @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
*
* Requirements:
*
* - `accounts` and `ids` must have the same length.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-balanceOfBatch-1
元数据:{'block索引': 1, '函数名': 'balanceOfBatch', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address[] calldata accounts, uint256[] calldata ids', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
/**
* @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
*
* Emits an {ApprovalForAll} event.
*
* Requirements:
*
* - `operator` cannot be the caller.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-setApprovalForAll-2
元数据:{'block索引': 2, '函数名': 'setApprovalForAll', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address operator, bool approved', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setApprovalForAll(address operator, bool approved) external;
/**
* @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
*
* See {setApprovalForAll}.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-isApprovedForAll-3
元数据:{'block索引': 3, '函数名': 'isApprovedForAll', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address account, address operator', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isApprovedForAll(address account, address operator) external view returns (bool);
/**
* @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
*
* Emits a {TransferSingle} event.
*
* Requirements:
*
* - `to` cannot be the zero address.
* - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
* - `from` must have a balance of tokens of type `id` of at least `amount`.
* - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
* acceptance magic value.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-safeTransferFrom-4
元数据:{'block索引': 4, '函数名': 'safeTransferFrom', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address from, address to, uint256 id, uint256 amount, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
/**
* @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
*
* Emits a {TransferBatch} event.
*
* Requirements:
*
* - `ids` and `amounts` must have the same length.
* - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
* acceptance magic value.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-safeBatchTransferFrom-5
元数据:{'block索引': 5, '函数名': 'safeBatchTransferFrom', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-name-0
元数据:{'block索引': 0, '函数名': 'name', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function name() external pure returns (string memory);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-symbol-1
元数据:{'block索引': 1, '函数名': 'symbol', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function symbol() external pure returns (string memory);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-decimals-2
元数据:{'block索引': 2, '函数名': 'decimals', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decimals() external pure returns (uint8);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-totalSupply-3
元数据:{'block索引': 3, '函数名': 'totalSupply', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-balanceOf-4
元数据:{'block索引': 4, '函数名': 'balanceOf', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-allowance-5
元数据:{'block索引': 5, '函数名': 'allowance', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner, address spender', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allowance(address owner, address spender) external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-approve-6
元数据:{'block索引': 6, '函数名': 'approve', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-transfer-7
元数据:{'block索引': 7, '函数名': 'transfer', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-transferFrom-8
元数据:{'block索引': 8, '函数名': 'transferFrom', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-DOMAIN_SEPARATOR-9
元数据:{'block索引': 9, '函数名': 'DOMAIN_SEPARATOR', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function DOMAIN_SEPARATOR() external view returns (bytes32);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-PERMIT_TYPEHASH-10
元数据:{'block索引': 10, '函数名': 'PERMIT_TYPEHASH', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function PERMIT_TYPEHASH() external pure returns (bytes32);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-nonces-11
元数据:{'block索引': 11, '函数名': 'nonces', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function nonces(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-permit-12
元数据:{'block索引': 12, '函数名': 'permit', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
event Swap(
address indexed sender,
uint amount0In,
uint amount1In,
uint amount0Out,
uint amount1Out,
address indexed to
);
event Sync(uint112 reserve0, uint112 reserve1);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-MINIMUM_LIQUIDITY-13
元数据:{'block索引': 13, '函数名': 'MINIMUM_LIQUIDITY', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function MINIMUM_LIQUIDITY() external pure returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-factory-14
元数据:{'block索引': 14, '函数名': 'factory', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function factory() external view returns (address);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-token0-15
元数据:{'block索引': 15, '函数名': 'token0', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token0() external view returns (address);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-token1-16
元数据:{'block索引': 16, '函数名': 'token1', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token1() external view returns (address);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-getReserves-17
元数据:{'block索引': 17, '函数名': 'getReserves', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-price0CumulativeLast-18
元数据:{'block索引': 18, '函数名': 'price0CumulativeLast', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price0CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-price1CumulativeLast-19
元数据:{'block索引': 19, '函数名': 'price1CumulativeLast', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price1CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-kLast-20
元数据:{'block索引': 20, '函数名': 'kLast', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function kLast() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-mint-21
元数据:{'block索引': 21, '函数名': 'mint', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address to) external returns (uint liquidity);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-burn-22
元数据:{'block索引': 22, '函数名': 'burn', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn(address to) external returns (uint amount0, uint amount1);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-swap-23
元数据:{'block索引': 23, '函数名': 'swap', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'uint amount0Out, uint amount1Out, address to, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-skim-24
元数据:{'block索引': 24, '函数名': 'skim', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function skim(address to) external;
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-sync-25
元数据:{'block索引': 25, '函数名': 'sync', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sync() external;
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-initialize-26
元数据:{'block索引': 26, '函数名': 'initialize', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address, address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(address, address) external;
}
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-name-0
元数据:{'block索引': 0, '函数名': 'name', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function name() external pure returns (string memory);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-symbol-1
元数据:{'block索引': 1, '函数名': 'symbol', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function symbol() external pure returns (string memory);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-decimals-2
元数据:{'block索引': 2, '函数名': 'decimals', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decimals() external pure returns (uint8);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-totalSupply-3
元数据:{'block索引': 3, '函数名': 'totalSupply', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-balanceOf-4
元数据:{'block索引': 4, '函数名': 'balanceOf', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-allowance-5
元数据:{'block索引': 5, '函数名': 'allowance', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner, address spender', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allowance(address owner, address spender) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-approve-6
元数据:{'block索引': 6, '函数名': 'approve', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-transfer-7
元数据:{'block索引': 7, '函数名': 'transfer', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-transferFrom-8
元数据:{'block索引': 8, '函数名': 'transferFrom', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-DOMAIN_SEPARATOR-9
元数据:{'block索引': 9, '函数名': 'DOMAIN_SEPARATOR', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function DOMAIN_SEPARATOR() external view returns (bytes32);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-PERMIT_TYPEHASH-10
元数据:{'block索引': 10, '函数名': 'PERMIT_TYPEHASH', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function PERMIT_TYPEHASH() external pure returns (bytes32);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-nonces-11
元数据:{'block索引': 11, '函数名': 'nonces', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function nonces(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-permit-12
元数据:{'block索引': 12, '函数名': 'permit', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
event Swap(
address indexed sender,
uint amount0In,
uint amount1In,
uint amount0Out,
uint amount1Out,
address indexed to
);
event Sync(uint112 reserve0, uint112 reserve1);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-MINIMUM_LIQUIDITY-13
元数据:{'block索引': 13, '函数名': 'MINIMUM_LIQUIDITY', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function MINIMUM_LIQUIDITY() external pure returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-factory-14
元数据:{'block索引': 14, '函数名': 'factory', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function factory() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-token0-15
元数据:{'block索引': 15, '函数名': 'token0', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token0() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-token1-16
元数据:{'block索引': 16, '函数名': 'token1', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token1() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-getReserves-17
元数据:{'block索引': 17, '函数名': 'getReserves', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-price0CumulativeLast-18
元数据:{'block索引': 18, '函数名': 'price0CumulativeLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price0CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-price1CumulativeLast-19
元数据:{'block索引': 19, '函数名': 'price1CumulativeLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price1CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-kLast-20
元数据:{'block索引': 20, '函数名': 'kLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function kLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-mint-21
元数据:{'block索引': 21, '函数名': 'mint', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address to) external returns (uint liquidity);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-burn-22
元数据:{'block索引': 22, '函数名': 'burn', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn(address to) external returns (uint amount0, uint amount1);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-swap-23
元数据:{'block索引': 23, '函数名': 'swap', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'uint amount0Out, uint amount1Out, address to, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-skim-24
元数据:{'block索引': 24, '函数名': 'skim', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function skim(address to) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-sync-25
元数据:{'block索引': 25, '函数名': 'sync', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sync() external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-initialize-26
元数据:{'block索引': 26, '函数名': 'initialize', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address, address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(address, address) external;
}
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeTo-0
元数据:{'block索引': 0, '函数名': 'feeTo', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeTo() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeToSetter-1
元数据:{'block索引': 1, '函数名': 'feeToSetter', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeToSetter() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeAmount-2
元数据:{'block索引': 2, '函数名': 'feeAmount', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeAmount() external view returns (uint16);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-owner-3
元数据:{'block索引': 3, '函数名': 'owner', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function owner() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-getPair-4
元数据:{'block索引': 4, '函数名': 'getPair', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPair(address tokenA, address tokenB) external view returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-allPairs-5
元数据:{'block索引': 5, '函数名': 'allPairs', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'uint', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairs(uint) external view returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-allPairsLength-6
元数据:{'block索引': 6, '函数名': 'allPairsLength', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairsLength() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-createPair-7
元数据:{'block索引': 7, '函数名': 'createPair', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function createPair(address tokenA, address tokenB) external returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-setFeeTo-8
元数据:{'block索引': 8, '函数名': 'setFeeTo', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo(address) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-setFeeToSetter-9
元数据:{'block索引': 9, '函数名': 'setFeeToSetter', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeToSetter(address) external;
}
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-factory-0
元数据:{'block索引': 0, '函数名': 'factory', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function factory() external pure returns (address);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-WETH-1
元数据:{'block索引': 1, '函数名': 'WETH', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function WETH() external pure returns (address);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-addLiquidity-2
元数据:{'block索引': 2, '函数名': 'addLiquidity', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-addLiquidityETH-3
元数据:{'block索引': 3, '函数名': 'addLiquidityETH', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-removeLiquidity-4
元数据:{'block索引': 4, '函数名': 'removeLiquidity', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-removeLiquidityETH-5
元数据:{'block索引': 5, '函数名': 'removeLiquidityETH', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-removeLiquidityWithPermit-6
元数据:{'block索引': 6, '函数名': 'removeLiquidityWithPermit', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-removeLiquidityETHWithPermit-7
元数据:{'block索引': 7, '函数名': 'removeLiquidityETHWithPermit', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapExactTokensForTokens-8
元数据:{'block索引': 8, '函数名': 'swapExactTokensForTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapTokensForExactTokens-9
元数据:{'block索引': 9, '函数名': 'swapTokensForExactTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapExactETHForTokens-10
元数据:{'block索引': 10, '函数名': 'swapExactETHForTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapTokensForExactETH-11
元数据:{'block索引': 11, '函数名': 'swapTokensForExactETH', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapExactTokensForETH-12
元数据:{'block索引': 12, '函数名': 'swapExactTokensForETH', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapETHForExactTokens-13
元数据:{'block索引': 13, '函数名': 'swapETHForExactTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-quote-14
元数据:{'block索引': 14, '函数名': 'quote', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountA, uint reserveA, uint reserveB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-getAmountOut-15
元数据:{'block索引': 15, '函数名': 'getAmountOut', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint reserveIn, uint reserveOut', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-getAmountIn-16
元数据:{'block索引': 16, '函数名': 'getAmountIn', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, uint reserveIn, uint reserveOut', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-getAmountsOut-17
元数据:{'block索引': 17, '函数名': 'getAmountsOut', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, address[] calldata path', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-getAmountsIn-18
元数据:{'block索引': 18, '函数名': 'getAmountsIn', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, address[] calldata path', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-removeLiquidityETHSupportingFeeOnTransferTokens-19
元数据:{'block索引': 19, '函数名': 'removeLiquidityETHSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-removeLiquidityETHWithPermitSupportingFeeOnTransferTokens-20
元数据:{'block索引': 20, '函数名': 'removeLiquidityETHWithPermitSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapExactTokensForTokensSupportingFeeOnTransferTokens-21
元数据:{'block索引': 21, '函数名': 'swapExactTokensForTokensSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapExactETHForTokensSupportingFeeOnTransferTokens-22
元数据:{'block索引': 22, '函数名': 'swapExactETHForTokensSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-IUniswapV2Router.sol-swapExactTokensForETHSupportingFeeOnTransferTokens-23
元数据:{'block索引': 23, '函数名': 'swapExactTokensForETHSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-2.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
}
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-factory-0
元数据:{'block索引': 0, '函数名': 'factory', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function factory() external pure returns (address);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-WETH-1
元数据:{'block索引': 1, '函数名': 'WETH', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function WETH() external pure returns (address);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-addLiquidity-2
元数据:{'block索引': 2, '函数名': 'addLiquidity', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity( address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB, uint liquidity);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-addLiquidityETH-3
元数据:{'block索引': 3, '函数名': 'addLiquidityETH', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityETH( address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-removeLiquidity-4
元数据:{'block索引': 4, '函数名': 'removeLiquidity', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline ) external returns (uint amountA, uint amountB);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-removeLiquidityETH-5
元数据:{'block索引': 5, '函数名': 'removeLiquidityETH', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETH( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountToken, uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-removeLiquidityWithPermit-6
元数据:{'block索引': 6, '函数名': 'removeLiquidityWithPermit', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityWithPermit( address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountA, uint amountB);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-removeLiquidityETHWithPermit-7
元数据:{'block索引': 7, '函数名': 'removeLiquidityETHWithPermit', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHWithPermit( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountToken, uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapExactTokensForTokens-8
元数据:{'block索引': 8, '函数名': 'swapExactTokensForTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapTokensForExactTokens-9
元数据:{'block索引': 9, '函数名': 'swapTokensForExactTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapExactETHForTokens-10
元数据:{'block索引': 10, '函数名': 'swapExactETHForTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapTokensForExactETH-11
元数据:{'block索引': 11, '函数名': 'swapTokensForExactETH', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapExactTokensForETH-12
元数据:{'block索引': 12, '函数名': 'swapExactTokensForETH', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapETHForExactTokens-13
元数据:{'block索引': 13, '函数名': 'swapETHForExactTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-quote-14
元数据:{'block索引': 14, '函数名': 'quote', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountA, uint reserveA, uint reserveB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-getAmountOut-15
元数据:{'block索引': 15, '函数名': 'getAmountOut', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint reserveIn, uint reserveOut', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-getAmountIn-16
元数据:{'block索引': 16, '函数名': 'getAmountIn', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, uint reserveIn, uint reserveOut', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-getAmountsOut-17
元数据:{'block索引': 17, '函数名': 'getAmountsOut', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, address[] calldata path', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-getAmountsIn-18
元数据:{'block索引': 18, '函数名': 'getAmountsIn', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountOut, address[] calldata path', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-removeLiquidityETHSupportingFeeOnTransferTokens-19
元数据:{'block索引': 19, '函数名': 'removeLiquidityETHSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-removeLiquidityETHWithPermitSupportingFeeOnTransferTokens-20
元数据:{'block索引': 20, '函数名': 'removeLiquidityETHWithPermitSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH);
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapExactTokensForTokensSupportingFeeOnTransferTokens-21
元数据:{'block索引': 21, '函数名': 'swapExactTokensForTokensSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapExactETHForTokensSupportingFeeOnTransferTokens-22
元数据:{'block索引': 22, '函数名': 'swapExactETHForTokensSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable;
------------------------------------------------
函数切片ID: Punk Protocol-1.sol-IUniswapV2Router.sol-swapExactTokensForETHSupportingFeeOnTransferTokens-23
元数据:{'block索引': 23, '函数名': 'swapExactTokensForETHSupportingFeeOnTransferTokens', '函数所属的合约或接口': 'Punk Protocol-1.sol-IUniswapV2Router.sol', '参数': 'uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external;
}
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-add-0
元数据:{'block索引': 0, '函数名': 'add', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
require(c >= a, "SafeMath: addition overflow");
return c;
}
/**
* @dev Returns the subtraction of two unsigned integers, reverting on
* overflow (when the result is negative).
*
* Counterpart to Solidity's `-` operator.
*
* Requirements:
*
* - Subtraction cannot overflow.
*/
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-sub-1
元数据:{'block索引': 1, '函数名': 'sub', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
return sub(a, b, "SafeMath: subtraction overflow");
}
/**
* @dev Returns the subtraction of two unsigned integers, reverting with custom message on
* overflow (when the result is negative).
*
* Counterpart to Solidity's `-` operator.
*
* Requirements:
*
* - Subtraction cannot overflow.
*/
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-sub-2
元数据:{'block索引': 2, '函数名': 'sub', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
require(b <= a, errorMessage);
uint256 c = a - b;
return c;
}
/**
* @dev Returns the multiplication of two unsigned integers, reverting on
* overflow.
*
* Counterpart to Solidity's `*` operator.
*
* Requirements:
*
* - Multiplication cannot overflow.
*/
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-mul-3
元数据:{'block索引': 3, '函数名': 'mul', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
// Gas optimization: this is cheaper than requiring 'a' not being zero, but the
// benefit is lost if 'b' is also tested.
// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
if (a == 0) {
return 0;
}
uint256 c = a * b;
require(c / a == b, "SafeMath: multiplication overflow");
return c;
}
/**
* @dev Returns the integer division of two unsigned integers. Reverts on
* division by zero. The result is rounded towards zero.
*
* Counterpart to Solidity's `/` operator. Note: this function uses a
* `revert` opcode (which leaves remaining gas untouched) while Solidity
* uses an invalid opcode to revert (consuming all remaining gas).
*
* Requirements:
*
* - The divisor cannot be zero.
*/
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-div-4
元数据:{'block索引': 4, '函数名': 'div', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return div(a, b, "SafeMath: division by zero");
}
/**
* @dev Returns the integer division of two unsigned integers. Reverts with custom message on
* division by zero. The result is rounded towards zero.
*
* Counterpart to Solidity's `/` operator. Note: this function uses a
* `revert` opcode (which leaves remaining gas untouched) while Solidity
* uses an invalid opcode to revert (consuming all remaining gas).
*
* Requirements:
*
* - The divisor cannot be zero.
*/
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-div-5
元数据:{'block索引': 5, '函数名': 'div', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
require(b > 0, errorMessage);
uint256 c = a / b;
// assert(a == b * c + a % b); // There is no case in which this doesn't hold
return c;
}
/**
* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
* Reverts when dividing by zero.
*
* Counterpart to Solidity's `%` operator. This function uses a `revert`
* opcode (which leaves remaining gas untouched) while Solidity uses an
* invalid opcode to revert (consuming all remaining gas).
*
* Requirements:
*
* - The divisor cannot be zero.
*/
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-mod-6
元数据:{'block索引': 6, '函数名': 'mod', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mod(uint256 a, uint256 b) internal pure returns (uint256) {
return mod(a, b, "SafeMath: modulo by zero");
}
/**
* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
* Reverts with custom message when dividing by zero.
*
* Counterpart to Solidity's `%` operator. This function uses a `revert`
* opcode (which leaves remaining gas untouched) while Solidity uses an
* invalid opcode to revert (consuming all remaining gas).
*
* Requirements:
*
* - The divisor cannot be zero.
*/
------------------------------------------------
函数切片ID: Fortress Protocol.sol-SafeMath.sol-mod-7
元数据:{'block索引': 7, '函数名': 'mod', '函数所属的合约或接口': 'Fortress Protocol.sol-SafeMath.sol', '参数': 'uint256 a, uint256 b, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
require(b != 0, errorMessage);
return a % b;
}
}
------------------------------------------------
排名结果：
函数切片ID,分数
SushiSwap.sol-UniswapV2ERC20.sol-_mint-0,0.95
SushiSwap.sol-SushiMaker.sol-_swap-7,0.90
SushiSwap.sol-SushiMaker.sol-_convert-5,0.85
SushiSwap.sol-SushiMaker.sol-convert-3,0.80
SushiSwap.sol-SushiMaker.sol-convertMultiple-4,0.75
SushiSwap.sol-UniswapV2ERC20.sol-_burn-1,0.70
SushiSwap.sol-SushiMaker.sol-setBridge-1,0.65
MonoX.sol-Monoswap.sol-mint-0,0.60
MonoX.sol-Monoswap.sol-burn-1,0.55
SushiSwap.sol-SushiToken.sol-mint-0,0.50
SushiSwap.sol-BoringERC20.sol-safeTransfer-3,0.45
SushiSwap.sol-BoringERC20.sol-safeTransferFrom-4,0.40
SushiSwap.sol-IUniswapV2Router02.sol-swapExactTokensForTokensSupportingFeeOnTransferTokens-2,0.35
SushiSwap.sol-IUniswapV2Router02.sol-swapExactETHForTokensSupportingFeeOnTransferTokens-3,0.30
SushiSwap.sol-IUniswapV2Router02.sol-swapExactTokensForETHSupportingFeeOnTransferTokens-4,0.25
SushiSwap.sol-Math.sol-sqrt-1,0.20
SushiSwap.sol-Math.sol-min-0,0.15
Fortress Protocol.sol-SafeMath.sol-mul-3,0.10
Fortress Protocol.sol-SafeMath.sol-div-4,0.05
Fortress Protocol.sol-SafeMath.sol-add-0,0.00