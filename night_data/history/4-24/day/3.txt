------------------------------------------------
交易故障分析：
问题/异常点分析：在故障交易0x90fb0c99中，用户通过Sushiswap路由合约将3.45 WBTC（约$100,000）兑换为3,568,000 SUSHI（约$4,200,000），实现超过40倍异常收益，而正常交易（如0x7df39084）的兑换收益比例符合市场价差。异常点集中于WBTC/WETH和WETH/SUSHI流动性池的储备量被操纵，导致兑换比率严重偏离合理范围。

漏洞原因分析：攻击者通过闪电贷（Flash Loan）对多个流动性池实施价格操控攻击。具体步骤为：1. 从WBTC/WETH池（0x9a138670）借出大量WBTC，人为降低该池的WBTC储备量；2. 触发路由合约的swap函数，利用被扭曲的WBTC/WETH汇率获取超额WETH；3. 将异常数量的WETH注入WETH/SUSHI池（0x795065dc），通过Sync事件更新虚假储备量；4. 完成SUSHI兑换后归还闪电贷。此过程暴露了以下漏洞：1）流动性池未实现时间加权平均价格（TWAP）机制，允许单区块内价格剧烈波动；2）路由合约未验证跨池交易的储备量同步性，接受已被闪电贷扭曲的价格数据；3）SUSHI质押合约（0x8798249c）未设置滑点保护，允许异常大额交易通过。

攻击链关键操作：1. 通过0x9a138670池的Transfer事件销毁604,800,790 SLP代币，人为改变WBTC/WETH比例；2. 调用0x022c0d9f函数执行无滑点检查的兑换；3. 最终向质押地址转移的SUSHI数量（14,662,164,107,484）超过该池总供应量的5%，造成永久性价格偏移。

trace调用链：0x51841d9afe... → 路由合约0xe11fc0b43a → Sushiswap WBTC/WETH池0x9a138670 → Sushiswap WETH/SNX池0xceff5175 → Sushiswap WETH/SUSHI池0x795065dc → SUSHI质押合约0x8798249c2e
------------------------------------------------
向量库匹配结果：
{'ids': [['SushiSwap.sol-SushiRoll.sol', 'SushiSwap.sol-SushiMaker.sol', 'Saddle Finance.sol-ISwap.sol', 'SushiSwap.sol-UniswapV2ERC20.sol', 'MonoX.sol-Monoswap.sol', 'MonoX.sol-IERC1155.sol', 'Rikkei Finance.sol-InterestRateModel.sol', 'Saddle Finance.sol-MetaSwapUtils.sol', 'Nmbplatform.sol-SafeERC20.sol', 'SushiSwap.sol-IUniswapV2Router02.sol', 'Indexed Finance.sol-IUniswapV2Pair.sol', 'Li.Fi.sol-LibAsset.sol', 'MERLIN LABS.sol-ILottery.sol', 'SushiSwap.sol-SushiSwapPairMock.sol', 'Beanstalk.sol-LibMeta.sol', 'Alchemix.sol-Context.sol', 'Qubit Finance.sol-IQBridgeHandler.sol', 'Li.Fi.sol-AnyswapFacet.sol', 'Li.Fi.sol-LibSwap.sol', 'Uranium Finance-4.sol-IUraniumPair.sol', 'Punk Protocol-2.sol-CompoundModel.sol', 'Li.Fi.sol-StorageSlot.sol', 'Alchemix.sol-VaultWithIndirection.sol', 'NBA NFT.sol-sale_configuration.sol', 'SushiSwap.sol-IUniswapV2Factory.sol', 'MonoX.sol-SafeERC20.sol', 'Beanstalk.sol-Decimal.sol', 'Cover Protocol.sol-COVER.sol', 'Uranium Finance-4.sol-IUraniumFactory.sol', 'Alchemix.sol-Address.sol', 'MonoX.sol-IMonoXPool.sol', 'Qubit Finance.sol-QBridgeToken.sol', 'CreamFinance-1.sol-CarefulMath.sol', 'Rikkei Finance.sol-CarefulMath.sol', 'Visor Finance.sol-Arrays.sol', 'Qubit Finance.sol-QBridgeHandler.sol', 'Saddle Finance.sol-SwapUtils.sol', 'SushiSwap.sol-SushiBar.sol', 'MonoX.sol-MonoXLibrary.sol', 'Li.Fi.sol-SafeERC20.sol']], 'distances': [[0.2454235553741455, 0.24956387281417847, 0.27152377367019653, 0.284925639629364, 0.2986009120941162, 0.3181259036064148, 0.32361793518066406, 0.334003210067749, 0.3405001163482666, 0.343131422996521, 0.3442559242248535, 0.3456640839576721, 0.34619712829589844, 0.34680837392807007, 0.3537846803665161, 0.35558265447616577, 0.35737842321395874, 0.3575359582901001, 0.3582605719566345, 0.35918857001935345, 0.3601568341255188, 0.3608276844024658, 0.3613291382789612, 0.3621895909309387, 0.36295807361602783, 0.36395692825317383, 0.3645869493484497, 0.36537235975265503, 0.3658790236930226, 0.36793893575668335, 0.3682394027709961, 0.36864733695983887, 0.3710591793060303, 0.37141263484954834, 0.3720382441782609, 0.3722049593925476, 0.37257254123687744, 0.37271904945373535, 0.37298184633255005, 0.37418484687805176]], 'embeddings': None, 'metadatas': None, 'documents': [['该智能合约名为SushiRoll，核心功能是帮助用户将Uniswap V2的流动性池（LP）代币迁移至SushiSwap。合约通过移除用户在Uniswap的流动性，并将代币重新注入SushiSwap的新流动性池中，完成LP代币的转换。迁移过程支持两种方式：带许可签名（permit）的授权迁移和常规授权迁移。合约关键点包括：1. 移除旧路由器的流动性时，需满足最小代币数量（amountAMin/amountBMin）和截止时间（deadline）；2. 添加流动性到新路由器时，自动计算最优代币比例，确保符合SushiSwap池的储备要求；3. 迁移后剩余代币会返还用户。合约通过UniswapV2Library进行地址排序、储备量查询等操作，并采用CREATE2方式计算旧路由器的Pair合约地址，避免外部调用。\n\n函数列表：\n1. 构造函数：初始化新旧路由器的地址（oldRouter和router）\n2. migrateWithPermit：通过许可签名授权后执行迁移，参数包含tokenA/B、流动性数量、最小代币量、截止时间及签名v/r/s\n3. migrate：核心迁移函数，处理流动性移除、添加及剩余代币返还\n4. removeLiquidity（internal）：从旧路由器移除流动性，返回实际获得的代币数量\n5. pairForOldRouter（internal view）：计算旧路由器中指定代币对的Pair合约地址\n6. addLiquidity（internal）：向新路由器添加流动性并铸造LP代币给用户\n7. _addLiquidity（internal）：计算添加流动性的最优代币量，必要时创建新Pair合约', '总结：该智能合约名为SushiMaker，核心功能是通过兑换流动性池中的代币为SUSHI代币，并将收益分配给xSushi持有者。合约通过销毁Uniswap V2 LP代币获取基础代币，再经过多步兑换逻辑将代币转换为SUSHI并发送至SushiBar合约。合约采用桥接代币机制处理非直接兑换路径，仅允许外部账户（EOA）调用关键函数以防止闪电贷攻击。主要流程包括获取LP代币、销毁LP代币获得基础资产、根据代币类型选择兑换路径（包括直接处理SUSHI/WETH、桥接代币兑换等），最终通过Uniswap V2交易对完成兑换。合约包含权限管理功能，仅允许所有者设置桥接代币地址。\n\n函数列表：\n1. bridgeFor(address token)：查询指定代币的桥接代币地址，默认返回WETH。\n2. setBridge(address token, address bridge)：所有者设置代币的桥接代币地址。\n3. convert(address token0, address token1)：外部EOA调用，处理单个交易对的代币转换。\n4. convertMultiple(address[] token0, address[] token1)：外部EOA调用，批量处理多个交易对的转换。\n5. _convert(address token0, address token1)：内部函数，执行LP代币销毁和基础代币提取。\n6. _convertStep(address token0, address token1, uint256 amount0, uint256 amount1)：内部函数，处理多路径代币兑换逻辑。\n7. _swap(address fromToken, address toToken, uint256 amountIn, address to)：内部函数，执行Uniswap V2交易对的实际兑换操作。\n8. _toSUSHI(address token, uint256 amountIn)：内部函数，将任意代币兑换为SUSHI并发送至Bar合约。', '该智能合约可命名为"Swap流动性池管理合约"，主要实现多代币流动性池的创建、代币兑换及流动性管理功能。合约基于自动化做市商(AMC)机制，包含代币兑换、流动性添加/移除、资金池参数管理等核心功能，支持多代币池配置与白名单机制。关键功能包含：1）通过恒定乘积算法实现代币兑换 2）支持灵活添加/移除流动性的多种模式 3）内置手续费机制（常规费率和管理员费率）4）LP代币的铸造与销毁管理 5）提供多种资金池数据查询接口。\n\n函数列表：\ngetA：获取资金池放大系数\ngetAllowlist：读取白名单合约地址\ngetToken：根据索引获取对应代币\ngetTokenIndex：通过代币地址查询索引号\ngetTokenBalance：查询指定代币的池内余额\ngetVirtualPrice：获取LP代币的虚拟价格\nisGuarded：检查防护状态\ncalculateSwap：计算兑换预期获得量\ncalculateTokenAmount：计算添加流动性对应LP数量\ncalculateRemoveLiquidity：计算全额移除流动性所得代币\ncalculateRemoveLiquidityOneToken：计算单币种移除流动性可得数量\ninitialize：初始化资金池参数\nswap：执行代币兑换交易\naddLiquidity：添加流动性并铸造LP代币\nremoveLiquidity：移除流动性并销毁LP代币\nremoveLiquidityOneToken：单币种移除流动性\nremoveLiquidityImbalance：非对称移除流动性。', '该智能合约是 SushiSwap 的流动性池代币（LP Token）实现，基于 ERC20 标准并扩展了离线授权功能。合约代币名称为"SushiSwap LP Token"(SLP)，提供基础代币转账、授权功能，同时通过 EIP-712 标准实现了 Permit 离线签名授权机制，允许用户通过数字签名完成代币授权操作，无需提前发送链上交易。合约包含代币铸造/销毁功能，但相关方法设为内部函数，需通过继承机制由外部合约调用，体现其作为流动性池代币的设计特性。\n\n函数列表：\n1. 构造函数：初始化代币基础信息并创建 EIP-712 域分隔符\n2. _mint（内部）：向指定地址增发代币并更新总供应量\n3. _burn（内部）：销毁指定地址的代币并减少总供应量\n4. _approve（私有）：处理代币授权逻辑并触发 Approval 事件\n5. _transfer（私有）：执行代币转账逻辑并触发 Transfer 事件\n6. approve（外部）：公开的授权接口，允许第三方操作指定数量的代币\n7. transfer（外部）：标准代币转账功能\n8. transferFrom（外部）：允许被授权方转移代币，支持无限授权优化\n9. permit（外部）：通过验证 EIP-712 签名实现离线授权，规避单独授权交易', 'Monoswap 智能合约总结：该合约是基于 ERC1155 标准实现的去中心化交易所核心合约，采用单边流动性模型并支持多种代币交易。核心功能包括流动性池管理、代币兑换、动态价格调整和手续费机制。合约通过 vCash 虚拟代币实现流动性管理，支持 ETH/WETH 交易对，并包含官方池、合成池等多种池状态管理。关键特性包含：1. 支持创建/移除流动性池 2. 实现基于价格滑点的自动做市算法 3. 可调节的交易手续费和开发者费用 4. 池状态锁定机制防止重入攻击 5. 提供多种兑换路径处理 ETH 与代币交易。\n\n函数列表：\n- initialize：初始化合约基础配置\n- setFeeTo：设置手续费接收地址\n- setFees：设置交易手续费率\n- setDevFee：设置开发者费用率\n- setPoolSizeMinLimit：设置最小池规模限制\n- setTokenInsurance：设置代币保险金额\n- setTokenStatus：设置代币锁定状态\n- updatePoolStatus：更新池状态（仅管理员）\n- updatePoolPrice：更新池价格（需冷却期）\n- updatePriceAdjuster：设置价格调节权限\n- setSynthPoolPrice：设置合成池价格\n- rebalancePool：执行池再平衡\n- addSpecialToken：创建特殊状态池\n- listNewToken：创建新代币池\n- addLiquidityPair：添加双向流动性\n- addLiquidity：添加单边流动性\n- addLiquidityETH：添加 ETH 流动性\n- removeLiquidity：移除流动性\n- removeLiquidityETH：移除 ETH 流动性\n- swapExactETHForToken：ETH 兑换代币\n- swapExactTokenForETH：代币兑换 ETH\n- swapETHForExactToken：指定数量 ETH 兑换\n- swapTokenForExactETH：指定数量代币兑换\n- swapExactTokenForToken：代币间兑换\n- swapTokenForExactToken：指定数量代币兑换\n- getPool：获取池信息\n- getAmountIn：计算输入金额\n- getAmountOut：计算输出金额\n- getConfig：获取系统配置参数', '该智能合约被命名为 IERC1155（ERC1155 标准接口），是基于 EIP-1155 标准定义的多代币管理接口合约，继承自 IERC165 接口。其主要功能为实现非同质化代币（NFT）和同质化代币（FT）的统一管理标准，支持批量转账、余额查询及操作员授权机制。合约通过事件记录代币转账、授权状态变更及元数据 URI 更新，要求实现代币接收方的安全验证回调。核心特性包括允许单次/批量转账、批量余额查询、操作员全局授权控制，并强制要求接收合约实现安全转账回调逻辑。\n\n函数列表如下：\n1. balanceOf：查询指定地址中特定代币 ID 的余额数量\n2. balanceOfBatch：批量查询多个地址对应多个代币 ID 的余额（原子性操作，全部成功或回滚）\n3. setApprovalForAll：授权或撤销某操作员对调用者所有代币的管理权限\n4. isApprovedForAll：检查指定操作员是否被授权管理某账户的全部代币\n5. safeTransferFrom：安全转账单个代币类型，需验证接收方合约的回调\n6. safeBatchTransferFrom：批量安全转账多个代币类型，需验证接收方合约的批量回调', 'InterestRateModel 智能合约总结：该合约是由 Rifi 开发的利率模型接口合约，主要用于定义去中心化金融市场中的借贷利率计算标准。合约通过两个核心函数抽象化利率计算逻辑，为具体利率模型实现提供接口规范。关键特性包括：1. 包含 isInterestRateModel 标识常量用于合约类型验证；2. 声明借款利率计算函数 getBorrowRate，接收市场现金总量、未偿借款和准备金作为输入参数；3. 声明供应利率计算函数 getSupplyRate，额外接收储备因子参数。该合约作为抽象接口，需要具体实现合约继承后完善实际利率计算逻辑，支持不同利率模型策略的灵活扩展，其返回值均采用 1e18 精度标准，确保计算精度满足 DeFi 应用需求。\n\n函数列表：\n1. getBorrowRate：计算每个区块的借款利率，参数为市场现金总额(cash)、未偿借款总额(borrows)、准备金总额(reserves)，返回经过 1e18 缩放后的借款利率百分比\n2. getSupplyRate：计算每个区块的存款利率，参数增加储备因子(reserveFactorMantissa)，返回经过 1e18 缩放后的存款利率百分比', 'MetaSwapUtils库是一个用于支持MetaSwap合约的智能合约工具库，旨在实现跨池流动性管理与代币交换功能。其核心功能是通过扩展基础Swap池的LP代币用途，允许用户在MetaSwap池中将基础池的LP代币与其他代币（如稳定币）进行组合，实现跨层交易。例如，用户可在MetaSwap池中交易基础池的LP代币与sUSD，同时支持底层代币的间接兑换。该库通过缓存机制优化基础池虚拟价格查询，降低Gas消耗，并提供流动性添加/移除、代币交换（包括底层代币）、手续费计算等关键功能。其算法基于Stableswap模型，处理多币种池的平衡计算，并通过动态更新基础池数据确保价格准确性。\n\n函数列表如下：\n1. _getBaseVirtualPrice：获取基础Swap池的虚拟价格，若缓存过期则实时更新。\n2. calculateWithdrawOneToken：计算用户单币种提取时应得的代币数量。\n3. calculateSwap：计算普通代币交换的预期输出量。\n4. calculateSwapUnderlying：计算跨基础池与MetaSwap池的代币交换结果。\n5. calculateTokenAmount：估算存入/提取流动性对LP代币数量的影响。\n6. getVirtualPrice：返回MetaSwap池的虚拟价格，用于收益计算。\n7. swap：执行MetaSwap池内代币的交换操作。\n8. swapUnderlying：执行跨基础池与MetaSwap池的代币交换，支持底层代币路径。\n9. addLiquidity：添加流动性到池中并铸造LP代币。\n10. removeLiquidityOneToken：移除单币种流动性并销毁LP代币。\n11. removeLiquidityImbalance：按非比例提取多种代币的流动性。\n12. _updateBaseVirtualPrice：更新基础池虚拟价格缓存，确保数据时效性。', 'SafeERC20 库总结：该智能合约是 OpenZeppelin 提供的 SafeERC20 安全操作库，主要用于增强 ERC20 代币操作的安全性。其核心功能是通过封装标准的 ERC20 操作（如转账、授权等），统一处理可能出现的调用失败情况，并对兼容 EIP-2612 的 ERC20Permit 代币提供许可签名验证功能。关键特性包括：1. 对所有 ERC20 操作添加返回值验证，防止忽略返回 false 的失败情况；2. 提供安全的授权额度调整方法，避免常见的前后授权竞争问题；3. 集成 permit 签名验证功能，支持免转账手续费授权操作；4. 通过低级调用实现兼容性处理，支持无返回值类型的代币合约。该库通过引入安全封装方法（如 safeTransfer、safeIncreaseAllowance 等），显著降低开发者直接调用 ERC20 接口时的潜在风险。\n\n函数列表：  \n- safeTransfer(IERC20,address,uint256)：安全转账函数，验证 ERC20 转账操作结果  \n- safeTransferFrom(IERC20,address,address,uint256)：安全跨账户转账，验证 transferFrom 结果  \n- safeApprove(IERC20,address,uint256)：授权操作（已弃用），强制要求从零地址开始授权  \n- safeIncreaseAllowance(IERC20,address,uint256)：安全增加授权额度，采用增量方式避免竞争条件  \n- safeDecreaseAllowance(IERC20,address,uint256)：安全减少授权额度，防止额度减至负数  \n- safePermit(IERC20Permit,address,address,uint256,uint256,uint8,bytes32,bytes32)：执行 EIP-2612 许可签名验证，包含 nonce 校验  \n- _callOptionalReturn(IERC20,bytes)：内部基础方法，执行低级调用并验证返回数据', '该智能合约是 Uniswap V2 路由器的扩展接口合约，主要用于支持转账时带有手续费代币的交易场景。合约继承自 IUniswapV2Router01 并新增了五个关键函数，核心功能围绕流动性移除和代币兑换操作进行优化，允许用户在执行交易时自动处理转账扣费代币的余额计算问题。其中移除流动性函数支持直接返还 ETH，并提供带数字签名授权（Permit）的版本以简化用户操作流程。swap 系列函数均支持精确输入金额的交易模式，并适配转账扣费机制，覆盖代币与代币、ETH 与代币之间的兑换场景。\n\n函数列表：\n1. removeLiquidityETHSupportingFeeOnTransferTokens：移除流动性并返还 ETH，支持转账扣费代币\n2. removeLiquidityETHWithPermitSupportingFeeOnTransferTokens：通过签名授权移除流动性并返 ETH，支持扣费代币\n3. swapExactTokensForTokensSupportingFeeOnTransferTokens：精确输入代币兑换代币，支持扣费代币\n4. swapExactETHForTokensSupportingFeeOnTransferTokens：精确输入 ETH 兑换代币，支持扣费代币\n5. swapExactTokensForETHSupportingFeeOnTransferTokens：精确输入代币兑换 ETH，支持扣费代币\n\n（注意：继承自 IUniswapV2Router01 的父接口函数未在本列表重复列出）', 'UniswapV2Pair 智能合约接口总结：该智能合约定义了 Uniswap V2 去中心化交易所中流动性池的核心功能，作为 ERC20 标准代币实现交易对池化资产管理。合约通过自动化做市商机制实现代币兑换，包含流动性铸造/销毁、代币交换、储备金同步等核心功能，并集成 ERC2612 签名授权特性。关键功能包括通过 mint/burn 函数进行流动性增减管理，swap 函数执行代币兑换，以及通过 getReserves 获取实时资金池状态。合约通过事件流记录资金变动，维护价格累积变量实现链上价格追踪。\n\n函数列表如下：\n1. name() - 获取流动性代币名称\n2. symbol() - 获取代币符号\n3. decimals() - 返回代币精度\n4. totalSupply() - 查询代币总供应量\n5. balanceOf() - 查询指定地址余额\n6. allowance() - 查询授权额度\n7. approve() - 设置代币操作权限\n8. transfer() - 转账代币\n9. transferFrom() - 从指定地址转账\n10. DOMAIN_SEPARATOR() - 获取 EIP712 域分隔符\n11. PERMIT_TYPEHASH() - 返回许可类型哈希\n12. nonces() - 查询地址的许可随机数\n13. permit() - 通过签名执行授权\n14. MINIMUM_LIQUIDITY() - 获取最小流动性限制\n15. factory() - 查询所属工厂地址\n16. token0() - 获取第一个代币地址\n17. token1() - 获取第二个代币地址\n18. getReserves() - 返回当前储备量及时间戳\n19. price0CumulativeLast() - 获取代币0价格累积值\n20. price1CumulativeLast() - 获取代币1价格累积值\n21. kLast() - 查询最后储备乘积值\n22. mint() - 铸造流动性代币\n23. burn() - 销毁流动性代币并提取基础资产\n24. swap() - 执行代币兑换交易\n25. skim() - 调整储备与余额的差异\n26. sync() - 强制同步储备数据\n27. initialize() - 初始化交易对代币地址', 'LibAsset 库合约总结：该智能合约是一个用于处理链上资产转账的工具库，主要功能为统一管理原生代币与 ERC20 标准代币的资产操作。合约通过 NATIVE_ASSETID 常量定义原生资产标识符（地址 0），实现了对两种类型资产的兼容处理。核心功能包含资产类型判断、余额查询、安全转账及代币授权四大模块，通过 OpenZeppelin 的 SafeERC20 库处理非常规 ERC20 代币的兼容性问题。合约特色在于采用 MAX_INT 最大授权量模式规避部分代币的授权漏洞，并通过 transferAsset 方法实现资产类型自动判断的统一转账接口，提升了多类型资产操作的安全性。\n\n函数列表：\nisNativeAsset：判断指定资产地址是否为原生代币\ngetOwnBalance：查询当前合约持有的指定资产余额\ntransferNativeAsset：执行原生代币转账至指定地址\napproveERC20：设置 ERC20 代币的第三方操作授权\ntransferERC20：向指定地址转出 ERC20 代币\ntransferFromERC20：从指定地址向目标地址转出 ERC20 代币\nincreaseERC20Allowance：增加 ERC20 代币的授权额度\ndecreaseERC20Allowance：减少 ERC20 代币的授权额度\ntransferAsset：资产类型自适应的统一转账方法', 'ILottery 智能合约总结：该合约是一个彩票系统接口合约，定义了与彩票核心机制交互的标准函数规范。合约主要包含获取彩票参数和修改彩票状态两大类功能，通过接口形式规范了不同合约间的交互标准。核心功能围绕彩票开奖机制设计，包含获取最大号码范围、接收随机数开奖结果、增加奖池金额三个关键操作，为彩票业务提供了基础功能框架。\n\n函数列表：\n1. getMaxRange - 外部视图函数，获取彩票号码的最大取值范围\n2. numbersDrawn - 外部状态修改函数，接收随机数并处理彩票开奖结果（需传入彩票ID、请求ID和随机数）\n3. addMerlinPrize - 外部状态修改函数，向奖池增加指定数量的奖金', '总结：该 SushiSwapPairMock 智能合约是一个模拟实现的流动性池合约，继承自 UniswapV2Pair 合约核心逻辑。其核心功能是作为去中心化交易所中的交易对池，处理代币兑换、流动性添加/移除等基础操作。代码未对父合约功能进行任何修改或扩展，仅通过构造函数调用父类初始化，属于基础逻辑复用型合约。其核心机制包括自动做市商算法、流动性代币铸造/销毁、交易手续费积累等原生 Uniswap V2 特性。\n\n函数列表：包含 UniswapV2Pair 全部函数：mint（铸造流动性代币给提供者）、burn（销毁流动性代币并返还代币）、swap（执行代币兑换）、sync（强制更新储备量）、skim（提取多余代币）、initialize（初始化交易对代币）、getReserves（获取当前储备量）、_update（内部储备量更新）、_mintFee（手续费铸造计算）、transfer（ERC20代币转账）、approve（授权额度）、transferFrom（授权转账）、permit（元交易许可）。具体函数实现细节需参考 UniswapV2Pair 源合约。', 'LibMeta 是一个用于处理元交易和链信息操作的工具库，主要提供EIP712域名分离器生成、链ID获取和增强版消息发送者识别功能。该库通过domainSeparator函数构建符合EIP712标准的域分隔符，结合链ID和合约地址生成唯一标识。getChainID使用底层汇编获取当前区块链网络ID，msgSender函数创新性地解决合约自调用场景下的真实调用者识别问题，通过解析msg.data末尾附加的地址信息确保元交易场景中能准确获取原始签名者地址。这些功能为构建支持元交易的智能合约提供了基础设施支持，常见于去中心化应用的身份验证和跨合约调用场景。\n\n函数列表：\nEIP712_DOMAIN_TYPEHASH - 存储EIP712域名类型哈希值的常量变量\ndomainSeparator(string memory name, string memory version) - 生成EIP712域分隔符，包含名称、版本、链ID和合约地址的哈希组合\ngetChainID() - 通过chainid汇编指令获取当前区块链网络ID\nmsgSender() - 增强版消息发送者识别，支持从合约自调用的消息数据中提取原始发送者地址', '总结：该智能合约是一个名为Context的抽象合约，主要用于提供交易执行上下文信息。其核心功能是封装以太坊交易的基础属性，解决GSN元交易场景下发送者与实际支付者地址不一致的问题。合约通过两个关键函数安全地获取交易发送者地址和原始调用数据，避免直接访问msg.sender和msg.data的潜在风险。该合约设计为可继承的库合约，采用virtual修饰符允许子合约重写逻辑，适用于需要处理元交易的中间层合约或库模块。代码包含防止状态可变性警告的编译优化处理，整体结构简洁，属于基础设施类合约。\n\n函数列表：\n1. _msgSender()：内部视图函数，返回当前交易发送者的地址（address payable类型），直接读取msg.sender值。\n2. _msgData()：内部视图函数，返回完整的交易调用数据（bytes类型），通过msg.data获取原始交易参数。', 'IQBridgeHandler 接口合约总结：该智能合约定义了跨链桥接处理程序的核心功能接口，主要用于管理资产跨链转移的关联关系、存款操作及提案执行。合约通过资源ID绑定目标合约地址实现多资产支持，包含ETH与ERC20代币的双重存款机制，提供资金释放安全控制，并设置可销毁资产标识以适应不同代币标准。核心功能分为资源管理、存款处理、提案执行三大模块，支持跨链操作中存款初始化、目标链提案执行及紧急资金提取等关键流程。\n\n函数列表：\n1. setResource(bytes32,address)：绑定资源ID与目标合约地址，建立存款调用关联\n2. setBurnable(address)：标记可销毁资产合约，支持代币销毁/铸造逻辑\n3. deposit(bytes32,address,bytes)：处理ERC20代币存款操作，由桥合约调用发起\n4. depositETH(bytes32,address,bytes)：处理ETH存款的特殊函数，支持原生币转账\n5. executeProposal(bytes32,bytes)：执行跨链提案的核心方法，完成目标链资产操作\n6. withdraw(address,address,uint256)：紧急资金提取功能，手动释放托管代币', 'AnyswapFacet 智能合约总结：该合约是一个基于 LiFi 协议的跨链桥接模块，专门集成 Anyswap 协议实现多链资产转移功能。合约支持两种主要操作模式：1) 直接桥接用户资产到目标链；2) 先执行资产兑换再完成跨链桥接。核心逻辑通过 Anyswap 路由合约实现资产跨链，同时结合 LibSwap 库处理链上兑换操作。合约严格校验转账金额与链 ID，采用底层代币处理机制确保 Anyswap 兼容性，并通过事件日志记录完整的跨链交易信息。主要特征包括原生代币/ERC20 双模式支持、多步兑换组合操作、安全余额验证机制以及防止同链转账校验。\n\n函数列表：\n1. startBridgeTokensViaAnyswap：直接桥接资产函数，处理用户资产转移后调用 Anyswap 跨链，支持 ERC20 代币和原生代币两种模式。\n2. swapAndStartBridgeTokensViaAnyswap：先兑换后桥接组合函数，允许在执行多步资产兑换操作后自动进行跨链转账。\n3. _startBridge：内部桥接执行函数，包含 Anyswap 路由调用逻辑，处理 ERC20 代币授权及原生代币跨链转账。\n4. 继承自 ILiFi 接口的 LiFiTransferStarted 事件：记录跨链交易开始时的核心参数，包括交易 ID、资产信息、接收方地址等。', 'LibSwap 交换库：该智能合约作为资产交换功能库，提供跨链/跨资产兑换功能实现。主要实现资产转移校验、代币授权、去中心化交易所调用及交换结果计算功能，通过事件记录完整兑换信息。合约核心流程包含三个关键环节：1. 校验并转移发送方资产至合约 2. 执行代币授权操作 3. 调用外部DEX合约完成实际兑换。特别处理了原生代币与非原生代币的不同操作逻辑，采用安全余额差值法计算实际到账数量，并通过低级调用异常捕获机制增强交易安全性。\n\n函数列表：\n- swap(bytes32 transactionId, SwapData calldata _swapData)：核心交换函数，处理资产转移校验、执行代币授权、调用外部DEX合约并计算实际获得资产数量。参数包含交易ID和结构化交换数据，自动处理原生代币与非原生代币的不同操作流程，失败时返回详细错误信息。', '智能合约名称：IUraniumPair（铀交易对接口）。该合约是一个定义了去中心化交易所交易对核心功能的接口，同时兼容 ERC20 标准作为流动性代币凭证。合约主要包含四个模块功能：1）ERC20 标准代币功能，用于管理流动性提供者的份额凭证；2）流动性铸造/销毁机制，通过 mint/burn 函数处理流动性增减；3）代币交换功能，支持双向代币兑换并触发 Swap 事件；4）价格预言机相关功能，通过储备量记录和累计价格实现外部价格查询。特色功能包括支持 EIP-2612 离线授权许可（permit）、储备同步机制（sync/skim）以及最小流动性锁定机制（MINIMUM_LIQUIDITY）。\n\n函数列表：\n- ERC20 标准函数：name（代币名称）、symbol（代币符号）、decimals（小数位）、totalSupply（总供应量）、balanceOf（查询余额）、allowance（查询授权额度）、approve（设置授权）、transfer（转账）、transferFrom（授权转账）\n- 许可功能：DOMAIN_SEPARATOR（EIP712 域分隔符）、PERMIT_TYPEHASH（许可类型哈希）、nonces（地址 nonce 值）、permit（离线授权）\n- 流动性管理：mint（铸造流动性代币）、burn（销毁流动性代币）\n- 交易功能：swap（执行代币兑换）\n- 储备管理：sync（同步储备余额）、skim（调整余额差异）\n- 信息查询：factory（查询工厂地址）、token0（查询代币0）、token1（查询代币1）、getReserves（获取储备量）、price0CumulativeLast（代币0累计价格）、price1CumulativeLast（代币1累计价格）、kLast（最后储备乘积）\n- 初始化函数：initialize（初始化交易对）\n- 常量参数：MINIMUM_LIQUIDITY（最小流动性值）', 'CompoundModel 智能合约总结：该合约是基于 Compound 协议和 Uniswap V2 构建的收益增强模型，主要实现资产存入 Compound 生息、自动复投 COMP 奖励的功能。合约通过连接 cToken 实现底层资产存入 Compound 协议获取利息，并定期将 COMP 奖励通过 Uniswap 兑换为底层资产进行复投。核心功能包含资金存入/赎回、COMP 奖励自动兑换、收益计算三个模块。合约采用 OnlyForge 权限控制，仅允许指定地址执行提款操作，确保资金安全。关键操作涉及与 Compound 协议的 cToken 交互（mint/redeem）和 Uniswap 的链上兑换（swapExactTokensForTokens），通过事件机制记录投资、提现和代币兑换行为。\n\n函数列表：\n1. initialize：初始化合约参数，设置 cToken、COMP 代币、Comptroller 和 Uniswap 路由地址\n2. underlyingBalanceInModel：查询合约持有的底层代币余额\n3. underlyingBalanceWithInvestment：计算包含投资利息的总资产价值\n4. invest：将全部底层代币存入 Compound 协议\n5. reInvest：组合操作：领取 COMP 奖励→兑换为底层代币→重新投资\n6. withdrawAllToForge：全额赎回资产并转账至 Forge 地址\n7. withdrawToForge：提取指定数量资产到 Forge 地址\n8. withdrawTo：提取指定数量资产到任意地址（仅限 Forge 调用）\n9. _cTokenBalanceOf（internal）：查询合约持有的 cToken 数量\n10. _claimComp（internal）：从 Compound 协议领取 COMP 奖励\n11. _swapCompToUnderlying（internal）：通过 Uniswap 将 COMP 兑换为底层代币', 'StorageSlot 库合约总结：该智能合约是一个用于安全访问特定存储插槽的底层工具库，主要服务于可升级合约架构（如ERC1967代理模式），通过类型化结构体封装避免存储冲突。合约定义了AddressSlot/BooleanSlot/Bytes32Slot/Uint256Slot四种数据结构，提供对应的getXXXSlot函数来获取指定存储插槽的引用指针。核心机制是通过内联汇编定位存储位置，返回结构体的存储引用使得外部可通过.value属性直接读写该插槽数据，在确保类型安全的同时避免了手动操作存储插槽的复杂性。该库通过标准化存储访问模式，为合约升级架构中的实现地址切换、状态变量存储等关键操作提供基础支持。\n\n函数列表：\n1. getAddressSlot(bytes32 slot) - 获取指定插槽的地址类型存储引用\n2. getBooleanSlot(bytes32 slot) - 获取指定插槽的布尔类型存储引用\n3. getBytes32Slot(bytes32 slot) - 获取指定插槽的bytes32类型存储引用\n4. getUint256Slot(bytes32 slot) - 获取指定插槽的uint256类型存储引用', '该智能合约是一个名为 VaultWithIndirection 的库，主要用于管理通过 Yearn 金库适配器进行资金存取的逻辑。合约通过 Data 结构体记录每个金库适配器实例及其总存款量，List 结构体用于管理多个金库实例集合。核心功能包括存款/取款操作、收益收割及金库列表管理，通过与 YearnVaultAdapterWithIndirection 适配器交互实现资金托管，采用 SafeMath 和 SafeERC20 确保数值计算与代币操作的安全性。存款时资金会转入适配器并更新总存款量，提款时通过直接/间接两种方式处理，harvest 函数可提取超出本金部分的收益。列表管理功能支持添加/查询/遍历多个金库实例。\n\n函数列表如下：\ntotalValue：查看金库总资产价值\ntoken：获取金库接受的代币类型\ndeposit：存入指定数量代币\ndepositAll：存入合约全部代币余额\nwithdraw：向指定地址提取代币并更新总存款量\ndirectWithdraw：直接通过适配器提取代币（不修改总存款量）\nindirectWithdraw：间接通过适配器提取代币（不修改总存款量）\nwithdrawAll：提取全部已存款代币\nharvest：提取超额收益到指定地址\npush：向列表添加新金库实例\nget：通过索引获取列表中的金库实例\nlast：获取列表最后一个金库实例\nlastIndex：获取列表最后一个元素的索引号\nlength：获取列表元素总数', '该智能合约被命名为 sale_configuration（销售配置合约），核心功能是管理代币销售的相关配置参数。合约内主要存储销售策略相关的数值型参数和地址信息，包含供应量限制、不同用户群体的铸造限额、价格参数、销售时间段设置、签名验证地址等基础配置。值得注意的是，合约中超过半数参数被标记为 obsolete（已废弃），显示该合约经历过多次迭代更新，当前实际生效的核心参数聚焦于最大供应量（_maxSupply）、客户端铸造限额（_clientMintLimit）、EC群体铸造限额（_ecMintLimit）、全价价格（_fullPrice）、正式销售时间段（_saleStart/_saleEnd）、单次销售最大铸造量（_maxPerSaleMint）、免费铸造额度（_freePerAddress）、签名验证地址（_signer）及EC资金库地址（_ecVault）。该合约目前仅声明存储变量而未定义任何功能函数，推测其作为基础配置模块，需与其他实现业务逻辑的合约配合使用。\n\n函数列表：该合约未定义任何函数。所有代码内容均为状态变量声明，无函数实现逻辑。已声明的20个状态变量中包含13个标记为obsolete的废弃参数，7个活跃参数，以及2个地址型参数。', '该智能合约为 Uniswap V2 工厂合约的接口定义（Interface），声明了 Factory 合约必须实现的功能方法及事件。其核心作用是创建并管理代币交易对（Pair），同时具备手续费管理权限设置功能。合约不包含具体逻辑实现，仅通过接口规范定义了其他合约调用时应遵循的函数原型。\n\n核心功能包括：1. 创建任意两种 ERC20 代币的交易对合约 2. 查询已创建的交易对信息 3. 设置协议手续费接收地址 4. 更新合约权限控制者地址 5. 设置迁移合约地址。关键机制是通过 createPair 函数生成新的 Pair 合约，并通过事件 PairCreated 广播交易对创建信息。\n\n函数列表：\n- feeTo()：查看手续费接收地址\n- feeToSetter()：查看手续费设置权限地址\n- migrator()：查看迁移管理器地址\n- getPair()：查询两个代币对应的交易对地址\n- allPairs()：通过索引查询已创建的交易对地址\n- allPairsLength()：获取已创建交易对总数\n- createPair()：创建新的代币交易对\n- setFeeTo()：设置手续费接收地址（需权限）\n- setFeeToSetter()：设置权限控制者地址（需权限）\n- setMigrator()：设置迁移合约地址（需权限）', 'SafeERC20 库合约总结：该智能合约是 OpenZeppelin 标准库中的 SafeERC20 安全封装库，主要提供针对 ERC20 代币操作的安全封装方法。通过强化标准 ERC20 接口调用的异常处理机制，有效防范代币转账失败风险。核心功能包含安全转账、授权额度控制及底层调用验证三部分，重点解决以下三类问题：(1) 处理返回 false 的非常规 ERC20 代币的失败回滚 (2) 避免 approve 授权操作的竞争条件问题 (3) 使用 SafeMath 进行安全的数值计算防止溢出。其通过 _callOptionalReturn 私有函数实现底层调用验证，强制要求代币合约调用必须成功，同时兼容符合 ERC20 标准与非常规实现的代币合约。\n\n函数列表：\n1. safeTransfer(IERC20,address,uint256)：安全转账函数，执行 token.transfer 调用并验证结果\n2. safeTransferFrom(IERC20,address,address,uint256)：安全转账函数，执行 token.transferFrom 调用并验证结果\n3. safeApprove(IERC20,address,uint256)：安全授权函数（已弃用），设置授权额度时要求从零值初始化\n4. safeIncreaseAllowance(IERC20,address,uint256)：安全增加授权额度，采用加法操作避免竞争条件\n5. safeDecreaseAllowance(IERC20,address,uint256)：安全减少授权额度，执行减法操作并防止负值\n6. _callOptionalReturn(IERC20,bytes)：内部核心验证函数，执行底层调用并强制验证操作结果', '该智能合约是一个名为 Decimal 的库合约，用于实现 18 位精度的定点数运算。其主要功能是通过结构体 D256 封装数值，并提供一系列数学运算方法，支持加减乘除、幂运算、比较操作及类型转换。合约依赖 OpenZeppelin 的 SafeMath 库确保运算安全，避免溢出问题。核心逻辑围绕定点数的精度处理展开，例如将普通整数转换为定点数时自动乘以 10^18，除法运算通过预先放大数值保证精度。该库适用于需要高精度小数计算的场景，如金融利率计算或复杂数学建模。\n\n函数列表如下：\n- zero()：返回值为0的D256实例\n- one()：返回值为1的D256实例（实际存储为10^18）\n- from(uint256)：将普通整数转换为定点数\n- ratio(uint256,uint256)：计算两个数的比例值并转换为定点数\n- add()：实现定点数与普通整数/定点数的加法重载函数\n- sub()：实现定点数与普通整数/定点数的减法重载函数（包含带错误提示版本）\n- mul()：实现定点数与普通整数/定点数的乘法重载函数\n- div()：实现定点数与普通整数/定点数的除法重载函数\n- pow()：计算定点数的整数次幂\n- equals()：判断两个定点数是否相等\n- greaterThan()/lessThan()：实现大小比较功能\n- greaterThanOrEqualTo()/lessThanOrEqualTo()：实现复合条件比较\n- isZero()：判断数值是否为0\n- asUint256()：将定点数转换回普通整数（舍弃小数部分）\n- getPartial()：内部核心方法处理分数乘法运算\n- compareTo()：内部方法实现三态比较逻辑', 'COVER代币合约总结：该合约是Cover Protocol项目的ERC20代币实现，具有挖矿和迁移功能控制机制。核心功能包括代币初始分配、权限管理和分阶段释放机制。合约部署时向指定地址铸造1枚代币用于创建资金池，通过release函数实现代币正式释放（需达到设定时间戳），向金库地址铸造950枚、归属地址铸造10800枚代币。代币铸造权仅限通过认证的迁移合约和矿工合约调用，且设置黑smith合约和迁移合约地址的权限采用链式验证模式（仅当前合约可修改自身地址）。合约包含严格的时间锁和一次性释放保护，防止重复初始化。\n\n函数列表：\n1. 构造函数：初始化代币名称符号，铸造1枚代币到固定地址\n2. mint：在代币释放后，允许迁移合约或矿工合约铸造代币给指定账户\n3. setBlacksmith：由当前黑smith合约调用，更新黑smith合约地址\n4. setMigrator：由当前迁移合约调用，更新迁移合约地址\n5. release：由合约所有者单次调用，激活代币系统并执行初始分配，设置黑smith和迁移合约地址（需达到设定时间且未释放过）', 'UraniumFactory接口合约总结：该智能合约是一个工厂合约接口，定义了去中心化交易所中代币交易对创建及费用管理的核心功能。合约主要用于创建和管理流动性交易对，包含费用地址设置、交易对查询、动态费用参数控制等机制。通过createPair函数可创建新的代币交易对，同时维护所有已创建交易对的列表。合约包含管理员权限体系，通过feeToSetter和owner进行协议参数控制，支持动态调整手续费接收地址和权限转移功能。该接口遵循类似Uniswap V2的工厂合约模式，但增加了feeAmount费用比例参数，表明可能采用动态手续费机制。\n\n函数列表：\n1. feeTo()：查询手续费接收地址\n2. feeToSetter()：查询手续费设置权限地址\n3. feeAmount()：查询当前交易手续费比例\n4. owner()：查询合约所有者地址\n5. getPair()：根据代币地址查询已存在的交易对\n6. allPairs()：通过索引获取已创建交易对地址\n7. allPairsLength()：获取已创建交易对总数\n8. createPair()：创建新的代币交易对\n9. setFeeTo()：设置新的手续费接收地址\n10. setFeeToSetter()：转移手续费设置权限', '该智能合约是一个名为 Address 的 Solidity 库，提供与地址类型相关的实用功能，主要用于安全地进行以太坊地址操作和合约调用。核心功能包括检测地址类型、替代原生转账功能，以及封装底层调用操作。关键点包括：(1) 通过检查 extcodesize 判断地址是否为合约，但需注意构造中和销毁合约的特殊情况；(2) 用 sendValue 代替原生 transfer 以突破 2300 gas 限制；(3) 提供 functionCall、functionCallWithValue、functionStaticCall、functionDelegateCall 四种安全调用方法，均包含错误处理和合约存在验证；(4) 内部通过 _verifyCallResult 统一处理调用结果，自动解析 revert 信息。该库通过封装底层调用逻辑，增强了对重入攻击等安全隐患的防护能力，同时优化了错误处理机制。函数列表如下：isContract：检查地址是否为合约账户。sendValue：向指定地址发送以太币。functionCall：执行底层调用并处理错误。functionCall：带自定义错误信息的底层调用。functionCallWithValue：附带以太币转账的合约调用。functionCallWithValue：带错误信息的转账调用。functionStaticCall：执行静态调用。functionStaticCall：带错误信息的静态调用。functionDelegateCall：执行委托调用。functionDelegateCall：带错误信息的委托调用。_verifyCallResult：内部函数，验证调用结果并处理错误。', 'MonoX 流动性池管理合约接口总结：该合约为基于 ERC1155 标准的多代币流动性池管理接口，主要功能涵盖流动性代币铸造销毁、WETH 存取、资产转移及流动性提供者管理。合约通过 ERC1155 基础功能实现多池流动性代币管理，支持 ETH 与 ERC20 代币的安全转账机制，内置 WETH 封装代币操作接口。核心特性包含流动性供应时间记录、顶级流动性持有者查询功能，并设置了白名单权限控制系统，允许通过 _isOfficial 参数区分官方流动性池，实现差异化管理策略。\n\n函数列表如下：\nmint：铸造流动性代币至指定账户\nburn：销毁账户持有的流动性代币\ntotalSupplyOf：查询指定流动性池代币总供应量\ndepositWETH：存入 WETH 代币\nwithdrawWETH：提取 WETH 代币\nsafeTransferETH：安全转账 ETH 至目标地址\nsafeTransferERC20Token：安全转账 ERC20 代币\nWETH：查询 WETH 合约地址\nliquidityLastAddedOf：查询账户最近流动性添加时间\ntopLPHolderOf：查询指定池顶级流动性持有者\nmintLp：铸造流动性代币（带官方标识参数）\nsetWhitelist：设置白名单权限状态', 'QBridgeToken 智能合约总结：该合约是基于 BEP20 标准构建的可升级代币合约，主要用于实现跨链桥接场景中的代币铸造和销毁功能。合约核心功能包含权限管理机制，通过维护铸币者白名单实现代币操作权限控制。合约所有者可通过 setMinter 函数动态管理具有铸币权限的地址，授权后的铸币者地址可执行代币铸造 mint 和带授权销毁 burnFrom 操作。合约继承自 BEP20Upgradeable 实现代币基础功能，并采用初始化函数 initialize 支持可升级合约模式，允许在部署后设置代币名称、符号和小数位。销毁功能采用从指定账户扣除授权额度的安全机制，通过校验用户对铸币者的授权额度防止超额燃烧代币。\n\n函数列表：\n1. initialize - 初始化函数，设置代币名称、符号和小数位\n2. setMinter - 设置/取消地址的铸币者权限（仅合约所有者可调用）\n3. mint - 向指定地址铸造代币（仅铸币者可调用）\n4. burnFrom - 从指定账户销毁代币并更新授权额度（仅铸币者可调用）\n5. isMinter - 查询指定地址是否具有铸币者权限', 'CarefulMath 安全数学运算合约总结：该智能合约是基于 OpenZeppelin 的 SafeMath 库改进的安全数学运算模块，主要用于防止算术运算中的常见错误。合约通过枚举类型定义四种数学错误类型（除零错误、整数溢出/下溢），提供安全的加减乘除运算方法。所有函数均采用错误码返回机制替代直接交易回滚，在执行算术运算时会主动检测边界条件，当检测到溢出、下溢或除零操作时返回对应错误码而非中断交易，这种设计为上层调用合约提供了灵活的错误处理空间。合约包含基础四则运算及组合运算，所有函数均为 pure 类型且仅内部可见，确保模块安全性和低 gas 消耗特性。\n\n函数列表：\n1. mulUInt - 安全乘法运算，检测整数溢出\n2. divUInt - 安全除法运算，检测除零错误\n3. subUInt - 安全减法运算，检测整数下溢\n4. addUInt - 安全加法运算，检测整数溢出\n5. addThenSubUInt - 组合运算，先执行加法再执行减法并检测错误链式传递', 'CarefulMath 智能合约总结：该合约是基于 OpenZeppelin 的 SafeMath 库改进的安全数学运算库，主要用于处理基础算术运算的溢出/下溢保护。合约通过枚举类型 MathError 定义了四种错误状态（除零错误、整数溢出、整数下溢），在执行算术运算时会返回包含错误码和计算结果的元组，为上层调用提供更灵活的错误处理机制。合约实现了基础四则运算及组合运算的安全校验：乘法通过反向除法验证溢出，减法检查被减数关系，加法通过结果反推验证，并通过 addThenSubUInt 实现加法减法链式调用。该合约所有函数均为 internal 权限且不修改状态，适用于作为其他合约的基础运算模块。\n\n函数列表：\n1. mulUInt(uint,uint) 执行安全乘法运算，返回错误码和乘积结果\n2. divUInt(uint,uint) 执行安全除法运算，返回错误码和整除结果\n3. subUInt(uint,uint) 执行安全减法运算，返回错误码和差值结果\n4. addUInt(uint,uint) 执行安全加法运算，返回错误码和求和结果\n5. addThenSubUInt(uint,uint,uint) 先执行加法再执行减法的链式运算，返回最终错误码和运算结果', 'Arrays 智能合约总结：该合约是一个专注于数组操作的 Solidity 库，核心功能是通过二分查找算法实现高效数组查询。库中提供 findUpperBound 函数用于在有序数组中快速定位目标元素的边界位置，适用于需要高效查询排序数据的场景。主要特性包括：(1) 要求输入数组必须为升序排列且无重复元素，通过前置条件保障算法正确性；(2) 采用二分查找算法实现 O(log n) 时间复杂度，通过计算中间索引动态调整搜索范围；(3) 返回值为首个大于等于目标元素的索引值，当所有元素小于目标值时返回数组长度；(4) 特别处理元素相等情况，当存在精确匹配时返回该元素的最后出现位置。关键实现细节体现在索引边界处理，使用 Math 库的 average 方法计算中间索引，通过 low/high 双指针动态收缩搜索范围，最终通过后处理步骤确定精确边界位置。\n\n函数列表：findUpperBound - 在有序数组中执行二分查找，返回第一个大于等于目标元素的索引值，若全部元素小于目标值则返回数组长度。', '智能合约名称：QBridgeHandler。该合约是跨链桥接协议的核心处理模块，主要实现资产跨链转移的存款、提款和提案执行功能。合约通过资源ID映射管理多链代币资产，支持ETH和ERC20代币的跨链操作，并引入燃烧铸造机制处理资产流通。核心功能包括：1）通过资源ID与代币地址的双向映射建立资产标识体系；2）区分可燃烧代币与普通代币的不同处理流程；3）设置提款手续费和最低存款金额风控机制；4）支持通过委托合约进行复杂资产操作扩展。合约采用权限分级控制，桥接合约负责业务操作，所有者可配置手续费等参数。\n\n函数列表：\nreceive()：接收ETH转账\ninitialize()：初始化桥接合约地址\nsetResource()：设置资源ID与代币合约地址的映射关系\nsetBurnable()：标记代币为可燃烧状态\nsetDelegator()：配置特定业务选项的委托合约\nsetWithdrawalFee()：设置指定资源的提款手续费\nsetMinDepositAmount()：设置资源ID对应业务的最低存款金额\ndeposit()：处理普通代币存款（燃烧或托管）\ndepositETH()：处理ETH存款\nexecuteProposal()：执行跨链提案进行资产铸造/转账\nwithdraw()：从合约提取资产到指定地址\nonlyBridge修饰器：限制仅桥接合约可调用', '该智能合约命名为SwapUtils库，是一个支持多代币池的自动化做市商（AMM）核心逻辑库，基于StableSwap算法实现。其主要功能包括代币兑换、流动性管理、动态手续费调整及放大系数（A）控制。合约通过维护各代币的余额和精度乘数实现跨代币兑换，采用LP Token机制记录流动性提供者的份额。核心数学计算涉及恒定乘积公式的变种，支持通过调整放大系数优化滑点。管理员可设置最高1%的兑换手续费（swapFee）及最高100%的手续费分成比例（adminFee）。流动性操作包括添加/移除流动性、单币种移除及不平衡移除，均考虑手续费影响并触发相应事件。\n\n函数列表如下：\n_getAPrecise：内部视图，获取当前精确放大系数A\ncalculateWithdrawOneToken：外部视图，计算提取单种代币时可获得的数量\ngetVirtualPrice：外部视图，获取LP Token的虚拟价格\ncalculateSwap：外部视图，计算兑换后可获得的代币数量\ncalculateRemoveLiquidity：外部视图，计算移除流动性时各代币的返还数量\ncalculateTokenAmount：外部视图，计算添加/移除流动性对应的LP Token数量变化\ngetAdminBalance：外部视图，查询管理员手续费余额\nswap：状态变更，执行代币兑换操作\naddLiquidity：状态变更，添加流动性并铸造LP Token\nremoveLiquidity：状态变更，按比例移除流动性并销毁LP Token\nremoveLiquidityOneToken：状态变更，单币种移除流动性\nremoveLiquidityImbalance：状态变更，按指定比例不平衡移除流动性\nwithdrawAdminFees：状态变更，提取累积的管理员手续费\nsetAdminFee：状态变更，设置管理员手续费比例\nsetSwapFee：状态变更，设置交易手续费比例\n内部辅助函数包含：_calculateWithdrawOneToken、calculateWithdrawOneTokenDY、getYD、getD、_xp、_feePerToken、_calculateSwap、_calculateRemoveLiquidity等，主要用于处理数学计算和状态维护。', '该智能合约是一个名为 SushiBar 的质押池合约，允许用户存入 SUSHI 代币并获取对应的质押凭证 xSUSHI。用户持有的 xSUSHI 数量与其质押的 SUSHI 数量按比例动态计算，当用户赎回时，根据合约内 SUSHI 的总量和 xSUSHI 的总供应量确定实际获得的 SUSHI 数量。合约通过 ERC20 标准实现 xSUSHI 代币的铸造与销毁机制，存入 SUSHI 时铸造 xSUSHI，赎回时销毁 xSUSHI 并返还对应比例的 SUSHI。核心逻辑通过动态比例计算实现质押资产的价值转换，用户收益来源于质押期间合约内 SUSHI 总量的增长（可能来自其他用户的质押或外部收益）。\n\n函数列表：\n1. constructor(IERC20 _sushi)：初始化合约，绑定 SUSHI 代币合约地址。\n2. enter(uint256 _amount)：用户存入 SUSHI 代币，根据当前质押率铸造对应数量的 xSUSHI 凭证。\n3. leave(uint256 _share)：用户销毁指定数量的 xSUSHI 凭证，按当前质押比例提取对应的 SUSHI 代币。\n4. sushi()：公开状态变量自动生成的 getter 函数，返回合约绑定的 SUSHI 代币地址。', 'MonoXLibrary 智能合约总结：该智能合约是一个名为 MonoXLibrary 的工具库，主要用于处理虚拟现金（vcash）余额计算及以太币安全转账功能。合约包含三个核心功能模块：(1) safeTransferETH 函数实现安全的 ETH 转账，采用底层调用方式并验证转账结果，确保资金转移可靠性；(2) vcashBalanceAdd 函数处理 vcash 信用与债务的平衡增加逻辑，根据现有债务情况智能分配增量到信用或债务；(3) vcashBalanceSub 函数执行 vcash 余额的扣减操作，优先扣除信用余额并在不足时转换为债务。该库通过 SafeMath 实现安全的数学运算，重点服务于需要管理双账户（信用账户与债务账户）余额变化的 DeFi 场景，典型应用于需要同时处理用户信用和债务平衡的金融协议。\n\n函数列表：\n1. safeTransferETH(address to, uint256 value) - 向指定地址安全转账 ETH，验证转账结果有效性\n2. vcashBalanceAdd(uint256 _credit, uint256 _debt, uint256 delta) - 增加 vcash 余额，根据当前债务情况智能分配信用/债务额度\n3. vcashBalanceSub(uint256 _credit, uint256 _debt, uint256 delta) - 减少 vcash 余额，优先扣除信用额度并在不足时增加债务', 'SafeERC20 库总结：该智能合约是一个用于安全执行 ERC20 标准代币操作的库合约，主要解决传统 ERC20 转账/授权可能因失败未回退导致的资金风险问题。其核心逻辑通过封装底层调用并强制验证返回值，确保代币操作在失败时自动回滚交易。关键实现包含三个安全层：1. 使用 functionCall 执行底层调用并验证合约存在性 2. 强制检查调用返回值长度，对非空返回数据解码验证布尔值 3. 特别处理 approve 授权操作，通过增量调整模式避免 ERC20 授权的前后不匹配问题。该库提供的主要安全操作包含代币转账、带来源的转账、授权额度调整等功能，其中针对授权操作专门设计了安全增加/减少额度函数以避免直接设置绝对值导致的风险。\n\n函数列表：\n1. safeTransfer(IERC20,address,uint256) - 安全转账操作，向指定地址转移代币\n2. safeTransferFrom(IERC20,address,address,uint256) - 安全跨地址转账，从来源地址向目标地址转移代币\n3. safeApprove(IERC20,address,uint256) - (已弃用) 设置代币授权额度，强制要求从零地址初始化或重置为零额度\n4. safeIncreaseAllowance(IERC20,address,uint256) - 安全增加授权额度，采用相对值调整模式\n5. safeDecreaseAllowance(IERC20,address,uint256) - 安全减少授权额度，带有额度不足检查防止超额减少\n6. _callOptionalReturn(IERC20,bytes) - 内部函数，执行代币合约底层调用并验证返回数据有效性']], 'uris': None, 'data': None, 'included': ['distances', 'documents']}
------------------------------------------------
重排序结果：
['SushiSwap.sol-SushiMaker.sol', 'SushiSwap.sol-SushiBar.sol', 'SushiSwap.sol-IUniswapV2Router02.sol', 'SushiSwap.sol-IUniswapV2Factory.sol', 'Indexed Finance.sol-IUniswapV2Pair.sol', 'SushiSwap.sol-SushiSwapPairMock.sol', 'SushiSwap.sol-UniswapV2ERC20.sol', 'MonoX.sol-Monoswap.sol', 'MonoX.sol-IMonoXPool.sol', 'MonoX.sol-MonoXLibrary.sol', 'Saddle Finance.sol-ISwap.sol', 'Saddle Finance.sol-SwapUtils.sol', 'Saddle Finance.sol-MetaSwapUtils.sol', 'Li.Fi.sol-LibSwap.sol', 'Li.Fi.sol-AnyswapFacet.sol', 'Li.Fi.sol-LibAsset.sol', 'Uranium Finance-4.sol-IUraniumPair.sol', 'Uranium Finance-4.sol-IUraniumFactory.sol', 'Qubit Finance.sol-QBridgeHandler.sol', 'Qubit Finance.sol-QBridgeToken.sol']
------------------------------------------------
函数切片：

------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-bridgeFor-0
元数据:{'block索引': 0, '函数名': 'bridgeFor', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function bridgeFor(address token) public view returns (address bridge) {
bridge = _bridges[token];
if (bridge == address(0)) {
bridge = weth;
}
}
// F1 - F10: OK
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-setBridge-1
元数据:{'block索引': 1, '函数名': 'setBridge', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token, address bridge', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LogBridgeSet']", '返回值': ''}
函数切片:
function setBridge(address token, address bridge) external onlyOwner {
// Checks
require(token != sushi && token != weth && token != bridge, "SushiMaker: Invalid bridge");
// Effects
_bridges[token] = bridge;
emit LogBridgeSet(token, bridge);
}
// M1 - M5: OK
// C1 - C24: OK
// C6: It's not a fool proof solution, but it prevents flash loans, so here it's ok to use tx.origin
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-onlyEOA-2
元数据:{'block索引': 2, '函数名': 'onlyEOA', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyEOA() {
// Try to make flash-loan exploit harder to do.
require(msg.sender == tx.origin, "SushiMaker: must use EOA");
_;
}
// F1 - F10: OK
// F3: _convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple
// F6: There is an exploit to add lots of SUSHI to the bar, run convert, then remove the SUSHI again.
//     As the size of the SushiBar has grown, this requires large amounts of funds and isn't super profitable anymore
//     The onlyEOA modifier prevents this being done with a flash loan.
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-convert-3
元数据:{'block索引': 3, '函数名': 'convert', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function convert(address token0, address token1) external onlyEOA() {
_convert(token0, token1);
}
// F1 - F10: OK, see convert
// C1 - C24: OK
// C3: Loop is under control of the caller
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-convertMultiple-4
元数据:{'block索引': 4, '函数名': 'convertMultiple', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address[] calldata token0, address[] calldata token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function convertMultiple(address[] calldata token0, address[] calldata token1) external onlyEOA() {
// TODO: This can be optimized a fair bit, but this is safer and simpler for now
uint256 len = token0.length;
for(uint256 i=0; i < len; i++) {
_convert(token0[i], token1[i]);
}
}
// F1 - F10: OK
// C1- C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_convert-5
元数据:{'block索引': 5, '函数名': '_convert', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LogConvert']", '返回值': ''}
函数切片:
function _convert(address token0, address token1) internal {
// Interactions
// S1 - S4: OK
IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));
require(address(pair) != address(0), "SushiMaker: Invalid pair");
// balanceOf: S1 - S4: OK
// transfer: X1 - X5: OK
IERC20(address(pair)).safeTransfer(address(pair), pair.balanceOf(address(this)));
// X1 - X5: OK
(uint256 amount0, uint256 amount1) = pair.burn(address(this));
if (token0 != pair.token0()) {
(amount0, amount1) = (amount1, amount0);
}
emit LogConvert(msg.sender, token0, token1, amount0, amount1, _convertStep(token0, token1, amount0, amount1));
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, _swap, _toSUSHI, _convertStep: X1 - X5: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_convertStep-6
元数据:{'block索引': 6, '函数名': '_convertStep', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1, uint256 amount0, uint256 amount1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _convertStep(address token0, address token1, uint256 amount0, uint256 amount1) internal returns(uint256 sushiOut) {
// Interactions
if (token0 == token1) {
uint256 amount = amount0.add(amount1);
if (token0 == sushi) {
IERC20(sushi).safeTransfer(bar, amount);
sushiOut = amount;
} else if (token0 == weth) {
sushiOut = _toSUSHI(weth, amount);
} else {
address bridge = bridgeFor(token0);
amount = _swap(token0, bridge, amount, address(this));
sushiOut = _convertStep(bridge, bridge, amount, 0);
}
} else if (token0 == sushi) { // eg. SUSHI - ETH
IERC20(sushi).safeTransfer(bar, amount0);
sushiOut = _toSUSHI(token1, amount1).add(amount0);
} else if (token1 == sushi) { // eg. USDT - SUSHI
IERC20(sushi).safeTransfer(bar, amount1);
sushiOut = _toSUSHI(token0, amount0).add(amount1);
} else if (token0 == weth) { // eg. ETH - USDC
sushiOut = _toSUSHI(weth, _swap(token1, weth, amount1, address(this)).add(amount0));
} else if (token1 == weth) { // eg. USDT - ETH
sushiOut = _toSUSHI(weth, _swap(token0, weth, amount0, address(this)).add(amount1));
} else { // eg. MIC - USDT
address bridge0 = bridgeFor(token0);
address bridge1 = bridgeFor(token1);
if (bridge0 == token1) { // eg. MIC - USDT - and bridgeFor(MIC) = USDT
sushiOut = _convertStep(bridge0, token1,
_swap(token0, bridge0, amount0, address(this)),
amount1
);
} else if (bridge1 == token0) { // eg. WBTC - DSD - and bridgeFor(DSD) = WBTC
sushiOut = _convertStep(token0, bridge1,
amount0,
_swap(token1, bridge1, amount1, address(this))
);
} else {
sushiOut = _convertStep(bridge0, bridge1, // eg. USDT - DSD - and bridgeFor(DSD) = WBTC
_swap(token0, bridge0, amount0, address(this)),
_swap(token1, bridge1, amount1, address(this))
);
}
}
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, swap: X1 - X5: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_swap-7
元数据:{'block索引': 7, '函数名': '_swap', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address fromToken, address toToken, uint256 amountIn, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _swap(address fromToken, address toToken, uint256 amountIn, address to) internal returns (uint256 amountOut) {
// Checks
// X1 - X5: OK
IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(fromToken, toToken));
require(address(pair) != address(0), "SushiMaker: Cannot convert");
// Interactions
// X1 - X5: OK
(uint256 reserve0, uint256 reserve1,) = pair.getReserves();
uint256 amountInWithFee = amountIn.mul(997);
if (fromToken == pair.token0()) {
amountOut = amountIn.mul(997).mul(reserve1) / reserve0.mul(1000).add(amountInWithFee);
IERC20(fromToken).safeTransfer(address(pair), amountIn);
pair.swap(0, amountOut, to, new bytes(0));
// TODO: Add maximum slippage?
} else {
amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);
IERC20(fromToken).safeTransfer(address(pair), amountIn);
pair.swap(amountOut, 0, to, new bytes(0));
// TODO: Add maximum slippage?
}
}
// F1 - F10: OK
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_toSUSHI-8
元数据:{'block索引': 8, '函数名': '_toSUSHI', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token, uint256 amountIn', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _toSUSHI(address token, uint256 amountIn) internal returns(uint256 amountOut) {
// X1 - X5: OK
amountOut = _swap(token, sushi, amountIn, bar);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiBar.sol-enter-0
元数据:{'block索引': 0, '函数名': 'enter', '函数所属的合约或接口': 'SushiSwap.sol-SushiBar.sol', '参数': 'uint256 _amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function enter(uint256 _amount) public {
// Gets the amount of Sushi locked in the contract
uint256 totalSushi = sushi.balanceOf(address(this));
// Gets the amount of xSushi in existence
uint256 totalShares = totalSupply();
// If no xSushi exists, mint it 1:1 to the amount put in
if (totalShares == 0 || totalSushi == 0) {
_mint(msg.sender, _amount);
}
// Calculate and mint the amount of xSushi the Sushi is worth. The ratio will change overtime, as xSushi is burned/minted and Sushi deposited + gained from fees / withdrawn.
else {
uint256 what = _amount.mul(totalShares).div(totalSushi);
_mint(msg.sender, what);
}
// Lock the Sushi in the contract
sushi.transferFrom(msg.sender, address(this), _amount);
}
// Leave the bar. Claim back your SUSHIs.
// Unclocks the staked + gained Sushi and burns xSushi
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiBar.sol-leave-1
元数据:{'block索引': 1, '函数名': 'leave', '函数所属的合约或接口': 'SushiSwap.sol-SushiBar.sol', '参数': 'uint256 _share', '可见性': 'public', '外部调用': True, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function leave(uint256 _share) public {
// Gets the amount of xSushi in existence
uint256 totalShares = totalSupply();
// Calculates the amount of Sushi the xSushi is worth
uint256 what = _share.mul(sushi.balanceOf(address(this))).div(totalShares);
_burn(msg.sender, _share);
sushi.transfer(msg.sender, what);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-0
元数据:{'block索引': 0, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHSupportingFeeOnTransferTokens(
address token,
uint liquidity,
uint amountTokenMin,
uint amountETHMin,
address to,
uint deadline
) external returns (uint amountETH);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
address token,
uint liquidity,
uint amountTokenMin,
uint amountETHMin,
address to,
uint deadline,
bool approveMax, uint8 v, bytes32 r, bytes32 s
) external returns (uint amountETH);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForTokensSupportingFeeOnTransferTokens(
uint amountIn,
uint amountOutMin,
address[] calldata path,
address to,
uint deadline
) external;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForTokensSupportingFeeOnTransferTokens(
uint amountOutMin,
address[] calldata path,
address to,
uint deadline
) external payable;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Router02.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Router02.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokensForETHSupportingFeeOnTransferTokens(
uint amountIn,
uint amountOutMin,
address[] calldata path,
address to,
uint deadline
) external;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-feeTo-0
元数据:{'block索引': 0, '函数名': 'feeTo', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeTo() external view returns (address);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-feeToSetter-1
元数据:{'block索引': 1, '函数名': 'feeToSetter', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeToSetter() external view returns (address);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-migrator-2
元数据:{'block索引': 2, '函数名': 'migrator', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function migrator() external view returns (address);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-getPair-3
元数据:{'block索引': 3, '函数名': 'getPair', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPair(address tokenA, address tokenB) external view returns (address pair);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-allPairs-4
元数据:{'block索引': 4, '函数名': 'allPairs', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'uint', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairs(uint) external view returns (address pair);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-allPairsLength-5
元数据:{'block索引': 5, '函数名': 'allPairsLength', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairsLength() external view returns (uint);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-createPair-6
元数据:{'block索引': 6, '函数名': 'createPair', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function createPair(address tokenA, address tokenB) external returns (address pair);
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-setFeeTo-7
元数据:{'block索引': 7, '函数名': 'setFeeTo', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo(address) external;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-setFeeToSetter-8
元数据:{'block索引': 8, '函数名': 'setFeeToSetter', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeToSetter(address) external;
------------------------------------------------
函数切片ID: SushiSwap.sol-IUniswapV2Factory.sol-setMigrator-9
元数据:{'block索引': 9, '函数名': 'setMigrator', '函数所属的合约或接口': 'SushiSwap.sol-IUniswapV2Factory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setMigrator(address) external;
}
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-name-0
元数据:{'block索引': 0, '函数名': 'name', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function name() external pure returns (string memory);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-symbol-1
元数据:{'block索引': 1, '函数名': 'symbol', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function symbol() external pure returns (string memory);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-decimals-2
元数据:{'block索引': 2, '函数名': 'decimals', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decimals() external pure returns (uint8);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-totalSupply-3
元数据:{'block索引': 3, '函数名': 'totalSupply', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-balanceOf-4
元数据:{'block索引': 4, '函数名': 'balanceOf', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-allowance-5
元数据:{'block索引': 5, '函数名': 'allowance', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner, address spender', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allowance(address owner, address spender) external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-approve-6
元数据:{'block索引': 6, '函数名': 'approve', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-transfer-7
元数据:{'block索引': 7, '函数名': 'transfer', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-transferFrom-8
元数据:{'block索引': 8, '函数名': 'transferFrom', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-DOMAIN_SEPARATOR-9
元数据:{'block索引': 9, '函数名': 'DOMAIN_SEPARATOR', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function DOMAIN_SEPARATOR() external view returns (bytes32);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-PERMIT_TYPEHASH-10
元数据:{'block索引': 10, '函数名': 'PERMIT_TYPEHASH', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function PERMIT_TYPEHASH() external pure returns (bytes32);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-nonces-11
元数据:{'block索引': 11, '函数名': 'nonces', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function nonces(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-permit-12
元数据:{'block索引': 12, '函数名': 'permit', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
event Swap(
address indexed sender,
uint amount0In,
uint amount1In,
uint amount0Out,
uint amount1Out,
address indexed to
);
event Sync(uint112 reserve0, uint112 reserve1);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-MINIMUM_LIQUIDITY-13
元数据:{'block索引': 13, '函数名': 'MINIMUM_LIQUIDITY', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function MINIMUM_LIQUIDITY() external pure returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-factory-14
元数据:{'block索引': 14, '函数名': 'factory', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function factory() external view returns (address);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-token0-15
元数据:{'block索引': 15, '函数名': 'token0', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token0() external view returns (address);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-token1-16
元数据:{'block索引': 16, '函数名': 'token1', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token1() external view returns (address);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-getReserves-17
元数据:{'block索引': 17, '函数名': 'getReserves', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-price0CumulativeLast-18
元数据:{'block索引': 18, '函数名': 'price0CumulativeLast', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price0CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-price1CumulativeLast-19
元数据:{'block索引': 19, '函数名': 'price1CumulativeLast', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price1CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-kLast-20
元数据:{'block索引': 20, '函数名': 'kLast', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function kLast() external view returns (uint);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-mint-21
元数据:{'block索引': 21, '函数名': 'mint', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address to) external returns (uint liquidity);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-burn-22
元数据:{'block索引': 22, '函数名': 'burn', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn(address to) external returns (uint amount0, uint amount1);
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-swap-23
元数据:{'block索引': 23, '函数名': 'swap', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'uint amount0Out, uint amount1Out, address to, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-skim-24
元数据:{'block索引': 24, '函数名': 'skim', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function skim(address to) external;
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-sync-25
元数据:{'block索引': 25, '函数名': 'sync', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sync() external;
------------------------------------------------
函数切片ID: Indexed Finance.sol-IUniswapV2Pair.sol-initialize-26
元数据:{'block索引': 26, '函数名': 'initialize', '函数所属的合约或接口': 'Indexed Finance.sol-IUniswapV2Pair.sol', '参数': 'address, address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(address, address) external;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_mint-0
元数据:{'block索引': 0, '函数名': '_mint', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _mint(address to, uint value) internal {
totalSupply = totalSupply.add(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(address(0), to, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_burn-1
元数据:{'block索引': 1, '函数名': '_burn', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _burn(address from, uint value) internal {
balanceOf[from] = balanceOf[from].sub(value);
totalSupply = totalSupply.sub(value);
emit Transfer(from, address(0), value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_approve-2
元数据:{'block索引': 2, '函数名': '_approve', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address owner, address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Approval']", '返回值': ''}
函数切片:
function _approve(address owner, address spender, uint value) private {
allowance[owner][spender] = value;
emit Approval(owner, spender, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_transfer-3
元数据:{'block索引': 3, '函数名': '_transfer', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _transfer(address from, address to, uint value) private {
balanceOf[from] = balanceOf[from].sub(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(from, to, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-approve-4
元数据:{'block索引': 4, '函数名': 'approve', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool) {
_approve(msg.sender, spender, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-transfer-5
元数据:{'block索引': 5, '函数名': 'transfer', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool) {
_transfer(msg.sender, to, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-transferFrom-6
元数据:{'block索引': 6, '函数名': 'transferFrom', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool) {
if (allowance[from][msg.sender] != uint(-1)) {
allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
}
_transfer(from, to, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-permit-7
元数据:{'block索引': 7, '函数名': 'permit', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
bytes32 digest = keccak256(
abi.encodePacked(
'\x19\x01',
DOMAIN_SEPARATOR,
keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
)
);
address recoveredAddress = ecrecover(digest, v, r, s);
require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
_approve(owner, spender, value);
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-mint-0
元数据:{'block索引': 0, '函数名': 'mint', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint (address account, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-burn-1
元数据:{'block索引': 1, '函数名': 'burn', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn (address account, uint256 amount) external;
}
/**
* The Monoswap is ERC1155 contract does this and that...
*/
contract Monoswap is Initializable, OwnableUpgradeable {
using SafeMath for uint256;
using SafeMath for uint112;
using SafeERC20 for IERC20;
using SafeERC20 for IvCash;
IvCash vCash;
address WETH;
address feeTo;
uint16 fees; // over 1e5, 300 means 0.3%
uint16 devFee; // over 1e5, 50 means 0.05%
uint256 constant MINIMUM_LIQUIDITY=100;
struct PoolInfo {
uint256 pid;
uint256 lastPoolValue;
address token;
PoolStatus status;
uint112 vcashDebt;
uint112 vcashCredit;
uint112 tokenBalance;
uint256 price; // over 1e18
uint256 createdAt; // timestamp
}
enum TxType {
SELL,
BUY
}
enum PoolStatus {
UNLISTED,
LISTED,
OFFICIAL,
SYNTHETIC,
PAUSED
}
mapping (address => PoolInfo) public pools;
// tokenStatus is for token lock/transfer. exempt means no need to verify post tx
mapping (address => uint8) private tokenStatus; //0=unlocked, 1=locked, 2=exempt
// token poool status is to track if the pool has already been created for the token
mapping (address => uint8) public tokenPoolStatus; //0=undefined, 1=exists
// negative vCash balance allowed for each token
mapping (address => uint) public tokenInsurance;
uint256 public poolSize;
uint private unlocked;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-lock-2
元数据:{'block索引': 2, '函数名': 'lock', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier lock() {
require(unlocked == 1, 'MonoX:LOCKED');
unlocked = 0;
_;
unlocked = 1;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-lockToken-3
元数据:{'block索引': 3, '函数名': 'lockToken', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier lockToken(address _token) {
uint8 originalState = tokenStatus[_token];
require(originalState!=1, 'MonoX:POOL_LOCKED');
if(originalState==0) {
tokenStatus[_token] = 1;
}
_;
if(originalState==0) {
tokenStatus[_token] = 0;
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-ensure-4
元数据:{'block索引': 4, '函数名': 'ensure', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier ensure(uint deadline) {
require(deadline >= block.timestamp, 'MonoX:EXPIRED');
_;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-onlyPriceAdjuster-5
元数据:{'block索引': 5, '函数名': 'onlyPriceAdjuster', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyPriceAdjuster(){
require(priceAdjusterRole[msg.sender]==true,"MonoX:BAD_ROLE");
_;
}
event AddLiquidity(address indexed provider,
uint indexed pid,
address indexed token,
uint liquidityAmount,
uint vcashAmount, uint tokenAmount, uint price);
event RemoveLiquidity(address indexed provider,
uint indexed pid,
address indexed token,
uint liquidityAmount,
uint vcashAmount, uint tokenAmount, uint price);
event Swap(
address indexed user,
address indexed tokenIn,
address indexed tokenOut,
uint amountIn,
uint amountOut,
uint swapVcashValue
);
// event PriceAdjusterChanged(
//   address indexed priceAdjuster,
//   bool added
// );
event PoolBalanced(
address _token,
uint vcashIn
);
event SyntheticPoolPriceChanged(
address _token,
uint price
);
event PoolStatusChanged(
address _token,
PoolStatus oldStatus,
PoolStatus newStatus
);
IMonoXPool public monoXPool;
// mapping (token address => block number of the last trade)
mapping (address => uint) public lastTradedBlock;
uint256 constant MINIMUM_POOL_VALUE = 10000 * 1e18;
mapping (address=>bool) public priceAdjusterRole;
// ------------
uint public poolSizeMinLimit;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-initialize-6
元数据:{'block索引': 6, '函数名': 'initialize', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'IMonoXPool _monoXPool, IvCash _vcash', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(IMonoXPool _monoXPool, IvCash _vcash) public initializer {
OwnableUpgradeable.__Ownable_init();
monoXPool = _monoXPool;
vCash = _vcash;
WETH = _monoXPool.WETH();
fees = 300;
devFee = 50;
poolSize = 0;
unlocked = 1;
}
// receive() external payable {
//   assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
// }
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setFeeTo-7
元数据:{'block索引': 7, '函数名': 'setFeeTo', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _feeTo', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo (address _feeTo) onlyOwner external {
feeTo = _feeTo;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setFees-8
元数据:{'block索引': 8, '函数名': 'setFees', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint16 _fees', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFees (uint16 _fees) onlyOwner external {
require(_fees<1e3);
fees = _fees;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setDevFee-9
元数据:{'block索引': 9, '函数名': 'setDevFee', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint16 _devFee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setDevFee (uint16 _devFee) onlyOwner external {
require(_devFee<1e3);
devFee = _devFee;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setPoolSizeMinLimit-10
元数据:{'block索引': 10, '函数名': 'setPoolSizeMinLimit', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint _poolSizeMinLimit', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setPoolSizeMinLimit(uint _poolSizeMinLimit) onlyOwner external {
poolSizeMinLimit = _poolSizeMinLimit;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setTokenInsurance-11
元数据:{'block索引': 11, '函数名': 'setTokenInsurance', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _insurance', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setTokenInsurance (address _token, uint _insurance) onlyOwner external {
tokenInsurance[_token] = _insurance;
}
// when safu, setting token status to 2 can achieve significant gas savings
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setTokenStatus-12
元数据:{'block索引': 12, '函数名': 'setTokenStatus', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint8 _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setTokenStatus (address _token, uint8 _status) onlyOwner external {
tokenStatus[_token] = _status;
}
// update status of a pool. onlyOwner.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePoolStatus-13
元数据:{'block索引': 13, '函数名': 'updatePoolStatus', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolStatusChanged']", '返回值': ''}
函数切片:
function updatePoolStatus(address _token, PoolStatus _status) external onlyOwner {
PoolStatus poolStatus = pools[_token].status;
if(poolStatus==PoolStatus.PAUSED){
require(block.number > lastTradedBlock[_token].add(6000), "MonoX:TOO_EARLY");
}
else{
// okay to pause an official pool, wait 6k blocks and then convert it to synthetic
require(_status!=PoolStatus.SYNTHETIC,"MonoX:NO_SYNT");
}
emit PoolStatusChanged(_token, poolStatus,_status);
pools[_token].status = _status;
// unlisting a token allows creating a new pool of the same token.
// should move it to PAUSED if the goal is to blacklist the token forever
if(_status==PoolStatus.UNLISTED) {
tokenPoolStatus[_token] = 0;
}
}
/**
@dev update pools price if there were no active trading for the last 6000 blocks
@notice Only owner callable, new price can neither be 0 nor be equal to old one
@param _token pool identifider (token address)
@param _newPrice new price in wei (uint112)
*/
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePoolPrice-14
元数据:{'block索引': 14, '函数名': 'updatePoolPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _newPrice', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function updatePoolPrice(address _token, uint _newPrice) external onlyOwner {
require(_newPrice > 0, 'MonoX:0_PRICE');
require(tokenPoolStatus[_token] != 0, "MonoX:NO_POOL");
require(block.number > lastTradedBlock[_token].add(6000), "MonoX:TOO_EARLY");
pools[_token].price = _newPrice;
lastTradedBlock[_token] = block.number;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePriceAdjuster-15
元数据:{'block索引': 15, '函数名': 'updatePriceAdjuster', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, bool _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PriceAdjusterChanged']", '返回值': ''}
函数切片:
function updatePriceAdjuster(address account, bool _status) external onlyOwner{
priceAdjusterRole[account]=_status;
//emit PriceAdjusterChanged(account,_status);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setSynthPoolPrice-16
元数据:{'block索引': 16, '函数名': 'setSynthPoolPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint price', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['SyntheticPoolPriceChanged']", '返回值': ''}
函数切片:
function setSynthPoolPrice(address _token, uint price) external onlyPriceAdjuster {
require(pools[_token].status==PoolStatus.SYNTHETIC,"MonoX:NOT_SYNT");
require(price > 0, "MonoX:ZERO_PRICE");
pools[_token].price=price;
emit SyntheticPoolPriceChanged(_token,price);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-rebalancePool-17
元数据:{'block索引': 17, '函数名': 'rebalancePool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolBalanced']", '返回值': ''}
函数切片:
function rebalancePool(address _token) external lockToken(_token) onlyOwner{
// // PoolInfo memory pool = pools[_token];
// uint poolPrice = pools[_token].price;
// require(vcashIn <= pools[_token].vcashDebt,"MonoX:NO_CREDIT");
// require((pools[_token].tokenBalance * poolPrice).div(1e18) >= vcashIn,"MonoX:INSUF_TOKEN_VAL");
// // uint rebalancedAmount = vcashIn.mul(1e18).div(pool.price);
// monoXPool.safeTransferERC20Token(_token, msg.sender, vcashIn.mul(1e18).div(poolPrice));
// _syncPoolInfo(_token, vcashIn, 0);
// emit PoolBalanced(_token, vcashIn);
_internalRebalance(_token);
}
// must be called from a method with token lock to prevent reentry
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_internalRebalance-18
元数据:{'block索引': 18, '函数名': '_internalRebalance', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolBalanced']", '返回值': ''}
函数切片:
function _internalRebalance(address _token) internal {
uint poolPrice = pools[_token].price;
uint vcashIn = pools[_token].vcashDebt;
if(poolPrice.mul(pools[_token].tokenBalance) / 1e18 < vcashIn){
vcashIn = poolPrice.mul(pools[_token].tokenBalance) / 1e18;
}
if(tokenStatus[_token]==2){
monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));
}else{
uint256 balanceIn0 = IERC20(_token).balanceOf(address(monoXPool));
monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));
uint256 balanceIn1 = IERC20(_token).balanceOf(address(monoXPool));
uint realAmount = balanceIn0.sub(balanceIn1);
vcashIn = realAmount.mul(poolPrice) / 1e18;
}
_syncPoolInfo(_token, vcashIn, 0);
emit PoolBalanced(_token,vcashIn);
}
// creates a pool
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_createPool-19
元数据:{'block索引': 19, '函数名': '_createPool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _price, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _createPool (address _token, uint _price, PoolStatus _status) lock internal returns(uint256 _pid)  {
require(tokenPoolStatus[_token]==0, "MonoX:POOL_EXISTS");
require (_token != address(vCash), "MonoX:NO_vCash");
_pid = poolSize;
pools[_token] = PoolInfo({
token: _token,
pid: _pid,
vcashCredit: 0,
vcashDebt: 0,
tokenBalance: 0,
lastPoolValue: 0,
status: _status,
price: _price,
createdAt: block.timestamp
});
poolSize = _pid.add(1);
tokenPoolStatus[_token]=1;
// initialze pool's lasttradingblocknumber as the block number on which the pool is created
lastTradedBlock[_token] = block.number;
}
// creates a pool with special status
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addSpecialToken-20
元数据:{'block索引': 20, '函数名': 'addSpecialToken', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _price, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addSpecialToken (address _token, uint _price, PoolStatus _status) onlyOwner external returns(uint256 _pid)  {
_pid = _createPool(_token, _price, _status);
}
// internal func to pay contract owner
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_mintFee-21
元数据:{'block索引': 21, '函数名': '_mintFee', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint256 pid, uint256 lastPoolValue, uint256 newPoolValue', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _mintFee (uint256 pid, uint256 lastPoolValue, uint256 newPoolValue) internal {
// dropping tx fees for now
return;
}
// util func to get some basic pool info
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-getPool-22
元数据:{'block索引': 22, '函数名': 'getPool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPool (address _token) view public returns (uint256 poolValue,
uint256 tokenBalanceVcashValue, uint256 vcashCredit, uint256 vcashDebt) {
// PoolInfo memory pool = pools[_token];
vcashCredit = pools[_token].vcashCredit;
vcashDebt = pools[_token].vcashDebt;
tokenBalanceVcashValue = pools[_token].price.mul(pools[_token].tokenBalance)/1e18;
poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
}
// trustless listing pool creation. always creates unofficial pool
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-23
元数据:{'block索引': 23, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function listNewToken (address _token, uint _price,
uint256 vcashAmount,
uint256 tokenAmount,
address to) external returns(uint _pid, uint256 liquidity) {
_pid = _createPool(_token, _price, PoolStatus.LISTED);
liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);
}
// add liquidity pair to a pool. allows adding vcash.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-24
元数据:{'block索引': 24, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityPair (address _token,
uint256 vcashAmount,
uint256 tokenAmount,
address to) external returns(uint256 liquidity) {
liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);
}
// add liquidity pair to a pool. allows adding vcash.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-25
元数据:{'block索引': 25, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['AddLiquidity']", '返回值': ''}
函数切片:
function _addLiquidityPair (address _token,
uint256 vcashAmount,
uint256 tokenAmount,
address from,
address to) internal lockToken(_token) returns(uint256 liquidity) {
require (tokenAmount>0, "MonoX:BAD_AMOUNT");
require(tokenPoolStatus[_token]==1, "MonoX:NO_POOL");
// (uint256 poolValue, , ,) = getPool(_token);
PoolInfo memory pool = pools[_token];
IMonoXPool monoXPoolLocal = monoXPool;
uint256 poolValue = pool.price.mul(pool.tokenBalance)/1e18;
poolValue = poolValue.add(pool.vcashCredit).sub(pool.vcashDebt);
_mintFee(pool.pid, pool.lastPoolValue, poolValue);
tokenAmount = transferAndCheck(from,address(monoXPoolLocal),_token,tokenAmount);
if(vcashAmount>0){
vCash.safeTransferFrom(msg.sender, address(monoXPoolLocal), vcashAmount);
vCash.burn(address(monoXPool), vcashAmount);
}
// this is to avoid stack too deep
{
uint256 _totalSupply = monoXPoolLocal.totalSupplyOf(pool.pid);
uint256 liquidityVcashValue = vcashAmount.add(tokenAmount.mul(pool.price)/1e18);
if(_totalSupply==0){
liquidityVcashValue = liquidityVcashValue/1e6; // so $1m would get you 1e18
liquidity = liquidityVcashValue.sub(MINIMUM_LIQUIDITY);
// sorry, oz doesn't allow minting to address(0)
monoXPoolLocal.mintLp(feeTo, pool.pid, MINIMUM_LIQUIDITY, pool.status == PoolStatus.LISTED);
}else{
liquidity = _totalSupply.mul(liquidityVcashValue).div(poolValue);
}
}
monoXPoolLocal.mintLp(to, pool.pid, liquidity, pool.status == PoolStatus.LISTED);
_syncPoolInfo(_token, vcashAmount, 0);
emit AddLiquidity(to,
pool.pid,
_token,
liquidity,
vcashAmount, tokenAmount, pool.price);
}
// add one-sided liquidity to a pool. no vcash
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addLiquidity-26
元数据:{'block索引': 26, '函数名': 'addLiquidity', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint256 _amount, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity (address _token, uint256 _amount, address to) external returns(uint256 liquidity)  {
liquidity = _addLiquidityPair(_token, 0, _amount, msg.sender, to);
}
// add one-sided ETH liquidity to a pool. no vcash
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addLiquidityETH-27
元数据:{'block索引': 27, '函数名': 'addLiquidityETH', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityETH (address to) external payable returns(uint256 liquidity)  {
MonoXLibrary.safeTransferETH(address(monoXPool), msg.value);
monoXPool.depositWETH(msg.value);
liquidity = _addLiquidityPair(WETH, 0, msg.value, address(this), to);
}
// updates pool vcash balance, token balance and last pool value.
// this function requires others to do the input validation
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_syncPoolInfo-28
元数据:{'block索引': 28, '函数名': '_syncPoolInfo', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint256 vcashIn, uint256 vcashOut', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _syncPoolInfo (address _token, uint256 vcashIn, uint256 vcashOut) internal {
// PoolInfo memory pool = pools[_token];
uint256 tokenPoolPrice = pools[_token].price;
(uint256 vcashCredit, uint256 vcashDebt) = _updateVcashBalance(_token, vcashIn, vcashOut);
uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));
uint256 tokenBalanceVcashValue = tokenPoolPrice.mul(tokenReserve)/1e18;
require(tokenReserve <= uint112(-1));
pools[_token].tokenBalance = uint112(tokenReserve);
// poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
pools[_token].lastPoolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
}
// view func for removing liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-29
元数据:{'block索引': 29, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _removeLiquidity (address _token, uint256 liquidity,
address to) view public returns(
uint256 poolValue, uint256 liquidityIn, uint256 vcashOut, uint256 tokenOut) {
require (liquidity>0, "MonoX:BAD_AMOUNT");
uint256 tokenBalanceVcashValue;
uint256 vcashCredit;
uint256 vcashDebt;
PoolInfo memory pool = pools[_token];
IMonoXPool monoXPoolLocal = monoXPool;
uint256 lastAdded = monoXPoolLocal.liquidityLastAddedOf(pool.pid, msg.sender);
require((lastAdded + (pool.status == PoolStatus.OFFICIAL ? 4 hours : pool.status == PoolStatus.LISTED ? 24 hours : 0)) <= block.timestamp, "MonoX:WRONG_TIME"); // Users are not allowed to remove liquidity right after adding
address topLPHolder = monoXPoolLocal.topLPHolderOf(pool.pid);
require(pool.status != PoolStatus.LISTED || msg.sender != topLPHolder || pool.createdAt + 90 days < block.timestamp, "MonoX:TOP_HOLDER & WRONG_TIME"); // largest LP holder is not allowed to remove LP within 90 days after pool creation
(poolValue, tokenBalanceVcashValue, vcashCredit, vcashDebt) = getPool(_token);
uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);
liquidityIn = monoXPool.balanceOf(to, pool.pid)>liquidity?liquidity:monoXPool.balanceOf(to, pool.pid);
uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));
if(tokenReserve < pool.tokenBalance){
tokenBalanceVcashValue = tokenReserve.mul(pool.price)/1e18;
}
if(vcashDebt>0){
tokenReserve = (tokenBalanceVcashValue.sub(vcashDebt)).mul(1e18).div(pool.price);
}
// if vcashCredit==0, vcashOut will be 0 as well
vcashOut = liquidityIn.mul(vcashCredit).div(_totalSupply);
tokenOut = liquidityIn.mul(tokenReserve).div(_totalSupply);
}
// actually removes liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-30
元数据:{'block索引': 30, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {
(vcashOut, tokenOut) = _removeLiquidityHelper (_token, liquidity, to, minVcashOut, minTokenOut, false);
}
// actually removes liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-31
元数据:{'block索引': 31, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidity']", '返回值': ''}
函数切片:
function _removeLiquidityHelper (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut,
bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut)  {
require (tokenPoolStatus[_token]==1, "MonoX:NO_TOKEN");
PoolInfo memory pool = pools[_token];
uint256 poolValue;
uint256 liquidityIn;
(poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to);
_mintFee(pool.pid, pool.lastPoolValue, poolValue);
require (vcashOut>=minVcashOut, "MonoX:INSUFF_vCash");
require (tokenOut>=minTokenOut, "MonoX:INSUFF_TOKEN");
if (vcashOut>0){
vCash.mint(to, vcashOut);
}
if (!isETH) {
monoXPool.safeTransferERC20Token(_token, to, tokenOut);
} else {
monoXPool.withdrawWETH(tokenOut);
monoXPool.safeTransferETH(to, tokenOut);
}
monoXPool.burn(to, pool.pid, liquidityIn);
_syncPoolInfo(_token, 0, vcashOut);
emit RemoveLiquidity(to,
pool.pid,
_token,
liquidityIn,
vcashOut, tokenOut, pool.price);
}
// actually removes ETH liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-32
元数据:{'block索引': 32, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETH (uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {
(vcashOut, tokenOut) = _removeLiquidityHelper (WETH, liquidity, to, minVcashOut, minTokenOut, true);
}
// util func to compute new price
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-33
元数据:{'block索引': 33, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getNewPrice (uint256 originalPrice, uint256 reserve,
uint256 delta, uint256 deltaBlocks, TxType txType) pure internal returns(uint256 price) {
if(txType==TxType.SELL) {
// no risk of being div by 0
price = originalPrice.mul(reserve)/(reserve.add(delta));
}else{ // BUY
price = originalPrice.mul(reserve).div(reserve.sub(delta));
}
}
// util func to compute new price
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_getAvgPrice-34
元数据:{'block索引': 34, '函数名': '_getAvgPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint256 originalPrice, uint256 newPrice', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getAvgPrice (uint256 originalPrice, uint256 newPrice) pure internal returns(uint256 price) {
price = originalPrice.add(newPrice.mul(4))/5;
}
// standard swap interface implementing uniswap router V2
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-35
元数据:{'block索引': 35, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForToken(
address tokenOut,
uint amountOutMin,
address to,
uint deadline
) external virtual payable ensure(deadline) returns (uint amountOut) {
uint amountIn = msg.value;
MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);
monoXPool.depositWETH(amountIn);
amountOut = swapIn(WETH, tokenOut, address(this), to, amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-36
元数据:{'block索引': 36, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokenForETH(
address tokenIn,
uint amountIn,
uint amountOutMin,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountOut) {
IMonoXPool monoXPoolLocal = monoXPool;
amountOut = swapIn(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
monoXPoolLocal.withdrawWETH(amountOut);
monoXPoolLocal.safeTransferETH(to, amountOut);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-37
元数据:{'block索引': 37, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapETHForExactToken(
address tokenOut,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual payable ensure(deadline) returns (uint amountIn) {
uint amountSentIn = msg.value;
( , , amountIn, ) = getAmountIn(WETH, tokenOut, amountOut);
MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);
monoXPool.depositWETH(amountIn);
amountIn = swapOut(WETH, tokenOut, address(this), to, amountOut);
require(amountIn <= amountSentIn, 'MonoX:BAD_INPUT');
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
if (amountSentIn > amountIn) {
MonoXLibrary.safeTransferETH(msg.sender, amountSentIn.sub(amountIn));
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-38
元数据:{'block索引': 38, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokenForExactETH(
address tokenIn,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountIn) {
IMonoXPool monoXPoolLocal = monoXPool;
amountIn = swapOut(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountOut);
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
monoXPoolLocal.withdrawWETH(amountOut);
monoXPoolLocal.safeTransferETH(to, amountOut);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-39
元数据:{'block索引': 39, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokenForToken(
address tokenIn,
address tokenOut,
uint amountIn,
uint amountOutMin,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountOut) {
amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-40
元数据:{'block索引': 40, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokenForExactToken(
address tokenIn,
address tokenOut,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountIn) {
amountIn = swapOut(tokenIn, tokenOut, msg.sender, to, amountOut);
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
}
// util func to manipulate vcash balance
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-41
元数据:{'block索引': 41, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _updateVcashBalance (address _token,
uint _vcashIn, uint _vcashOut) internal returns (uint _vcashCredit, uint _vcashDebt) {
if(_vcashIn>_vcashOut){
_vcashIn = _vcashIn - _vcashOut;
_vcashOut = 0;
}else{
_vcashOut = _vcashOut - _vcashIn;
_vcashIn = 0;
}
// PoolInfo memory _pool = pools[_token];
uint _poolVcashCredit = pools[_token].vcashCredit;
uint _poolVcashDebt = pools[_token].vcashDebt;
PoolStatus _poolStatus = pools[_token].status;
if(_vcashOut>0){
(_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceSub(
_poolVcashCredit, _poolVcashDebt, _vcashOut);
require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));
pools[_token].vcashCredit = uint112(_vcashCredit);
pools[_token].vcashDebt = uint112(_vcashDebt);
}
if(_vcashIn>0){
(_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceAdd(
_poolVcashCredit, _poolVcashDebt, _vcashIn);
require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));
pools[_token].vcashCredit = uint112(_vcashCredit);
pools[_token].vcashDebt = uint112(_vcashDebt);
}
if(_poolStatus == PoolStatus.LISTED){
require (_vcashDebt<=tokenInsurance[_token], "MonoX:INSUFF_vCash");
}
}
// updates pool token balance and price.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-42
元数据:{'block索引': 42, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _updateTokenInfo (address _token, uint256 _price,
uint256 _vcashIn, uint256 _vcashOut, uint256 _ETHDebt) internal {
uint256 _balance = IERC20(_token).balanceOf(address(monoXPool));
_balance = _balance.sub(_ETHDebt);
require(pools[_token].status!=PoolStatus.PAUSED,"MonoX:PAUSED");
require(_balance <= uint112(-1));
(uint initialPoolValue, , ,) = getPool(_token);
pools[_token].tokenBalance = uint112(_balance);
pools[_token].price = _price;
// record last trade's block number in mapping: lastTradedBlock
lastTradedBlock[_token] = block.number;
_updateVcashBalance(_token, _vcashIn, _vcashOut);
(uint poolValue, , ,) = getPool(_token);
require(initialPoolValue <= poolValue || poolValue >= poolSizeMinLimit,
"MonoX:MIN_POOL_SIZE");
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-43
元数据:{'block索引': 43, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function directSwapAllowed(uint tokenInPoolPrice,uint tokenOutPoolPrice,
uint tokenInPoolTokenBalance, uint tokenOutPoolTokenBalance, PoolStatus status, bool getsAmountOut) internal pure returns(bool){
uint tokenInValue  = tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18);
uint tokenOutValue = tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18);
bool priceExists   = getsAmountOut?tokenInPoolPrice>0:tokenOutPoolPrice>0;
// only if it's official pool with similar size
return priceExists&&status==PoolStatus.OFFICIAL&&tokenInValue>0&&tokenOutValue>0&&
((tokenInValue/tokenOutValue)+(tokenOutValue/tokenInValue)==1);
}
// view func to compute amount required for tokenIn to get fixed amount of tokenOut
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-44
元数据:{'block索引': 44, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountIn(address tokenIn, address tokenOut,
uint256 amountOut) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice,
uint256 amountIn, uint256 tradeVcashValue) {
require(amountOut > 0, 'MonoX:INSUFF_INPUT');
uint256 amountOutWithFee = amountOut.mul(1e5).div(1e5 - fees);
address vcashAddress = address(vCash);
uint tokenOutPoolPrice = pools[tokenOut].price;
uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;
if(tokenOut==vcashAddress){
tradeVcashValue = amountOutWithFee;
tokenOutPrice = 1e18;
}else{
require (tokenPoolStatus[tokenOut]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenOutPool = pools[tokenOut];
PoolStatus tokenOutPoolStatus = pools[tokenOut].status;
require (tokenOutPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance,
amountOutWithFee, 0, TxType.BUY);
tradeVcashValue = _getAvgPrice(tokenOutPoolPrice, tokenOutPrice).mul(amountOutWithFee)/1e18;
}
if(tokenIn==vcashAddress){
amountIn = tradeVcashValue;
tokenInPrice = 1e18;
}else{
require (tokenPoolStatus[tokenIn]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenInPool = pools[tokenIn];
PoolStatus tokenInPoolStatus = pools[tokenIn].status;
uint tokenInPoolPrice = pools[tokenIn].price;
uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;
require (tokenInPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
amountIn = tradeVcashValue.add(tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18));
amountIn = tradeVcashValue.mul(tokenInPoolTokenBalance).div(amountIn);
bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenInPoolStatus,false);
// assuming p1*p2 = k, equivalent to uniswap's x * y = k
uint directSwapTokenInPrice = allowDirectSwap?tokenOutPoolPrice.mul(tokenInPoolPrice).div(tokenOutPrice):1;
tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance,
amountIn, 0, TxType.SELL);
tokenInPrice = directSwapTokenInPrice > tokenInPrice?directSwapTokenInPrice:tokenInPrice;
amountIn = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenInPoolPrice, tokenInPrice));
}
}
// view func to compute amount required for tokenOut to get fixed amount of tokenIn
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-45
元数据:{'block索引': 45, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountOut(address tokenIn, address tokenOut,
uint256 amountIn) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice,
uint256 amountOut, uint256 tradeVcashValue) {
require(amountIn > 0, 'MonoX:INSUFF_INPUT');
uint256 amountInWithFee = amountIn.mul(1e5-fees)/1e5;
address vcashAddress = address(vCash);
uint tokenInPoolPrice = pools[tokenIn].price;
uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;
if(tokenIn==vcashAddress){
tradeVcashValue = amountInWithFee;
tokenInPrice = 1e18;
}else{
require (tokenPoolStatus[tokenIn]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenInPool = pools[tokenIn];
PoolStatus tokenInPoolStatus = pools[tokenIn].status;
require (tokenInPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance,
amountInWithFee, 0, TxType.SELL);
tradeVcashValue = _getAvgPrice(tokenInPoolPrice, tokenInPrice).mul(amountInWithFee)/1e18;
}
if(tokenOut==vcashAddress){
amountOut = tradeVcashValue;
tokenOutPrice = 1e18;
}else{
require (tokenPoolStatus[tokenOut]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenOutPool = pools[tokenOut];
PoolStatus tokenOutPoolStatus = pools[tokenOut].status;
uint tokenOutPoolPrice = pools[tokenOut].price;
uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;
require (tokenOutPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
amountOut = tradeVcashValue.add(tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18));
amountOut = tradeVcashValue.mul(tokenOutPoolTokenBalance).div(amountOut);
bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenOutPoolStatus,true);
// assuming p1*p2 = k, equivalent to uniswap's x * y = k
uint directSwapTokenOutPrice = allowDirectSwap?tokenInPoolPrice.mul(tokenOutPoolPrice).div(tokenInPrice):uint(-1);
// prevent the attack where user can use a small pool to update price in a much larger pool
tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance,
amountOut, 0, TxType.BUY);
tokenOutPrice = directSwapTokenOutPrice < tokenOutPrice?directSwapTokenOutPrice:tokenOutPrice;
amountOut = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenOutPoolPrice, tokenOutPrice));
}
}
// swap from tokenIn to tokenOut with fixed tokenIn amount.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-46
元数据:{'block索引': 46, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Swap']", '返回值': ''}
函数切片:
function swapIn (address tokenIn, address tokenOut, address from, address to,
uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {
address monoXPoolLocal = address(monoXPool);
amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);
// uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;
uint256 tokenInPrice;
uint256 tokenOutPrice;
uint256 tradeVcashValue;
(tokenInPrice, tokenOutPrice, amountOut, tradeVcashValue) = getAmountOut(tokenIn, tokenOut, amountIn);
uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;
// trading in
if(tokenIn==address(vCash)){
vCash.burn(monoXPoolLocal, amountIn);
// all fees go to the other side
oneSideFeesInVcash = oneSideFeesInVcash.mul(2);
}else{
_updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);
}
// trading out
if(tokenOut==address(vCash)){
vCash.mint(to, amountOut);
}else{
if (to != monoXPoolLocal) {
IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);
}
_updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0,
to == monoXPoolLocal ? amountOut : 0);
}
if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){
_internalRebalance(tokenIn);
}
emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);
}
// swap from tokenIn to tokenOut with fixed tokenOut amount.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-47
元数据:{'block索引': 47, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Swap']", '返回值': ''}
函数切片:
function swapOut (address tokenIn, address tokenOut, address from, address to,
uint256 amountOut) internal lockToken(tokenIn) returns(uint256 amountIn)  {
uint256 tokenInPrice;
uint256 tokenOutPrice;
uint256 tradeVcashValue;
(tokenInPrice, tokenOutPrice, amountIn, tradeVcashValue) = getAmountIn(tokenIn, tokenOut, amountOut);
address monoXPoolLocal = address(monoXPool);
amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);
// uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;
uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;
// trading in
if(tokenIn==address(vCash)){
vCash.burn(monoXPoolLocal, amountIn);
// all fees go to buy side
oneSideFeesInVcash = oneSideFeesInVcash.mul(2);
}else {
_updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);
}
// trading out
if(tokenOut==address(vCash)){
vCash.mint(to, amountOut);
// all fees go to sell side
_updateVcashBalance(tokenIn, oneSideFeesInVcash, 0);
}else{
if (to != monoXPoolLocal) {
IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);
}
_updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0,
to == monoXPoolLocal ? amountOut:0 );
}
if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){
_internalRebalance(tokenIn);
}
emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);
}
// function balanceOf(address account, uint256 id) public view returns (uint256) {
//   return monoXPool.balanceOf(account, id);
// }
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-getConfig-48
元数据:{'block索引': 48, '函数名': 'getConfig', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getConfig() public view returns (address _vCash, address _weth, address _feeTo, uint16 _fees, uint16 _devFee) {
_vCash = address(vCash);
_weth = WETH;
_feeTo = feeTo;
_fees = fees;
_devFee = devFee;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-transferAndCheck-49
元数据:{'block索引': 49, '函数名': 'transferAndCheck', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address from,address to,address _token,uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferAndCheck(address from,address to,address _token,uint amount) internal returns (uint256){
if(from == address(this)){
return amount; // if it's ETH
}
// if it's not ETH
if(tokenStatus[_token]==2){
IERC20(_token).safeTransferFrom(from, to, amount);
return amount;
}else{
uint256 balanceIn0 = IERC20(_token).balanceOf(to);
IERC20(_token).safeTransferFrom(from, to, amount);
uint256 balanceIn1 = IERC20(_token).balanceOf(to);
return balanceIn1.sub(balanceIn0);
}
}
}
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-mint-0
元数据:{'block索引': 0, '函数名': 'mint', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address account, uint256 id, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint (address account, uint256 id, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-burn-1
元数据:{'block索引': 1, '函数名': 'burn', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address account, uint256 id, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn (address account, uint256 id, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-totalSupplyOf-2
元数据:{'block索引': 2, '函数名': 'totalSupplyOf', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 pid', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupplyOf(uint256 pid) external view returns (uint256);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-depositWETH-3
元数据:{'block索引': 3, '函数名': 'depositWETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function depositWETH(uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-withdrawWETH-4
元数据:{'block索引': 4, '函数名': 'withdrawWETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdrawWETH(uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-safeTransferETH-5
元数据:{'block索引': 5, '函数名': 'safeTransferETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address to, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferETH(address to, uint amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-safeTransferERC20Token-6
元数据:{'block索引': 6, '函数名': 'safeTransferERC20Token', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address token, address to, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferERC20Token(address token, address to, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-WETH-7
元数据:{'block索引': 7, '函数名': 'WETH', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function WETH() external view returns (address);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-liquidityLastAddedOf-8
元数据:{'block索引': 8, '函数名': 'liquidityLastAddedOf', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 pid, address account', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function liquidityLastAddedOf(uint256 pid, address account) external view returns(uint256);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-topLPHolderOf-9
元数据:{'block索引': 9, '函数名': 'topLPHolderOf', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'uint256 pid', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function topLPHolderOf(uint256 pid) external view returns (address);
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-mintLp-10
元数据:{'block索引': 10, '函数名': 'mintLp', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address account, uint256 id, uint256 amount, bool _isOfficial', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mintLp(address account, uint256 id, uint256 amount, bool _isOfficial) external;
------------------------------------------------
函数切片ID: MonoX.sol-IMonoXPool.sol-setWhitelist-11
元数据:{'block索引': 11, '函数名': 'setWhitelist', '函数所属的合约或接口': 'MonoX.sol-IMonoXPool.sol', '参数': 'address _whitelister, bool _isWhitelister', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setWhitelist(address _whitelister, bool _isWhitelister) external;
}
------------------------------------------------
函数切片ID: MonoX.sol-MonoXLibrary.sol-safeTransferETH-0
元数据:{'block索引': 0, '函数名': 'safeTransferETH', '函数所属的合约或接口': 'MonoX.sol-MonoXLibrary.sol', '参数': 'address to, uint256 value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferETH(address to, uint256 value) internal {
(bool success, ) = to.call{value: value}(new bytes(0));
require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');
}
// util func to manipulate vcash balance
------------------------------------------------
函数切片ID: MonoX.sol-MonoXLibrary.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-MonoXLibrary.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function vcashBalanceAdd (uint256 _credit, uint256 _debt,
uint256 delta) internal pure returns (uint256 _newCredit, uint256 _newDebt) {
if(_debt>0){
if(delta>_debt){
_newDebt = 0;
_newCredit = _credit.add(delta - _debt);
}else{
_newCredit = 0;
_newDebt = _debt - delta;
}
}else{
_newCredit = _credit.add(delta);
_newDebt = 0;
}
}
// util func to manipulate vcash balance
------------------------------------------------
函数切片ID: MonoX.sol-MonoXLibrary.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-MonoXLibrary.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function vcashBalanceSub (uint256 _credit, uint256 _debt,
uint256 delta) internal pure returns (uint256 _newCredit, uint256 _newDebt) {
if(_credit>0){
if(delta>_credit){
_newCredit = 0;
_newDebt = delta - _credit;
}else{
_newCredit = _credit - delta;
_newDebt = 0;
}
}else{
_newCredit = 0;
_newDebt = _debt.add(delta);
}
}
}
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getA-0
元数据:{'block索引': 0, '函数名': 'getA', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getA() external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getAllowlist-1
元数据:{'block索引': 1, '函数名': 'getAllowlist', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAllowlist() external view returns (IAllowlist);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getToken-2
元数据:{'block索引': 2, '函数名': 'getToken', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint8 index', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getToken(uint8 index) external view returns (IERC20);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getTokenIndex-3
元数据:{'block索引': 3, '函数名': 'getTokenIndex', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'address tokenAddress', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getTokenIndex(address tokenAddress) external view returns (uint8);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getTokenBalance-4
元数据:{'block索引': 4, '函数名': 'getTokenBalance', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint8 index', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getTokenBalance(uint8 index) external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getVirtualPrice-5
元数据:{'block索引': 5, '函数名': 'getVirtualPrice', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getVirtualPrice() external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-isGuarded-6
元数据:{'block索引': 6, '函数名': 'isGuarded', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isGuarded() external view returns (bool);
// min return calculation functions
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-7
元数据:{'block索引': 7, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateSwap(
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx
) external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-calculateTokenAmount-8
元数据:{'block索引': 8, '函数名': 'calculateTokenAmount', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint256[] calldata amounts, bool deposit', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateTokenAmount(uint256[] calldata amounts, bool deposit)
external
view
returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-calculateRemoveLiquidity-9
元数据:{'block索引': 9, '函数名': 'calculateRemoveLiquidity', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateRemoveLiquidity(uint256 amount)
external
view
returns (uint256[] memory);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-10
元数据:{'block索引': 10, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateRemoveLiquidityOneToken(
uint256 tokenAmount,
uint8 tokenIndex
) external view returns (uint256 availableTokenAmount);
// state modifying functions
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-11
元数据:{'block索引': 11, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(
IERC20[] memory pooledTokens,
uint8[] memory decimals,
string memory lpTokenName,
string memory lpTokenSymbol,
uint256 a,
uint256 fee,
uint256 adminFee,
address lpTokenTargetAddress
) external;
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-12
元数据:{'block索引': 12, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swap(
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx,
uint256 minDy,
uint256 deadline
) external returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-13
元数据:{'block索引': 13, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity(
uint256[] calldata amounts,
uint256 minToMint,
uint256 deadline
) external returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-14
元数据:{'block索引': 14, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity(
uint256 amount,
uint256[] calldata minAmounts,
uint256 deadline
) external returns (uint256[] memory);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-15
元数据:{'block索引': 15, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityOneToken(
uint256 tokenAmount,
uint8 tokenIndex,
uint256 minAmount,
uint256 deadline
) external returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-16
元数据:{'block索引': 16, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityImbalance(
uint256[] calldata amounts,
uint256 maxBurnAmount,
uint256 deadline
) external returns (uint256);
}
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-_getAPrecise-0
元数据:{'block索引': 0, '函数名': '_getAPrecise', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getAPrecise(Swap storage self) internal view returns (uint256) {
return AmplificationUtils._getAPrecise(self);
}
/**
* @notice Calculate the dy, the amount of selected token that user receives and
* the fee of withdrawing in one token
* @param tokenAmount the amount to withdraw in the pool's precision
* @param tokenIndex which token will be withdrawn
* @param self Swap struct to read from
* @return the amount of token user will receive
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateWithdrawOneToken(
Swap storage self,
uint256 tokenAmount,
uint8 tokenIndex
) external view returns (uint256) {
(uint256 availableTokenAmount, ) =
_calculateWithdrawOneToken(
self,
tokenAmount,
tokenIndex,
self.lpToken.totalSupply()
);
return availableTokenAmount;
}
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _calculateWithdrawOneToken(
Swap storage self,
uint256 tokenAmount,
uint8 tokenIndex,
uint256 totalSupply
) internal view returns (uint256, uint256) {
uint256 dy;
uint256 newY;
uint256 currentY;
(dy, newY, currentY) = calculateWithdrawOneTokenDY(
self,
tokenIndex,
tokenAmount,
totalSupply
);
// dy_0 (without fees)
// dy, dy_0 - dy
uint256 dySwapFee =
currentY
.sub(newY)
.div(self.tokenPrecisionMultipliers[tokenIndex])
.sub(dy);
return (dy, dySwapFee);
}
/**
* @notice Calculate the dy of withdrawing in one token
* @param self Swap struct to read from
* @param tokenIndex which token will be withdrawn
* @param tokenAmount the amount to withdraw in the pools precision
* @return the d and the new y after withdrawing one token
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateWithdrawOneTokenDY(
Swap storage self,
uint8 tokenIndex,
uint256 tokenAmount,
uint256 totalSupply
)
internal
view
returns (
uint256,
uint256,
uint256
)
{
// Get the current D, then solve the stableswap invariant
// y_i for D - tokenAmount
uint256[] memory xp = _xp(self);
require(tokenIndex < xp.length, "Token index out of range");
CalculateWithdrawOneTokenDYInfo memory v =
CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);
v.preciseA = _getAPrecise(self);
v.d0 = getD(xp, v.preciseA);
v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));
require(tokenAmount <= xp[tokenIndex], "Withdraw exceeds available");
v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);
uint256[] memory xpReduced = new uint256[](xp.length);
v.feePerToken = _feePerToken(self.swapFee, xp.length);
for (uint256 i = 0; i < xp.length; i++) {
uint256 xpi = xp[i];
// if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY
// else dxExpected = xp[i] - (xp[i] * d1 / d0)
// xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR
xpReduced[i] = xpi.sub(
(
(i == tokenIndex)
? xpi.mul(v.d1).div(v.d0).sub(v.newY)
: xpi.sub(xpi.mul(v.d1).div(v.d0))
)
.mul(v.feePerToken)
.div(FEE_DENOMINATOR)
);
}
uint256 dy =
xpReduced[tokenIndex].sub(
getYD(v.preciseA, tokenIndex, xpReduced, v.d1)
);
dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);
return (dy, v.newY, xp[tokenIndex]);
}
/**
* @notice Calculate the price of a token in the pool with given
* precision-adjusted balances and a particular D.
*
* @dev This is accomplished via solving the invariant iteratively.
* See the StableSwap paper and Curve.fi implementation for further details.
*
* x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)
* x_1**2 + b*x_1 = c
* x_1 = (x_1**2 + c) / (2*x_1 + b)
*
* @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.
* @param tokenIndex Index of token we are calculating for.
* @param xp a precision-adjusted set of pool balances. Array should be
* the same cardinality as the pool.
* @param d the stableswap invariant
* @return the price of the token, in the same precision as in xp
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getYD(
uint256 a,
uint8 tokenIndex,
uint256[] memory xp,
uint256 d
) internal pure returns (uint256) {
uint256 numTokens = xp.length;
require(tokenIndex < numTokens, "Token not found");
uint256 c = d;
uint256 s;
uint256 nA = a.mul(numTokens);
for (uint256 i = 0; i < numTokens; i++) {
if (i != tokenIndex) {
s = s.add(xp[i]);
c = c.mul(d).div(xp[i].mul(numTokens));
// If we were to protect the division loss we would have to keep the denominator separate
// and divide at the end. However this leads to overflow with large numTokens or/and D.
// c = c * D * D * D * ... overflow!
}
}
c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));
uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));
uint256 yPrev;
uint256 y = d;
for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
yPrev = y;
y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));
if (y.within1(yPrev)) {
return y;
}
}
revert("Approximation did not converge");
}
/**
* @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.
* @param xp a precision-adjusted set of pool balances. Array should be the same cardinality
* as the pool.
* @param a the amplification coefficient * n * (n - 1) in A_PRECISION.
* See the StableSwap paper for details
* @return the invariant, at the precision of the pool
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-getD-5
元数据:{'block索引': 5, '函数名': 'getD', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'uint256[] memory xp, uint256 a', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getD(uint256[] memory xp, uint256 a)
internal
pure
returns (uint256)
{
uint256 numTokens = xp.length;
uint256 s;
for (uint256 i = 0; i < numTokens; i++) {
s = s.add(xp[i]);
}
if (s == 0) {
return 0;
}
uint256 prevD;
uint256 d = s;
uint256 nA = a.mul(numTokens);
for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
uint256 dP = d;
for (uint256 j = 0; j < numTokens; j++) {
dP = dP.mul(d).div(xp[j].mul(numTokens));
// If we were to protect the division loss we would have to keep the denominator separate
// and divide at the end. However this leads to overflow with large numTokens or/and D.
// dP = dP * D * D * D * ... overflow!
}
prevD = d;
d = nA
.mul(s)
.div(AmplificationUtils.A_PRECISION)
.add(dP.mul(numTokens))
.mul(d)
.div(
nA
.sub(AmplificationUtils.A_PRECISION)
.mul(d)
.div(AmplificationUtils.A_PRECISION)
.add(numTokens.add(1).mul(dP))
);
if (d.within1(prevD)) {
return d;
}
}
// Convergence should occur in 4 loops or less. If this is reached, there may be something wrong
// with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`
// function which does not rely on D.
revert("D does not converge");
}
/**
* @notice Given a set of balances and precision multipliers, return the
* precision-adjusted balances.
*
* @param balances an array of token balances, in their native precisions.
* These should generally correspond with pooled tokens.
*
* @param precisionMultipliers an array of multipliers, corresponding to
* the amounts in the balances array. When multiplied together they
* should yield amounts at the pool's precision.
*
* @return an array of amounts "scaled" to the pool's precision
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-6
元数据:{'block索引': 6, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _xp(
uint256[] memory balances,
uint256[] memory precisionMultipliers
) internal pure returns (uint256[] memory) {
uint256 numTokens = balances.length;
require(
numTokens == precisionMultipliers.length,
"Balances must match multipliers"
);
uint256[] memory xp = new uint256[](numTokens);
for (uint256 i = 0; i < numTokens; i++) {
xp[i] = balances[i].mul(precisionMultipliers[i]);
}
return xp;
}
/**
* @notice Return the precision-adjusted balances of all tokens in the pool
* @param self Swap struct to read from
* @return the pool balances "scaled" to the pool's precision, allowing
* them to be more easily compared.
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-_xp-7
元数据:{'block索引': 7, '函数名': '_xp', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _xp(Swap storage self) internal view returns (uint256[] memory) {
return _xp(self.balances, self.tokenPrecisionMultipliers);
}
/**
* @notice Get the virtual price, to help calculate profit
* @param self Swap struct to read from
* @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-getVirtualPrice-8
元数据:{'block索引': 8, '函数名': 'getVirtualPrice', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getVirtualPrice(Swap storage self)
external
view
returns (uint256)
{
uint256 d = getD(_xp(self), _getAPrecise(self));
LPToken lpToken = self.lpToken;
uint256 supply = lpToken.totalSupply();
if (supply > 0) {
return d.mul(10**uint256(POOL_PRECISION_DECIMALS)).div(supply);
}
return 0;
}
/**
* @notice Calculate the new balances of the tokens given the indexes of the token
* that is swapped from (FROM) and the token that is swapped to (TO).
* This function is used as a helper function to calculate how much TO token
* the user should receive on swap.
*
* @param preciseA precise form of amplification coefficient
* @param tokenIndexFrom index of FROM token
* @param tokenIndexTo index of TO token
* @param x the new total amount of FROM token
* @param xp balances of the tokens in the pool
* @return the amount of TO token that should remain in the pool
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-9
元数据:{'block索引': 9, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getY(
uint256 preciseA,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 x,
uint256[] memory xp
) internal pure returns (uint256) {
uint256 numTokens = xp.length;
require(
tokenIndexFrom != tokenIndexTo,
"Can't compare token to itself"
);
require(
tokenIndexFrom < numTokens && tokenIndexTo < numTokens,
"Tokens must be in pool"
);
uint256 d = getD(xp, preciseA);
uint256 c = d;
uint256 s;
uint256 nA = numTokens.mul(preciseA);
uint256 _x;
for (uint256 i = 0; i < numTokens; i++) {
if (i == tokenIndexFrom) {
_x = x;
} else if (i != tokenIndexTo) {
_x = xp[i];
} else {
continue;
}
s = s.add(_x);
c = c.mul(d).div(_x.mul(numTokens));
// If we were to protect the division loss we would have to keep the denominator separate
// and divide at the end. However this leads to overflow with large numTokens or/and D.
// c = c * D * D * D * ... overflow!
}
c = c.mul(d).mul(AmplificationUtils.A_PRECISION).div(nA.mul(numTokens));
uint256 b = s.add(d.mul(AmplificationUtils.A_PRECISION).div(nA));
uint256 yPrev;
uint256 y = d;
// iterative approximation
for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {
yPrev = y;
y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));
if (y.within1(yPrev)) {
return y;
}
}
revert("Approximation did not converge");
}
/**
* @notice Externally calculates a swap between two tokens.
* @param self Swap struct to read from
* @param tokenIndexFrom the token to sell
* @param tokenIndexTo the token to buy
* @param dx the number of tokens to sell. If the token charges a fee on transfers,
* use the amount that gets transferred after the fee.
* @return dy the number of tokens the user will get
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-10
元数据:{'block索引': 10, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateSwap(
Swap storage self,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx
) external view returns (uint256 dy) {
(dy, ) = _calculateSwap(
self,
tokenIndexFrom,
tokenIndexTo,
dx,
self.balances
);
}
/**
* @notice Internally calculates a swap between two tokens.
*
* @dev The caller is expected to transfer the actual amounts (dx and dy)
* using the token contracts.
*
* @param self Swap struct to read from
* @param tokenIndexFrom the token to sell
* @param tokenIndexTo the token to buy
* @param dx the number of tokens to sell. If the token charges a fee on transfers,
* use the amount that gets transferred after the fee.
* @return dy the number of tokens the user will get
* @return dyFee the associated fee
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-11
元数据:{'block索引': 11, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _calculateSwap(
Swap storage self,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx,
uint256[] memory balances
) internal view returns (uint256 dy, uint256 dyFee) {
uint256[] memory multipliers = self.tokenPrecisionMultipliers;
uint256[] memory xp = _xp(balances, multipliers);
require(
tokenIndexFrom < xp.length && tokenIndexTo < xp.length,
"Token index out of range"
);
uint256 x = dx.mul(multipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);
uint256 y =
getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);
dy = xp[tokenIndexTo].sub(y).sub(1);
dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);
dy = dy.sub(dyFee).div(multipliers[tokenIndexTo]);
}
/**
* @notice A simple method to calculate amount of each underlying
* tokens that is returned upon burning given amount of
* LP tokens
*
* @param amount the amount of LP tokens that would to be burned on
* withdrawal
* @return array of amounts of tokens user will receive
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-calculateRemoveLiquidity-12
元数据:{'block索引': 12, '函数名': 'calculateRemoveLiquidity', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateRemoveLiquidity(Swap storage self, uint256 amount)
external
view
returns (uint256[] memory)
{
return
_calculateRemoveLiquidity(
self.balances,
amount,
self.lpToken.totalSupply()
);
}
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-13
元数据:{'block索引': 13, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _calculateRemoveLiquidity(
uint256[] memory balances,
uint256 amount,
uint256 totalSupply
) internal pure returns (uint256[] memory) {
require(amount <= totalSupply, "Cannot exceed total supply");
uint256[] memory amounts = new uint256[](balances.length);
for (uint256 i = 0; i < balances.length; i++) {
amounts[i] = balances[i].mul(amount).div(totalSupply);
}
return amounts;
}
/**
* @notice A simple method to calculate prices from deposits or
* withdrawals, excluding fees but including slippage. This is
* helpful as an input into the various "min" parameters on calls
* to fight front-running
*
* @dev This shouldn't be used outside frontends for user estimates.
*
* @param self Swap struct to read from
* @param amounts an array of token amounts to deposit or withdrawal,
* corresponding to pooledTokens. The amount should be in each
* pooled token's native precision. If a token charges a fee on transfers,
* use the amount that gets transferred after the fee.
* @param deposit whether this is a deposit or a withdrawal
* @return if deposit was true, total amount of lp token that will be minted and if
* deposit was false, total amount of lp token that will be burned
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-14
元数据:{'block索引': 14, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateTokenAmount(
Swap storage self,
uint256[] calldata amounts,
bool deposit
) external view returns (uint256) {
uint256 a = _getAPrecise(self);
uint256[] memory balances = self.balances;
uint256[] memory multipliers = self.tokenPrecisionMultipliers;
uint256 d0 = getD(_xp(balances, multipliers), a);
for (uint256 i = 0; i < balances.length; i++) {
if (deposit) {
balances[i] = balances[i].add(amounts[i]);
} else {
balances[i] = balances[i].sub(
amounts[i],
"Cannot withdraw more than available"
);
}
}
uint256 d1 = getD(_xp(balances, multipliers), a);
uint256 totalSupply = self.lpToken.totalSupply();
if (deposit) {
return d1.sub(d0).mul(totalSupply).div(d0);
} else {
return d0.sub(d1).mul(totalSupply).div(d0);
}
}
/**
* @notice return accumulated amount of admin fees of the token with given index
* @param self Swap struct to read from
* @param index Index of the pooled token
* @return admin balance in the token's precision
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-getAdminBalance-15
元数据:{'block索引': 15, '函数名': 'getAdminBalance', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self, uint256 index', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAdminBalance(Swap storage self, uint256 index)
external
view
returns (uint256)
{
require(index < self.pooledTokens.length, "Token index out of range");
return
self.pooledTokens[index].balanceOf(address(this)).sub(
self.balances[index]
);
}
/**
* @notice internal helper function to calculate fee per token multiplier used in
* swap fee calculations
* @param swapFee swap fee for the tokens
* @param numTokens number of tokens pooled
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-_feePerToken-16
元数据:{'block索引': 16, '函数名': '_feePerToken', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'uint256 swapFee, uint256 numTokens', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _feePerToken(uint256 swapFee, uint256 numTokens)
internal
pure
returns (uint256)
{
return swapFee.mul(numTokens).div(numTokens.sub(1).mul(4));
}
/*** STATE MODIFYING FUNCTIONS ***/
/**
* @notice swap two tokens in the pool
* @param self Swap struct to read from and write to
* @param tokenIndexFrom the token the user wants to sell
* @param tokenIndexTo the token the user wants to buy
* @param dx the amount of tokens the user wants to sell
* @param minDy the min amount the user would like to receive, or revert.
* @return amount of token user received on swap
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-17
元数据:{'block索引': 17, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['TokenSwap']", '返回值': ''}
函数切片:
function swap(
Swap storage self,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx,
uint256 minDy
) external returns (uint256) {
{
IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];
require(
dx <= tokenFrom.balanceOf(msg.sender),
"Cannot swap more than you own"
);
// Transfer tokens first to see if a fee was charged on transfer
uint256 beforeBalance = tokenFrom.balanceOf(address(this));
tokenFrom.safeTransferFrom(msg.sender, address(this), dx);
// Use the actual transferred amount for AMM math
dx = tokenFrom.balanceOf(address(this)).sub(beforeBalance);
}
uint256 dy;
uint256 dyFee;
uint256[] memory balances = self.balances;
(dy, dyFee) = _calculateSwap(
self,
tokenIndexFrom,
tokenIndexTo,
dx,
balances
);
require(dy >= minDy, "Swap didn't result in min tokens");
uint256 dyAdminFee =
dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(
self.tokenPrecisionMultipliers[tokenIndexTo]
);
self.balances[tokenIndexFrom] = balances[tokenIndexFrom].add(dx);
self.balances[tokenIndexTo] = balances[tokenIndexTo].sub(dy).sub(
dyAdminFee
);
self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);
emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);
return dy;
}
/**
* @notice Add liquidity to the pool
* @param self Swap struct to read from and write to
* @param amounts the amounts of each token to add, in their native precision
* @param minToMint the minimum LP tokens adding this amount of liquidity
* should mint, otherwise revert. Handy for front-running mitigation
* allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.
* @return amount of LP token user received
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-18
元数据:{'block索引': 18, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['AddLiquidity']", '返回值': ''}
函数切片:
function addLiquidity(
Swap storage self,
uint256[] memory amounts,
uint256 minToMint
) external returns (uint256) {
IERC20[] memory pooledTokens = self.pooledTokens;
require(
amounts.length == pooledTokens.length,
"Amounts must match pooled tokens"
);
// current state
ManageLiquidityInfo memory v =
ManageLiquidityInfo(
0,
0,
0,
_getAPrecise(self),
self.lpToken,
0,
self.balances,
self.tokenPrecisionMultipliers
);
v.totalSupply = v.lpToken.totalSupply();
if (v.totalSupply != 0) {
v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);
}
uint256[] memory newBalances = new uint256[](pooledTokens.length);
for (uint256 i = 0; i < pooledTokens.length; i++) {
require(
v.totalSupply != 0 || amounts[i] > 0,
"Must supply all tokens in pool"
);
// Transfer tokens first to see if a fee was charged on transfer
if (amounts[i] != 0) {
uint256 beforeBalance =
pooledTokens[i].balanceOf(address(this));
pooledTokens[i].safeTransferFrom(
msg.sender,
address(this),
amounts[i]
);
// Update the amounts[] with actual transfer amount
amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(
beforeBalance
);
}
newBalances[i] = v.balances[i].add(amounts[i]);
}
// invariant after change
v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);
require(v.d1 > v.d0, "D should increase");
// updated to reflect fees and calculate the user's LP tokens
v.d2 = v.d1;
uint256[] memory fees = new uint256[](pooledTokens.length);
if (v.totalSupply != 0) {
uint256 feePerToken =
_feePerToken(self.swapFee, pooledTokens.length);
for (uint256 i = 0; i < pooledTokens.length; i++) {
uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);
fees[i] = feePerToken
.mul(idealBalance.difference(newBalances[i]))
.div(FEE_DENOMINATOR);
self.balances[i] = newBalances[i].sub(
fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)
);
newBalances[i] = newBalances[i].sub(fees[i]);
}
v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);
} else {
// the initial depositor doesn't pay fees
self.balances = newBalances;
}
uint256 toMint;
if (v.totalSupply == 0) {
toMint = v.d1;
} else {
toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);
}
require(toMint >= minToMint, "Couldn't mint min requested");
// mint the user's LP tokens
v.lpToken.mint(msg.sender, toMint);
emit AddLiquidity(
msg.sender,
amounts,
fees,
v.d1,
v.totalSupply.add(toMint)
);
return toMint;
}
/**
* @notice Burn LP tokens to remove liquidity from the pool.
* @dev Liquidity can always be removed, even when the pool is paused.
* @param self Swap struct to read from and write to
* @param amount the amount of LP tokens to burn
* @param minAmounts the minimum amounts of each token in the pool
* acceptable for this burn. Useful as a front-running mitigation
* @return amounts of tokens the user received
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-19
元数据:{'block索引': 19, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidity']", '返回值': ''}
函数切片:
function removeLiquidity(
Swap storage self,
uint256 amount,
uint256[] calldata minAmounts
) external returns (uint256[] memory) {
LPToken lpToken = self.lpToken;
IERC20[] memory pooledTokens = self.pooledTokens;
require(amount <= lpToken.balanceOf(msg.sender), ">LP.balanceOf");
require(
minAmounts.length == pooledTokens.length,
"minAmounts must match poolTokens"
);
uint256[] memory balances = self.balances;
uint256 totalSupply = lpToken.totalSupply();
uint256[] memory amounts =
_calculateRemoveLiquidity(balances, amount, totalSupply);
for (uint256 i = 0; i < amounts.length; i++) {
require(amounts[i] >= minAmounts[i], "amounts[i] < minAmounts[i]");
self.balances[i] = balances[i].sub(amounts[i]);
pooledTokens[i].safeTransfer(msg.sender, amounts[i]);
}
lpToken.burnFrom(msg.sender, amount);
emit RemoveLiquidity(msg.sender, amounts, totalSupply.sub(amount));
return amounts;
}
/**
* @notice Remove liquidity from the pool all in one token.
* @param self Swap struct to read from and write to
* @param tokenAmount the amount of the lp tokens to burn
* @param tokenIndex the index of the token you want to receive
* @param minAmount the minimum amount to withdraw, otherwise revert
* @return amount chosen token that user received
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-20
元数据:{'block索引': 20, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidityOne']", '返回值': ''}
函数切片:
function removeLiquidityOneToken(
Swap storage self,
uint256 tokenAmount,
uint8 tokenIndex,
uint256 minAmount
) external returns (uint256) {
LPToken lpToken = self.lpToken;
IERC20[] memory pooledTokens = self.pooledTokens;
require(tokenAmount <= lpToken.balanceOf(msg.sender), ">LP.balanceOf");
require(tokenIndex < pooledTokens.length, "Token not found");
uint256 totalSupply = lpToken.totalSupply();
(uint256 dy, uint256 dyFee) =
_calculateWithdrawOneToken(
self,
tokenAmount,
tokenIndex,
totalSupply
);
require(dy >= minAmount, "dy < minAmount");
self.balances[tokenIndex] = self.balances[tokenIndex].sub(
dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))
);
lpToken.burnFrom(msg.sender, tokenAmount);
pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);
emit RemoveLiquidityOne(
msg.sender,
tokenAmount,
totalSupply,
tokenIndex,
dy
);
return dy;
}
/**
* @notice Remove liquidity from the pool, weighted differently than the
* pool's current balances.
*
* @param self Swap struct to read from and write to
* @param amounts how much of each token to withdraw
* @param maxBurnAmount the max LP token provider is willing to pay to
* remove liquidity. Useful as a front-running mitigation.
* @return actual amount of LP tokens burned in the withdrawal
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-21
元数据:{'block索引': 21, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidityImbalance']", '返回值': ''}
函数切片:
function removeLiquidityImbalance(
Swap storage self,
uint256[] memory amounts,
uint256 maxBurnAmount
) public returns (uint256) {
ManageLiquidityInfo memory v =
ManageLiquidityInfo(
0,
0,
0,
_getAPrecise(self),
self.lpToken,
0,
self.balances,
self.tokenPrecisionMultipliers
);
v.totalSupply = v.lpToken.totalSupply();
IERC20[] memory pooledTokens = self.pooledTokens;
require(
amounts.length == pooledTokens.length,
"Amounts should match pool tokens"
);
require(
maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&
maxBurnAmount != 0,
">LP.balanceOf"
);
uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);
uint256[] memory fees = new uint256[](pooledTokens.length);
{
uint256[] memory balances1 = new uint256[](pooledTokens.length);
v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);
for (uint256 i = 0; i < pooledTokens.length; i++) {
balances1[i] = v.balances[i].sub(
amounts[i],
"Cannot withdraw more than available"
);
}
v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);
for (uint256 i = 0; i < pooledTokens.length; i++) {
uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);
uint256 difference = idealBalance.difference(balances1[i]);
fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);
self.balances[i] = balances1[i].sub(
fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)
);
balances1[i] = balances1[i].sub(fees[i]);
}
v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);
}
uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);
require(tokenAmount != 0, "Burnt amount cannot be zero");
tokenAmount = tokenAmount.add(1);
require(tokenAmount <= maxBurnAmount, "tokenAmount > maxBurnAmount");
v.lpToken.burnFrom(msg.sender, tokenAmount);
for (uint256 i = 0; i < pooledTokens.length; i++) {
pooledTokens[i].safeTransfer(msg.sender, amounts[i]);
}
emit RemoveLiquidityImbalance(
msg.sender,
amounts,
fees,
v.d1,
v.totalSupply.sub(tokenAmount)
);
return tokenAmount;
}
/**
* @notice withdraw all admin fees to a given address
* @param self Swap struct to withdraw fees from
* @param to Address to send the fees to
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-withdrawAdminFees-22
元数据:{'block索引': 22, '函数名': 'withdrawAdminFees', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdrawAdminFees(Swap storage self, address to) external {
IERC20[] memory pooledTokens = self.pooledTokens;
for (uint256 i = 0; i < pooledTokens.length; i++) {
IERC20 token = pooledTokens[i];
uint256 balance =
token.balanceOf(address(this)).sub(self.balances[i]);
if (balance != 0) {
token.safeTransfer(to, balance);
}
}
}
/**
* @notice Sets the admin fee
* @dev adminFee cannot be higher than 100% of the swap fee
* @param self Swap struct to update
* @param newAdminFee new admin fee to be applied on future transactions
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-setAdminFee-23
元数据:{'block索引': 23, '函数名': 'setAdminFee', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self, uint256 newAdminFee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['NewAdminFee']", '返回值': ''}
函数切片:
function setAdminFee(Swap storage self, uint256 newAdminFee) external {
require(newAdminFee <= MAX_ADMIN_FEE, "Fee is too high");
self.adminFee = newAdminFee;
emit NewAdminFee(newAdminFee);
}
/**
* @notice update the swap fee
* @dev fee cannot be higher than 1% of each swap
* @param self Swap struct to update
* @param newSwapFee new swap fee to be applied on future transactions
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-SwapUtils.sol-setSwapFee-24
元数据:{'block索引': 24, '函数名': 'setSwapFee', '函数所属的合约或接口': 'Saddle Finance.sol-SwapUtils.sol', '参数': 'Swap storage self, uint256 newSwapFee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['NewSwapFee']", '返回值': ''}
函数切片:
function setSwapFee(Swap storage self, uint256 newSwapFee) external {
require(newSwapFee <= MAX_SWAP_FEE, "Fee is too high");
self.swapFee = newSwapFee;
emit NewSwapFee(newSwapFee);
}
}
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-_getBaseVirtualPrice-0
元数据:{'block索引': 0, '函数名': '_getBaseVirtualPrice', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': 'MetaSwap storage metaSwapStorage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getBaseVirtualPrice(MetaSwap storage metaSwapStorage)
internal
view
returns (uint256)
{
if (
block.timestamp >
metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME
) {
return metaSwapStorage.baseSwap.getVirtualPrice();
}
return metaSwapStorage.baseVirtualPrice;
}
/**
* @notice Calculate how much the user would receive when withdrawing via single token
* @param self Swap struct to read from
* @param metaSwapStorage MetaSwap struct to read from
* @param tokenAmount the amount to withdraw in the pool's precision
* @param tokenIndex which token will be withdrawn
* @return dy the amount of token user will receive
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateWithdrawOneToken(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint256 tokenAmount,
uint8 tokenIndex
) external view returns (uint256 dy) {
(dy, ) = _calculateWithdrawOneToken(
self,
tokenAmount,
tokenIndex,
_getBaseVirtualPrice(metaSwapStorage),
self.lpToken.totalSupply()
);
}
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _calculateWithdrawOneToken(
SwapUtils.Swap storage self,
uint256 tokenAmount,
uint8 tokenIndex,
uint256 baseVirtualPrice,
uint256 totalSupply
) internal view returns (uint256, uint256) {
uint256 dy;
uint256 dySwapFee;
{
uint256 currentY;
uint256 newY;
// Calculate how much to withdraw
(dy, newY, currentY) = _calculateWithdrawOneTokenDY(
self,
tokenIndex,
tokenAmount,
baseVirtualPrice,
totalSupply
);
// Calculate the associated swap fee
dySwapFee = currentY
.sub(newY)
.div(self.tokenPrecisionMultipliers[tokenIndex])
.sub(dy);
}
return (dy, dySwapFee);
}
/**
* @notice Calculate the dy of withdrawing in one token
* @param self Swap struct to read from
* @param tokenIndex which token will be withdrawn
* @param tokenAmount the amount to withdraw in the pools precision
* @param baseVirtualPrice the virtual price of the base swap's LP token
* @return the dy excluding swap fee, the new y after withdrawing one token, and current y
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _calculateWithdrawOneTokenDY(
SwapUtils.Swap storage self,
uint8 tokenIndex,
uint256 tokenAmount,
uint256 baseVirtualPrice,
uint256 totalSupply
)
internal
view
returns (
uint256,
uint256,
uint256
)
{
// Get the current D, then solve the stableswap invariant
// y_i for D - tokenAmount
uint256[] memory xp = _xp(self, baseVirtualPrice);
require(tokenIndex < xp.length, "Token index out of range");
CalculateWithdrawOneTokenDYInfo memory v =
CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, self._getAPrecise(), 0);
v.d0 = SwapUtils.getD(xp, v.preciseA);
v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));
require(tokenAmount <= xp[tokenIndex], "Withdraw exceeds available");
v.newY = SwapUtils.getYD(v.preciseA, tokenIndex, xp, v.d1);
uint256[] memory xpReduced = new uint256[](xp.length);
v.feePerToken = SwapUtils._feePerToken(self.swapFee, xp.length);
for (uint256 i = 0; i < xp.length; i++) {
v.xpi = xp[i];
// if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY
// else dxExpected = xp[i] - (xp[i] * d1 / d0)
// xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR
xpReduced[i] = v.xpi.sub(
(
(i == tokenIndex)
? v.xpi.mul(v.d1).div(v.d0).sub(v.newY)
: v.xpi.sub(v.xpi.mul(v.d1).div(v.d0))
)
.mul(v.feePerToken)
.div(FEE_DENOMINATOR)
);
}
uint256 dy =
xpReduced[tokenIndex].sub(
SwapUtils.getYD(v.preciseA, tokenIndex, xpReduced, v.d1)
);
if (tokenIndex == xp.length.sub(1)) {
dy = dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(baseVirtualPrice);
}
dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);
return (dy, v.newY, xp[tokenIndex]);
}
/**
* @notice Given a set of balances and precision multipliers, return the
* precision-adjusted balances. The last element will also get scaled up by
* the given baseVirtualPrice.
*
* @param balances an array of token balances, in their native precisions.
* These should generally correspond with pooled tokens.
*
* @param precisionMultipliers an array of multipliers, corresponding to
* the amounts in the balances array. When multiplied together they
* should yield amounts at the pool's precision.
*
* @param baseVirtualPrice the base virtual price to scale the balance of the
* base Swap's LP token.
*
* @return an array of amounts "scaled" to the pool's precision
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _xp(
uint256[] memory balances,
uint256[] memory precisionMultipliers,
uint256 baseVirtualPrice
) internal pure returns (uint256[] memory) {
uint256[] memory xp = SwapUtils._xp(balances, precisionMultipliers);
uint256 baseLPTokenIndex = balances.length.sub(1);
xp[baseLPTokenIndex] = xp[baseLPTokenIndex].mul(baseVirtualPrice).div(
BASE_VIRTUAL_PRICE_PRECISION
);
return xp;
}
/**
* @notice Return the precision-adjusted balances of all tokens in the pool
* @param self Swap struct to read from
* @return the pool balances "scaled" to the pool's precision, allowing
* them to be more easily compared.
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-_xp-5
元数据:{'block索引': 5, '函数名': '_xp', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': 'SwapUtils.Swap storage self, uint256 baseVirtualPrice', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _xp(SwapUtils.Swap storage self, uint256 baseVirtualPrice)
internal
view
returns (uint256[] memory)
{
return
_xp(
self.balances,
self.tokenPrecisionMultipliers,
baseVirtualPrice
);
}
/**
* @notice Get the virtual price, to help calculate profit
* @param self Swap struct to read from
* @param metaSwapStorage MetaSwap struct to read from
* @return the virtual price, scaled to precision of BASE_VIRTUAL_PRICE_PRECISION
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-6
元数据:{'block索引': 6, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getVirtualPrice(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage
) external view returns (uint256) {
uint256 d =
SwapUtils.getD(
_xp(
self.balances,
self.tokenPrecisionMultipliers,
_getBaseVirtualPrice(metaSwapStorage)
),
self._getAPrecise()
);
uint256 supply = self.lpToken.totalSupply();
if (supply != 0) {
return d.mul(BASE_VIRTUAL_PRICE_PRECISION).div(supply);
}
return 0;
}
/**
* @notice Externally calculates a swap between two tokens. The SwapUtils.Swap storage and
* MetaSwap storage should be from the same MetaSwap contract.
* @param self Swap struct to read from
* @param metaSwapStorage MetaSwap struct from the same contract
* @param tokenIndexFrom the token to sell
* @param tokenIndexTo the token to buy
* @param dx the number of tokens to sell. If the token charges a fee on transfers,
* use the amount that gets transferred after the fee.
* @return dy the number of tokens the user will get
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-7
元数据:{'block索引': 7, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateSwap(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx
) external view returns (uint256 dy) {
(dy, ) = _calculateSwap(
self,
tokenIndexFrom,
tokenIndexTo,
dx,
_getBaseVirtualPrice(metaSwapStorage)
);
}
/**
* @notice Internally calculates a swap between two tokens.
*
* @dev The caller is expected to transfer the actual amounts (dx and dy)
* using the token contracts.
*
* @param self Swap struct to read from
* @param tokenIndexFrom the token to sell
* @param tokenIndexTo the token to buy
* @param dx the number of tokens to sell. If the token charges a fee on transfers,
* use the amount that gets transferred after the fee.
* @param baseVirtualPrice the virtual price of the base LP token
* @return dy the number of tokens the user will get and dyFee the associated fee
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-8
元数据:{'block索引': 8, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _calculateSwap(
SwapUtils.Swap storage self,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx,
uint256 baseVirtualPrice
) internal view returns (uint256 dy, uint256 dyFee) {
uint256[] memory xp = _xp(self, baseVirtualPrice);
require(
tokenIndexFrom < xp.length && tokenIndexTo < xp.length,
"Token index out of range"
);
uint256 x =
dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(
xp[tokenIndexFrom]
);
uint256 y =
SwapUtils.getY(
self._getAPrecise(),
tokenIndexFrom,
tokenIndexTo,
x,
xp
);
dy = xp[tokenIndexTo].sub(y).sub(1);
dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);
dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);
}
/**
* @notice Calculates the expected return amount from swapping between
* the pooled tokens and the underlying tokens of the base Swap pool.
*
* @param self Swap struct to read from
* @param metaSwapStorage MetaSwap struct from the same contract
* @param tokenIndexFrom the token to sell
* @param tokenIndexTo the token to buy
* @param dx the number of tokens to sell. If the token charges a fee on transfers,
* use the amount that gets transferred after the fee.
* @return dy the number of tokens the user will get
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-9
元数据:{'block索引': 9, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateSwapUnderlying(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx
) external view returns (uint256) {
CalculateSwapUnderlyingInfo memory v =
CalculateSwapUnderlyingInfo(
_getBaseVirtualPrice(metaSwapStorage),
metaSwapStorage.baseSwap,
0,
uint8(metaSwapStorage.baseTokens.length),
0,
0,
0
);
uint256[] memory xp = _xp(self, v.baseVirtualPrice);
v.baseLPTokenIndex = uint8(xp.length.sub(1));
{
uint8 maxRange = v.baseLPTokenIndex + v.baseTokensLength;
require(
tokenIndexFrom < maxRange && tokenIndexTo < maxRange,
"Token index out of range"
);
}
if (tokenIndexFrom < v.baseLPTokenIndex) {
// tokenFrom is from this pool
v.x = xp[tokenIndexFrom].add(
dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom])
);
} else {
// tokenFrom is from the base pool
tokenIndexFrom = tokenIndexFrom - v.baseLPTokenIndex;
if (tokenIndexTo < v.baseLPTokenIndex) {
uint256[] memory baseInputs = new uint256[](v.baseTokensLength);
baseInputs[tokenIndexFrom] = dx;
v.x = v
.baseSwap
.calculateTokenAmount(baseInputs, true)
.mul(v.baseVirtualPrice)
.div(BASE_VIRTUAL_PRICE_PRECISION)
.add(xp[v.baseLPTokenIndex]);
} else {
// both from and to are from the base pool
return
v.baseSwap.calculateSwap(
tokenIndexFrom,
tokenIndexTo - v.baseLPTokenIndex,
dx
);
}
tokenIndexFrom = v.baseLPTokenIndex;
}
v.metaIndexTo = v.baseLPTokenIndex;
if (tokenIndexTo < v.baseLPTokenIndex) {
v.metaIndexTo = tokenIndexTo;
}
{
uint256 y =
SwapUtils.getY(
self._getAPrecise(),
tokenIndexFrom,
v.metaIndexTo,
v.x,
xp
);
v.dy = xp[v.metaIndexTo].sub(y).sub(1);
uint256 dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);
v.dy = v.dy.sub(dyFee);
}
if (tokenIndexTo < v.baseLPTokenIndex) {
// tokenTo is from this pool
v.dy = v.dy.div(self.tokenPrecisionMultipliers[v.metaIndexTo]);
} else {
// tokenTo is from the base pool
v.dy = v.baseSwap.calculateRemoveLiquidityOneToken(
v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(v.baseVirtualPrice),
tokenIndexTo - v.baseLPTokenIndex
);
}
return v.dy;
}
/**
* @notice A simple method to calculate prices from deposits or
* withdrawals, excluding fees but including slippage. This is
* helpful as an input into the various "min" parameters on calls
* to fight front-running
*
* @dev This shouldn't be used outside frontends for user estimates.
*
* @param self Swap struct to read from
* @param metaSwapStorage MetaSwap struct to read from
* @param amounts an array of token amounts to deposit or withdrawal,
* corresponding to pooledTokens. The amount should be in each
* pooled token's native precision. If a token charges a fee on transfers,
* use the amount that gets transferred after the fee.
* @param deposit whether this is a deposit or a withdrawal
* @return if deposit was true, total amount of lp token that will be minted and if
* deposit was false, total amount of lp token that will be burned
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-10
元数据:{'block索引': 10, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateTokenAmount(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint256[] calldata amounts,
bool deposit
) external view returns (uint256) {
uint256 a = self._getAPrecise();
uint256 d0;
uint256 d1;
{
uint256 baseVirtualPrice = _getBaseVirtualPrice(metaSwapStorage);
uint256[] memory balances1 = self.balances;
uint256[] memory tokenPrecisionMultipliers =
self.tokenPrecisionMultipliers;
uint256 numTokens = balances1.length;
d0 = SwapUtils.getD(
_xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),
a
);
for (uint256 i = 0; i < numTokens; i++) {
if (deposit) {
balances1[i] = balances1[i].add(amounts[i]);
} else {
balances1[i] = balances1[i].sub(
amounts[i],
"Cannot withdraw more than available"
);
}
}
d1 = SwapUtils.getD(
_xp(balances1, tokenPrecisionMultipliers, baseVirtualPrice),
a
);
}
uint256 totalSupply = self.lpToken.totalSupply();
if (deposit) {
return d1.sub(d0).mul(totalSupply).div(d0);
} else {
return d0.sub(d1).mul(totalSupply).div(d0);
}
}
/*** STATE MODIFYING FUNCTIONS ***/
/**
* @notice swap two tokens in the pool
* @param self Swap struct to read from and write to
* @param metaSwapStorage MetaSwap struct to read from and write to
* @param tokenIndexFrom the token the user wants to sell
* @param tokenIndexTo the token the user wants to buy
* @param dx the amount of tokens the user wants to sell
* @param minDy the min amount the user would like to receive, or revert.
* @return amount of token user received on swap
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-11
元数据:{'block索引': 11, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['TokenSwap']", '返回值': ''}
函数切片:
function swap(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx,
uint256 minDy
) external returns (uint256) {
{
uint256 pooledTokensLength = self.pooledTokens.length;
require(
tokenIndexFrom < pooledTokensLength &&
tokenIndexTo < pooledTokensLength,
"Token index is out of range"
);
}
uint256 transferredDx;
{
IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];
require(
dx <= tokenFrom.balanceOf(msg.sender),
"Cannot swap more than you own"
);
{
// Transfer tokens first to see if a fee was charged on transfer
uint256 beforeBalance = tokenFrom.balanceOf(address(this));
tokenFrom.safeTransferFrom(msg.sender, address(this), dx);
// Use the actual transferred amount for AMM math
transferredDx = tokenFrom.balanceOf(address(this)).sub(
beforeBalance
);
}
}
(uint256 dy, uint256 dyFee) =
_calculateSwap(
self,
tokenIndexFrom,
tokenIndexTo,
transferredDx,
_updateBaseVirtualPrice(metaSwapStorage)
);
require(dy >= minDy, "Swap didn't result in min tokens");
uint256 dyAdminFee =
dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(
self.tokenPrecisionMultipliers[tokenIndexTo]
);
self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(
transferredDx
);
self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(
dyAdminFee
);
self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);
emit TokenSwap(
msg.sender,
transferredDx,
dy,
tokenIndexFrom,
tokenIndexTo
);
return dy;
}
/**
* @notice Swaps with the underlying tokens of the base Swap pool. For this function,
* the token indices are flattened out so that underlying tokens are represented
* in the indices.
* @dev Since this calls multiple external functions during the execution,
* it is recommended to protect any function that depends on this with reentrancy guards.
* @param self Swap struct to read from and write to
* @param metaSwapStorage MetaSwap struct to read from and write to
* @param tokenIndexFrom the token the user wants to sell
* @param tokenIndexTo the token the user wants to buy
* @param dx the amount of tokens the user wants to sell
* @param minDy the min amount the user would like to receive, or revert.
* @return amount of token user received on swap
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-12
元数据:{'block索引': 12, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['TokenSwapUnderlying']", '返回值': ''}
函数切片:
function swapUnderlying(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx,
uint256 minDy
) external returns (uint256) {
SwapUnderlyingInfo memory v =
SwapUnderlyingInfo(
0,
0,
0,
self.tokenPrecisionMultipliers,
self.balances,
metaSwapStorage.baseTokens,
IERC20(address(0)),
0,
IERC20(address(0)),
0,
_updateBaseVirtualPrice(metaSwapStorage)
);
uint8 baseLPTokenIndex = uint8(v.oldBalances.length.sub(1));
{
uint8 maxRange = uint8(baseLPTokenIndex + v.baseTokens.length);
require(
tokenIndexFrom < maxRange && tokenIndexTo < maxRange,
"Token index out of range"
);
}
ISwap baseSwap = metaSwapStorage.baseSwap;
// Find the address of the token swapping from and the index in MetaSwap's token list
if (tokenIndexFrom < baseLPTokenIndex) {
v.tokenFrom = self.pooledTokens[tokenIndexFrom];
v.metaIndexFrom = tokenIndexFrom;
} else {
v.tokenFrom = v.baseTokens[tokenIndexFrom - baseLPTokenIndex];
v.metaIndexFrom = baseLPTokenIndex;
}
// Find the address of the token swapping to and the index in MetaSwap's token list
if (tokenIndexTo < baseLPTokenIndex) {
v.tokenTo = self.pooledTokens[tokenIndexTo];
v.metaIndexTo = tokenIndexTo;
} else {
v.tokenTo = v.baseTokens[tokenIndexTo - baseLPTokenIndex];
v.metaIndexTo = baseLPTokenIndex;
}
// Check for possible fee on transfer
v.dx = v.tokenFrom.balanceOf(address(this));
v.tokenFrom.safeTransferFrom(msg.sender, address(this), dx);
v.dx = v.tokenFrom.balanceOf(address(this)).sub(v.dx); // update dx in case of fee on transfer
if (
tokenIndexFrom < baseLPTokenIndex || tokenIndexTo < baseLPTokenIndex
) {
// Either one of the tokens belongs to the MetaSwap tokens list
uint256[] memory xp =
_xp(
v.oldBalances,
v.tokenPrecisionMultipliers,
v.baseVirtualPrice
);
if (tokenIndexFrom < baseLPTokenIndex) {
// Swapping from a MetaSwap token
v.x = xp[tokenIndexFrom].add(
dx.mul(v.tokenPrecisionMultipliers[tokenIndexFrom])
);
} else {
// Swapping from a base Swap token
// This case requires adding the underlying token to the base Swap, then
// using the base LP token to swap to the desired token
uint256[] memory baseAmounts =
new uint256[](v.baseTokens.length);
baseAmounts[tokenIndexFrom - baseLPTokenIndex] = v.dx;
// Add liquidity to the underlying Swap contract and receive base LP token
v.dx = baseSwap.addLiquidity(baseAmounts, 0, block.timestamp);
// Calculate the value of total amount of baseLPToken we end up with
v.x = v
.dx
.mul(v.baseVirtualPrice)
.div(BASE_VIRTUAL_PRICE_PRECISION)
.add(xp[baseLPTokenIndex]);
}
// Calculate how much to withdraw in MetaSwap level and the the associated swap fee
uint256 dyFee;
{
uint256 y =
SwapUtils.getY(
self._getAPrecise(),
v.metaIndexFrom,
v.metaIndexTo,
v.x,
xp
);
v.dy = xp[v.metaIndexTo].sub(y).sub(1);
dyFee = v.dy.mul(self.swapFee).div(FEE_DENOMINATOR);
v.dy = v.dy.sub(dyFee).div(
v.tokenPrecisionMultipliers[v.metaIndexTo]
);
}
if (tokenIndexTo >= baseLPTokenIndex) {
// When swapping to a base Swap token, scale down dy by its virtual price
v.dy = v.dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(
v.baseVirtualPrice
);
}
// Update the balances array according to the calculated input and output amount
{
uint256 dyAdminFee =
dyFee.mul(self.adminFee).div(FEE_DENOMINATOR);
dyAdminFee = dyAdminFee.div(
v.tokenPrecisionMultipliers[v.metaIndexTo]
);
self.balances[v.metaIndexFrom] = v.oldBalances[v.metaIndexFrom]
.add(v.dx);
self.balances[v.metaIndexTo] = v.oldBalances[v.metaIndexTo]
.sub(v.dy)
.sub(dyAdminFee);
}
if (tokenIndexTo >= baseLPTokenIndex) {
// When swapping to a token that belongs to the base Swap, burn the LP token
// and withdraw the desired token from the base pool
uint256 oldBalance = v.tokenTo.balanceOf(address(this));
baseSwap.removeLiquidityOneToken(
v.dy,
tokenIndexTo - baseLPTokenIndex,
0,
block.timestamp
);
v.dy = v.tokenTo.balanceOf(address(this)) - oldBalance;
}
// Check the amount of token to send meets minDy
require(v.dy >= minDy, "Swap didn't result in min tokens");
} else {
// Both tokens are from the base Swap pool
// Do a swap through the base Swap
v.dy = v.tokenTo.balanceOf(address(this));
baseSwap.swap(
tokenIndexFrom - baseLPTokenIndex,
tokenIndexTo - baseLPTokenIndex,
v.dx,
minDy,
block.timestamp
);
v.dy = v.tokenTo.balanceOf(address(this)).sub(v.dy);
}
// Send the desired token to the caller
v.tokenTo.safeTransfer(msg.sender, v.dy);
emit TokenSwapUnderlying(
msg.sender,
dx,
v.dy,
tokenIndexFrom,
tokenIndexTo
);
return v.dy;
}
/**
* @notice Add liquidity to the pool
* @param self Swap struct to read from and write to
* @param metaSwapStorage MetaSwap struct to read from and write to
* @param amounts the amounts of each token to add, in their native precision
* @param minToMint the minimum LP tokens adding this amount of liquidity
* should mint, otherwise revert. Handy for front-running mitigation
* allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.
* @return amount of LP token user received
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-13
元数据:{'block索引': 13, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['AddLiquidity']", '返回值': ''}
函数切片:
function addLiquidity(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint256[] memory amounts,
uint256 minToMint
) external returns (uint256) {
IERC20[] memory pooledTokens = self.pooledTokens;
require(
amounts.length == pooledTokens.length,
"Amounts must match pooled tokens"
);
uint256[] memory fees = new uint256[](pooledTokens.length);
// current state
ManageLiquidityInfo memory v =
ManageLiquidityInfo(
0,
0,
0,
self.lpToken,
0,
self._getAPrecise(),
_updateBaseVirtualPrice(metaSwapStorage),
self.tokenPrecisionMultipliers,
self.balances
);
v.totalSupply = v.lpToken.totalSupply();
if (v.totalSupply != 0) {
v.d0 = SwapUtils.getD(
_xp(
v.newBalances,
v.tokenPrecisionMultipliers,
v.baseVirtualPrice
),
v.preciseA
);
}
for (uint256 i = 0; i < pooledTokens.length; i++) {
require(
v.totalSupply != 0 || amounts[i] > 0,
"Must supply all tokens in pool"
);
// Transfer tokens first to see if a fee was charged on transfer
if (amounts[i] != 0) {
uint256 beforeBalance =
pooledTokens[i].balanceOf(address(this));
pooledTokens[i].safeTransferFrom(
msg.sender,
address(this),
amounts[i]
);
// Update the amounts[] with actual transfer amount
amounts[i] = pooledTokens[i].balanceOf(address(this)).sub(
beforeBalance
);
}
v.newBalances[i] = v.newBalances[i].add(amounts[i]);
}
// invariant after change
v.d1 = SwapUtils.getD(
_xp(v.newBalances, v.tokenPrecisionMultipliers, v.baseVirtualPrice),
v.preciseA
);
require(v.d1 > v.d0, "D should increase");
// updated to reflect fees and calculate the user's LP tokens
v.d2 = v.d1;
uint256 toMint;
if (v.totalSupply != 0) {
uint256 feePerToken =
SwapUtils._feePerToken(self.swapFee, pooledTokens.length);
for (uint256 i = 0; i < pooledTokens.length; i++) {
uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);
fees[i] = feePerToken
.mul(idealBalance.difference(v.newBalances[i]))
.div(FEE_DENOMINATOR);
self.balances[i] = v.newBalances[i].sub(
fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)
);
v.newBalances[i] = v.newBalances[i].sub(fees[i]);
}
v.d2 = SwapUtils.getD(
_xp(
v.newBalances,
v.tokenPrecisionMultipliers,
v.baseVirtualPrice
),
v.preciseA
);
toMint = v.d2.sub(v.d0).mul(v.totalSupply).div(v.d0);
} else {
// the initial depositor doesn't pay fees
self.balances = v.newBalances;
toMint = v.d1;
}
require(toMint >= minToMint, "Couldn't mint min requested");
// mint the user's LP tokens
self.lpToken.mint(msg.sender, toMint);
emit AddLiquidity(
msg.sender,
amounts,
fees,
v.d1,
v.totalSupply.add(toMint)
);
return toMint;
}
/**
* @notice Remove liquidity from the pool all in one token.
* @param self Swap struct to read from and write to
* @param metaSwapStorage MetaSwap struct to read from and write to
* @param tokenAmount the amount of the lp tokens to burn
* @param tokenIndex the index of the token you want to receive
* @param minAmount the minimum amount to withdraw, otherwise revert
* @return amount chosen token that user received
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-14
元数据:{'block索引': 14, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidityOne']", '返回值': ''}
函数切片:
function removeLiquidityOneToken(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint256 tokenAmount,
uint8 tokenIndex,
uint256 minAmount
) external returns (uint256) {
LPToken lpToken = self.lpToken;
uint256 totalSupply = lpToken.totalSupply();
uint256 numTokens = self.pooledTokens.length;
require(tokenAmount <= lpToken.balanceOf(msg.sender), ">LP.balanceOf");
require(tokenIndex < numTokens, "Token not found");
uint256 dyFee;
uint256 dy;
(dy, dyFee) = _calculateWithdrawOneToken(
self,
tokenAmount,
tokenIndex,
_updateBaseVirtualPrice(metaSwapStorage),
totalSupply
);
require(dy >= minAmount, "dy < minAmount");
// Update balances array
self.balances[tokenIndex] = self.balances[tokenIndex].sub(
dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR))
);
// Burn the associated LP token from the caller and send the desired token
lpToken.burnFrom(msg.sender, tokenAmount);
self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);
emit RemoveLiquidityOne(
msg.sender,
tokenAmount,
totalSupply,
tokenIndex,
dy
);
return dy;
}
/**
* @notice Remove liquidity from the pool, weighted differently than the
* pool's current balances.
*
* @param self Swap struct to read from and write to
* @param metaSwapStorage MetaSwap struct to read from and write to
* @param amounts how much of each token to withdraw
* @param maxBurnAmount the max LP token provider is willing to pay to
* remove liquidity. Useful as a front-running mitigation.
* @return actual amount of LP tokens burned in the withdrawal
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-15
元数据:{'block索引': 15, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidityImbalance']", '返回值': ''}
函数切片:
function removeLiquidityImbalance(
SwapUtils.Swap storage self,
MetaSwap storage metaSwapStorage,
uint256[] memory amounts,
uint256 maxBurnAmount
) public returns (uint256) {
// Using this struct to avoid stack too deep error
ManageLiquidityInfo memory v =
ManageLiquidityInfo(
0,
0,
0,
self.lpToken,
0,
self._getAPrecise(),
_updateBaseVirtualPrice(metaSwapStorage),
self.tokenPrecisionMultipliers,
self.balances
);
v.totalSupply = v.lpToken.totalSupply();
require(
amounts.length == v.newBalances.length,
"Amounts should match pool tokens"
);
require(maxBurnAmount != 0, "Must burn more than 0");
uint256 feePerToken =
SwapUtils._feePerToken(self.swapFee, v.newBalances.length);
// Calculate how much LPToken should be burned
uint256[] memory fees = new uint256[](v.newBalances.length);
{
uint256[] memory balances1 = new uint256[](v.newBalances.length);
v.d0 = SwapUtils.getD(
_xp(
v.newBalances,
v.tokenPrecisionMultipliers,
v.baseVirtualPrice
),
v.preciseA
);
for (uint256 i = 0; i < v.newBalances.length; i++) {
balances1[i] = v.newBalances[i].sub(
amounts[i],
"Cannot withdraw more than available"
);
}
v.d1 = SwapUtils.getD(
_xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),
v.preciseA
);
for (uint256 i = 0; i < v.newBalances.length; i++) {
uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);
uint256 difference = idealBalance.difference(balances1[i]);
fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);
self.balances[i] = balances1[i].sub(
fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)
);
balances1[i] = balances1[i].sub(fees[i]);
}
v.d2 = SwapUtils.getD(
_xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),
v.preciseA
);
}
uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);
require(tokenAmount != 0, "Burnt amount cannot be zero");
// Scale up by withdraw fee
tokenAmount = tokenAmount.add(1);
// Check for max burn amount
require(tokenAmount <= maxBurnAmount, "tokenAmount > maxBurnAmount");
// Burn the calculated amount of LPToken from the caller and send the desired tokens
v.lpToken.burnFrom(msg.sender, tokenAmount);
for (uint256 i = 0; i < v.newBalances.length; i++) {
self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);
}
emit RemoveLiquidityImbalance(
msg.sender,
amounts,
fees,
v.d1,
v.totalSupply.sub(tokenAmount)
);
return tokenAmount;
}
/**
* @notice Determines if the stored value of base Swap's virtual price is expired.
* If the last update was past the BASE_CACHE_EXPIRE_TIME, then update the stored value.
*
* @param metaSwapStorage MetaSwap struct to read from and write to
* @return base Swap's virtual price
*/
------------------------------------------------
函数切片ID: Saddle Finance.sol-MetaSwapUtils.sol-_updateBaseVirtualPrice-16
元数据:{'block索引': 16, '函数名': '_updateBaseVirtualPrice', '函数所属的合约或接口': 'Saddle Finance.sol-MetaSwapUtils.sol', '参数': 'MetaSwap storage metaSwapStorage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _updateBaseVirtualPrice(MetaSwap storage metaSwapStorage)
internal
returns (uint256)
{
if (
block.timestamp >
metaSwapStorage.baseCacheLastUpdated + BASE_CACHE_EXPIRE_TIME
) {
// When the cache is expired, update it
uint256 baseVirtualPrice =
ISwap(metaSwapStorage.baseSwap).getVirtualPrice();
metaSwapStorage.baseVirtualPrice = baseVirtualPrice;
metaSwapStorage.baseCacheLastUpdated = block.timestamp;
return baseVirtualPrice;
} else {
return metaSwapStorage.baseVirtualPrice;
}
}
}
------------------------------------------------
函数切片ID: Li.Fi.sol-LibSwap.sol-swap-0
元数据:{'block索引': 0, '函数名': 'swap', '函数所属的合约或接口': 'Li.Fi.sol-LibSwap.sol', '参数': 'bytes32 transactionId, SwapData calldata _swapData', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['AssetSwapped']", '返回值': ''}
函数切片:
function swap(bytes32 transactionId, SwapData calldata _swapData) internal {
uint256 fromAmount = _swapData.fromAmount;
uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);
address fromAssetId = _swapData.sendingAssetId;
if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {
LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);
}
if (!LibAsset.isNativeAsset(fromAssetId)) {
LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);
}
// solhint-disable-next-line avoid-low-level-calls
(bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);
if (!success) {
string memory reason = LibUtil.getRevertMsg(res);
revert(reason);
}
toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;
emit AssetSwapped(
transactionId,
_swapData.callTo,
_swapData.sendingAssetId,
_swapData.receivingAssetId,
fromAmount,
toAmount,
block.timestamp
);
}
}
------------------------------------------------
函数切片ID: Li.Fi.sol-AnyswapFacet.sol-startBridgeTokensViaAnyswap-0
元数据:{'block索引': 0, '函数名': 'startBridgeTokensViaAnyswap', '函数所属的合约或接口': 'Li.Fi.sol-AnyswapFacet.sol', '参数': 'LiFiData memory _lifiData, AnyswapData calldata _anyswapData', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LiFiTransferStarted']", '返回值': ''}
函数切片:
function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {
if (_anyswapData.token != address(0)) {
address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);
LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);
require(
LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,
"ERR_INVALID_AMOUNT"
);
} else {
require(msg.value == _anyswapData.amount, "ERR_INVALID_AMOUNT");
}
_startBridge(_anyswapData);
emit LiFiTransferStarted(
_lifiData.transactionId,
_lifiData.integrator,
_lifiData.referrer,
_lifiData.sendingAssetId,
_lifiData.receivingAssetId,
_lifiData.receiver,
_lifiData.amount,
_lifiData.destinationChainId,
block.timestamp
);
}
/**
* @notice Performs a swap before bridging via Anyswap
* @param _lifiData data used purely for tracking and analytics
* @param _swapData an array of swap related data for performing swaps before bridging
* @param _anyswapData data specific to Anyswap
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-AnyswapFacet.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-AnyswapFacet.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LiFiTransferStarted']", '返回值': ''}
函数切片:
function swapAndStartBridgeTokensViaAnyswap(
LiFiData memory _lifiData,
LibSwap.SwapData[] calldata _swapData,
AnyswapData memory _anyswapData
) public payable {
if (_anyswapData.token != address(0)) {
address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();
uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);
// Swap
for (uint8 i; i < _swapData.length; i++) {
LibSwap.swap(_lifiData.transactionId, _swapData[i]);
}
uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;
require(_postSwapBalance > 0, "ERR_INVALID_AMOUNT");
_anyswapData.amount = _postSwapBalance;
} else {
uint256 _fromBalance = address(this).balance;
// Swap
for (uint8 i; i < _swapData.length; i++) {
LibSwap.swap(_lifiData.transactionId, _swapData[i]);
}
require(address(this).balance - _fromBalance >= _anyswapData.amount, "ERR_INVALID_AMOUNT");
uint256 _postSwapBalance = address(this).balance - _fromBalance;
require(_postSwapBalance > 0, "ERR_INVALID_AMOUNT");
_anyswapData.amount = _postSwapBalance;
}
_startBridge(_anyswapData);
emit LiFiTransferStarted(
_lifiData.transactionId,
_lifiData.integrator,
_lifiData.referrer,
_lifiData.sendingAssetId,
_lifiData.receivingAssetId,
_lifiData.receiver,
_lifiData.amount,
_lifiData.destinationChainId,
block.timestamp
);
}
/* ========== Internal Functions ========== */
/**
* @dev Conatains the business logic for the bridge via Anyswap
* @param _anyswapData data specific to Anyswap
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-AnyswapFacet.sol-_startBridge-2
元数据:{'block索引': 2, '函数名': '_startBridge', '函数所属的合约或接口': 'Li.Fi.sol-AnyswapFacet.sol', '参数': 'AnyswapData memory _anyswapData', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _startBridge(AnyswapData memory _anyswapData) internal {
// Check chain id
require(block.chainid != _anyswapData.toChainId, "Cannot bridge to the same network.");
if (_anyswapData.token != address(0)) {
// Give Anyswap approval to bridge tokens
LibAsset.approveERC20(
IERC20(IAnyswapToken(_anyswapData.token).underlying()),
_anyswapData.router,
_anyswapData.amount
);
IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(
_anyswapData.token,
_anyswapData.recipient,
_anyswapData.amount,
_anyswapData.toChainId
);
} else {
IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(
_anyswapData.token,
_anyswapData.recipient,
_anyswapData.toChainId
);
}
}
}
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-isNativeAsset-0
元数据:{'block索引': 0, '函数名': 'isNativeAsset', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': 'address assetId', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isNativeAsset(address assetId) internal pure returns (bool) {
return assetId == NATIVE_ASSETID;
}
/**
* @notice Gets the balance of the inheriting contract for the given asset
* @param assetId The asset identifier to get the balance of
* @return Balance held by contracts using this library
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-getOwnBalance-1
元数据:{'block索引': 1, '函数名': 'getOwnBalance', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': 'address assetId', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getOwnBalance(address assetId) internal view returns (uint256) {
return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));
}
/**
* @notice Transfers ether from the inheriting contract to a given
*         recipient
* @param recipient Address to send ether to
* @param amount Amount to send to given recipient
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-transferNativeAsset-2
元数据:{'block索引': 2, '函数名': 'transferNativeAsset', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': 'address payable recipient, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferNativeAsset(address payable recipient, uint256 amount) internal {
// solhint-disable-next-line avoid-low-level-calls
(bool success, ) = recipient.call{ value: amount }("");
require(success, "#TNA:028");
}
/**
* @notice Gives approval for another address to spend tokens
* @param assetId Token address to transfer
* @param spender Address to give spend approval to
* @param amount Amount to approve for spending
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approveERC20(
IERC20 assetId,
address spender,
uint256 amount
) internal {
if (isNativeAsset(address(assetId))) return;
uint256 allowance = assetId.allowance(address(this), spender);
if (allowance < amount) {
if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);
SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);
}
}
/**
* @notice Transfers tokens from the inheriting contract to a given
*         recipient
* @param assetId Token address to transfer
* @param recipient Address to send ether to
* @param amount Amount to send to given recipient
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferERC20(
address assetId,
address recipient,
uint256 amount
) internal {
SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);
}
/**
* @notice Transfers tokens from a sender to a given recipient
* @param assetId Token address to transfer
* @param from Address of sender/owner
* @param to Address of recipient/spender
* @param amount Amount to transfer from owner to spender
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-5
元数据:{'block索引': 5, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFromERC20(
address assetId,
address from,
address to,
uint256 amount
) internal {
SafeERC20.safeTransferFrom(IERC20(assetId), from, to, amount);
}
/**
* @notice Increases the allowance of a token to a spender
* @param assetId Token address of asset to increase allowance of
* @param spender Account whos allowance is increased
* @param amount Amount to increase allowance by
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-6
元数据:{'block索引': 6, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function increaseERC20Allowance(
address assetId,
address spender,
uint256 amount
) internal {
require(!isNativeAsset(assetId), "#IA:034");
SafeERC20.safeIncreaseAllowance(IERC20(assetId), spender, amount);
}
/**
* @notice Decreases the allowance of a token to a spender
* @param assetId Token address of asset to decrease allowance of
* @param spender Account whos allowance is decreased
* @param amount Amount to decrease allowance by
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-7
元数据:{'block索引': 7, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decreaseERC20Allowance(
address assetId,
address spender,
uint256 amount
) internal {
require(!isNativeAsset(assetId), "#DA:034");
SafeERC20.safeDecreaseAllowance(IERC20(assetId), spender, amount);
}
/**
* @notice Wrapper function to transfer a given asset (native or erc20) to
*         some recipient. Should handle all non-compliant return value
*         tokens as well by using the SafeERC20 contract by open zeppelin.
* @param assetId Asset id for transfer (address(0) for native asset,
*                token address for erc20s)
* @param recipient Address to send asset to
* @param amount Amount to send to given recipient
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-8
元数据:{'block索引': 8, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferAsset(
address assetId,
address payable recipient,
uint256 amount
) internal {
isNativeAsset(assetId) ? transferNativeAsset(recipient, amount) : transferERC20(assetId, recipient, amount);
}
}
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-name-0
元数据:{'block索引': 0, '函数名': 'name', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function name() external pure returns (string memory);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-symbol-1
元数据:{'block索引': 1, '函数名': 'symbol', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function symbol() external pure returns (string memory);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-decimals-2
元数据:{'block索引': 2, '函数名': 'decimals', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decimals() external pure returns (uint8);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-totalSupply-3
元数据:{'block索引': 3, '函数名': 'totalSupply', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-balanceOf-4
元数据:{'block索引': 4, '函数名': 'balanceOf', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-allowance-5
元数据:{'block索引': 5, '函数名': 'allowance', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner, address spender', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allowance(address owner, address spender) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-approve-6
元数据:{'block索引': 6, '函数名': 'approve', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-transfer-7
元数据:{'block索引': 7, '函数名': 'transfer', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-transferFrom-8
元数据:{'block索引': 8, '函数名': 'transferFrom', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-DOMAIN_SEPARATOR-9
元数据:{'block索引': 9, '函数名': 'DOMAIN_SEPARATOR', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function DOMAIN_SEPARATOR() external view returns (bytes32);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-PERMIT_TYPEHASH-10
元数据:{'block索引': 10, '函数名': 'PERMIT_TYPEHASH', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function PERMIT_TYPEHASH() external pure returns (bytes32);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-nonces-11
元数据:{'block索引': 11, '函数名': 'nonces', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function nonces(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-permit-12
元数据:{'block索引': 12, '函数名': 'permit', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
event Swap(
address indexed sender,
uint amount0In,
uint amount1In,
uint amount0Out,
uint amount1Out,
address indexed to
);
event Sync(uint112 reserve0, uint112 reserve1);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-MINIMUM_LIQUIDITY-13
元数据:{'block索引': 13, '函数名': 'MINIMUM_LIQUIDITY', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function MINIMUM_LIQUIDITY() external pure returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-factory-14
元数据:{'block索引': 14, '函数名': 'factory', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function factory() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-token0-15
元数据:{'block索引': 15, '函数名': 'token0', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token0() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-token1-16
元数据:{'block索引': 16, '函数名': 'token1', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token1() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-getReserves-17
元数据:{'block索引': 17, '函数名': 'getReserves', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-price0CumulativeLast-18
元数据:{'block索引': 18, '函数名': 'price0CumulativeLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price0CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-price1CumulativeLast-19
元数据:{'block索引': 19, '函数名': 'price1CumulativeLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price1CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-kLast-20
元数据:{'block索引': 20, '函数名': 'kLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function kLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-mint-21
元数据:{'block索引': 21, '函数名': 'mint', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address to) external returns (uint liquidity);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-burn-22
元数据:{'block索引': 22, '函数名': 'burn', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn(address to) external returns (uint amount0, uint amount1);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-swap-23
元数据:{'block索引': 23, '函数名': 'swap', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'uint amount0Out, uint amount1Out, address to, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-skim-24
元数据:{'block索引': 24, '函数名': 'skim', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function skim(address to) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-sync-25
元数据:{'block索引': 25, '函数名': 'sync', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sync() external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-initialize-26
元数据:{'block索引': 26, '函数名': 'initialize', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address, address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(address, address) external;
}
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeTo-0
元数据:{'block索引': 0, '函数名': 'feeTo', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeTo() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeToSetter-1
元数据:{'block索引': 1, '函数名': 'feeToSetter', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeToSetter() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeAmount-2
元数据:{'block索引': 2, '函数名': 'feeAmount', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeAmount() external view returns (uint16);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-owner-3
元数据:{'block索引': 3, '函数名': 'owner', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function owner() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-getPair-4
元数据:{'block索引': 4, '函数名': 'getPair', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPair(address tokenA, address tokenB) external view returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-allPairs-5
元数据:{'block索引': 5, '函数名': 'allPairs', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'uint', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairs(uint) external view returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-allPairsLength-6
元数据:{'block索引': 6, '函数名': 'allPairsLength', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairsLength() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-createPair-7
元数据:{'block索引': 7, '函数名': 'createPair', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function createPair(address tokenA, address tokenB) external returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-setFeeTo-8
元数据:{'block索引': 8, '函数名': 'setFeeTo', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo(address) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-setFeeToSetter-9
元数据:{'block索引': 9, '函数名': 'setFeeToSetter', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeToSetter(address) external;
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-initialize-0
元数据:{'block索引': 0, '函数名': 'initialize', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'address bridgeAddress', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(address bridgeAddress) external initializer {
__Ownable_init();
_bridgeAddress = bridgeAddress;
}
/* ========== MODIFIERS ========== */
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-onlyBridge-1
元数据:{'block索引': 1, '函数名': 'onlyBridge', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyBridge() {
require(msg.sender == _bridgeAddress, "QBridgeHandler: caller is not the bridge contract");
_;
}
/* ========== RESTRICTED FUNCTIONS ========== */
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-setResource-2
元数据:{'block索引': 2, '函数名': 'setResource', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'bytes32 resourceID, address contractAddress', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setResource(bytes32 resourceID, address contractAddress) external override onlyBridge {
resourceIDToTokenContractAddress[resourceID] = contractAddress;
tokenContractAddressToResourceID[contractAddress] = resourceID;
contractWhitelist[contractAddress] = true;
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-setBurnable-3
元数据:{'block索引': 3, '函数名': 'setBurnable', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'address contractAddress', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setBurnable(address contractAddress) external override onlyBridge {
require(contractWhitelist[contractAddress], "QBridgeHandler: contract address is not whitelisted");
burnList[contractAddress] = true;
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-setDelegator-4
元数据:{'block索引': 4, '函数名': 'setDelegator', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'uint option, address newDelegator', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setDelegator(uint option, address newDelegator) external onlyOwner {
delegators[option] = newDelegator;
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-setWithdrawalFee-5
元数据:{'block索引': 5, '函数名': 'setWithdrawalFee', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'bytes32 resourceID, uint withdrawalFee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setWithdrawalFee(bytes32 resourceID, uint withdrawalFee) external onlyOwner {
withdrawalFees[resourceID] = withdrawalFee;
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-setMinDepositAmount-6
元数据:{'block索引': 6, '函数名': 'setMinDepositAmount', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'bytes32 resourceID, uint option, uint minAmount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setMinDepositAmount(bytes32 resourceID, uint option, uint minAmount) external onlyOwner {
minAmounts[resourceID][option] = minAmount;
}
/**
@notice A deposit is initiated by making a deposit in the Bridge contract.
@param resourceID ResourceID used to find address of token to be used for deposit.
@param depositer Address of account making the deposit in the Bridge contract.
@param data passed into the function should be constructed as follows:
option                                 uint256     bytes  0 - 32
amount                                 uint256     bytes  32 - 64
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-deposit-7
元数据:{'block索引': 7, '函数名': 'deposit', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'bytes32 resourceID, address depositer, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function deposit(bytes32 resourceID, address depositer, bytes calldata data) external override onlyBridge {
uint option;
uint amount;
(option, amount) = abi.decode(data, (uint, uint));
address tokenAddress = resourceIDToTokenContractAddress[resourceID];
require(contractWhitelist[tokenAddress], "provided tokenAddress is not whitelisted");
if (burnList[tokenAddress]) {
require(amount >= withdrawalFees[resourceID], "less than withdrawal fee");
QBridgeToken(tokenAddress).burnFrom(depositer, amount);
} else {
require(amount >= minAmounts[resourceID][option], "less than minimum amount");
tokenAddress.safeTransferFrom(depositer, address(this), amount);
}
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-depositETH-8
元数据:{'block索引': 8, '函数名': 'depositETH', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'bytes32 resourceID, address depositer, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function depositETH(bytes32 resourceID, address depositer, bytes calldata data) external payable override onlyBridge {
uint option;
uint amount;
(option, amount) = abi.decode(data, (uint, uint));
require(amount == msg.value);
address tokenAddress = resourceIDToTokenContractAddress[resourceID];
require(contractWhitelist[tokenAddress], "provided tokenAddress is not whitelisted");
require(amount >= minAmounts[resourceID][option], "less than minimum amount");
}
/**
@notice Proposal execution should be initiated by a relayer on the deposit's destination chain.
@param data passed into the function should be constructed as follows:
option                                 uint256
amount                                 uint256
destinationRecipientAddress            address
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-executeProposal-9
元数据:{'block索引': 9, '函数名': 'executeProposal', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'bytes32 resourceID, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {
uint option;
uint amount;
address recipientAddress;
(option, amount, recipientAddress) = abi.decode(data, (uint, uint, address));
address tokenAddress = resourceIDToTokenContractAddress[resourceID];
require(contractWhitelist[tokenAddress], "provided tokenAddress is not whitelisted");
if (burnList[tokenAddress]) {
address delegatorAddress = delegators[option];
if (delegatorAddress == address(0)) {
QBridgeToken(tokenAddress).mint(recipientAddress, amount);
} else {
QBridgeToken(tokenAddress).mint(delegatorAddress, amount);
IQBridgeDelegator(delegatorAddress).delegate(tokenAddress, recipientAddress, option, amount);
}
} else if (tokenAddress == ETH) {
SafeToken.safeTransferETH(recipientAddress, amount.sub(withdrawalFees[resourceID]));
} else {
tokenAddress.safeTransfer(recipientAddress, amount.sub(withdrawalFees[resourceID]));
}
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeHandler.sol-withdraw-10
元数据:{'block索引': 10, '函数名': 'withdraw', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeHandler.sol', '参数': 'address tokenAddress, address recipient, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdraw(address tokenAddress, address recipient, uint amount) external override onlyBridge {
if (tokenAddress == ETH)
SafeToken.safeTransferETH(recipient, amount);
else
tokenAddress.safeTransfer(recipient, amount);
}
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeToken.sol-onlyMinter-0
元数据:{'block索引': 0, '函数名': 'onlyMinter', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeToken.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyMinter() {
require(isMinter(msg.sender), "QBridgeToken: caller is not the minter");
_;
}
/* ========== INITIALIZER ========== */
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeToken.sol-initialize-1
元数据:{'block索引': 1, '函数名': 'initialize', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeToken.sol', '参数': 'string memory name, string memory symbol, uint8 decimals', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(string memory name, string memory symbol, uint8 decimals) external initializer {
__BEP20__init(name, symbol, decimals);
}
/* ========== RESTRICTED FUNCTIONS ========== */
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeToken.sol-setMinter-2
元数据:{'block索引': 2, '函数名': 'setMinter', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeToken.sol', '参数': 'address minter, bool canMint', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setMinter(address minter, bool canMint) external onlyOwner {
_minters[minter] = canMint;
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeToken.sol-mint-3
元数据:{'block索引': 3, '函数名': 'mint', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeToken.sol', '参数': 'address _to, uint _amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address _to, uint _amount) public onlyMinter {
_mint(_to, _amount);
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeToken.sol-burnFrom-4
元数据:{'block索引': 4, '函数名': 'burnFrom', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeToken.sol', '参数': 'address account, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burnFrom(address account, uint amount) public onlyMinter {
uint decreasedAllowance = allowance(account, msg.sender).sub(amount, "BEP20: burn amount exceeds allowance");
_approve(account, _msgSender(), decreasedAllowance);
_burn(account, amount);
}
/* ========== VIEWS ========== */
------------------------------------------------
函数切片ID: Qubit Finance.sol-QBridgeToken.sol-isMinter-5
元数据:{'block索引': 5, '函数名': 'isMinter', '函数所属的合约或接口': 'Qubit Finance.sol-QBridgeToken.sol', '参数': 'address account', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isMinter(address account) public view returns (bool) {
return _minters[account];
}
}
------------------------------------------------
排名结果：
