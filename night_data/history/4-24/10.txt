------------------------------------------------
交易故障分析：
问题/异常点：在故障交易中，攻击者通过代币销毁/铸造操作与流动性池价格操纵，以极低成本获取了异常高额WETH并兑换为SUSHI。具体表现为：  
1. 代币异常铸造与销毁：地址0x9a1386...通过transfer销毁604,731,158代币后，立即从零地址铸造53,612代币到路由合约，存在人为操控代币供应量的迹象。  
2. 流动性池价格失衡：在WBTC/WETH池（0xceff51...）中，输入345,151,756 WBTC（≈345 BTC）却输出8.8e12 WETH（≈8.8万亿ETH），兑换率严重偏离市场价（实际WBTC/WETH价格比例应为1:15左右），表明池储备计算被异常修改。  
3. 跨池套利路径异常：攻击者在同一交易内完成WBTC→WETH→SUSHI的兑换，但两个流动性池的储备同步事件（Sync）显示其储备量未按实际兑换比例更新，存在价格预言机操控风险。  

原因分析：  
1. **代币合约漏洞利用**：攻击者通过路由合约（0xe11fc0b...）调用自定义代币合约（0x9a1386...）的transfer和mint函数，利用代币供应量控制缺陷。该代币的铸造权限未严格限制，允许攻击者在销毁代币后立即铸造新代币，虚增流动性池权重。  
2. **流动性池价格操纵**：在WBTC/WETH池中，攻击者通过STATICCALL调用UniswapV2Library的getReserves函数（0x0902f1ac），但实际执行swap时，池合约未正确验证输入代币数量与储备比例。结合trace信息，攻击者在swap前通过跨合约调用修改了临时储备数据，导致价格计算公式(K值)被绕过。  
3. **跨协议套利组合**：攻击组合了SushiSwap和自定义池的流动性缺陷。首先通过虚假代币增发人为放大某一池的流动性深度，再利用SushiSwap路由合约的报价机制缺陷，将扭曲的WETH价格传导至SUSHI兑换环节，最终通过质押合约完成获利。  

---  
**Trace调用链**：  
0x51841d9... → 0xe11fc0b...（路由合约）→ [STATICCALL] 0xc0aee478（工厂合约）→ [CALL] 0x9a138670（代币销毁）→ [CALL] 0x2260fac5（WBTC转账）→ [STATICCALL] 0xceff5175（获取储备）→ [CALL] 0xceff5175（执行swap）→ [CALL] 0x795065dc（SUSHI兑换）→ 0x8798249...（质押合约）
------------------------------------------------
向量库匹配结果：
{'ids': [['SushiSwap.sol-SushiMaker.sol', 'SushiSwap.sol-SushiRoll.sol', 'Alchemix.sol-IWETH9.sol', 'SushiSwap.sol-UniswapV2ERC20.sol', 'MonoX.sol-IERC1155.sol', 'MonoX.sol-Monoswap.sol', 'Punk Protocol-2.sol-ModelInterface.sol', 'Saddle Finance.sol-ISwap.sol', 'XCarnival.sol-IERC1155Upgradeable.sol', 'Li.Fi.sol-LibAsset.sol', 'Uranium Finance-2.sol-UraniumERC20.sol', 'SushiSwap.sol-Address.sol', 'Uranium Finance-4.sol-IUraniumFactory.sol', 'Nmbplatform.sol-SafeERC20.sol', 'Qubit Finance.sol-BEP20Upgradeable.sol', 'Cover Protocol.sol-Vesting.sol', 'Uranium Finance-4.sol-IUraniumPair.sol', 'Beanstalk.sol-LibIncentive.sol', 'Cover Protocol.sol-COVER.sol', 'Rikkei Finance.sol-InterestRateModel.sol', 'MonoX.sol-IMonoXPool.sol', 'Uranium Finance-1.sol-UraniumERC20.sol', 'Uranium Finance-2.sol-IUraniumERC20.sol', 'MonoX.sol-MonoXLibrary.sol', 'Qubit Finance.sol-QBridgeToken.sol', 'Li.Fi.sol-WithdrawFacet.sol', 'Umbrella Network.sol-IStakingRewards.sol', 'Li.Fi.sol-ICBridge.sol', 'Alchemix.sol-VaultWithIndirection.sol', 'Alchemix.sol-Math.sol', 'Beanstalk.sol-Decimal.sol', 'Alchemix.sol-ITransmuter.sol', 'Saddle Finance.sol-AddressUpgradeable.sol', 'Uranium Finance-3.sol-IUraniumPair.sol', 'XCarnival.sol-IInterestRateModel.sol', 'Indexed Finance.sol-IUniswapV2Pair.sol', 'Uranium Finance-3.sol-IUraniumERC20.sol', 'SushiSwap.sol-IWETH.sol', 'Uranium Finance-2.sol-IUraniumPair.sol', 'MonoX.sol-IERC1155MetadataURI.sol']], 'distances': [[0.30929869413375854, 0.3355236053466797, 0.34257107973098755, 0.3534182906150818, 0.35522323846817017, 0.36381757259368896, 0.3638674020767212, 0.3718423843383789, 0.37222116236573133, 0.37373918294906616, 0.3745960593223572, 0.3748800754547119, 0.3762994763981715, 0.3791537880897522, 0.3797740936279297, 0.3804967403411865, 0.3827647483394363, 0.3828461170196533, 0.3853498697280884, 0.38627320528030396, 0.38652968406677246, 0.38756734132766724, 0.38839101791381836, 0.39002537727355957, 0.3920109272003174, 0.3941670060157776, 0.3943548798561096, 0.3949859142303467, 0.39686131477355957, 0.3972395658493042, 0.39803028106689453, 0.3983266353607178, 0.39958900213241577, 0.3999363271601236, 0.39996843235962576, 0.40034037828445435, 0.4037122213554013, 0.4039669632911682, 0.40592873096466064, 0.4061715602874756]], 'embeddings': None, 'metadatas': None, 'documents': [['总结：该智能合约名为SushiMaker，核心功能是通过兑换流动性池中的代币为SUSHI代币，并将收益分配给xSushi持有者。合约通过销毁Uniswap V2 LP代币获取基础代币，再经过多步兑换逻辑将代币转换为SUSHI并发送至SushiBar合约。合约采用桥接代币机制处理非直接兑换路径，仅允许外部账户（EOA）调用关键函数以防止闪电贷攻击。主要流程包括获取LP代币、销毁LP代币获得基础资产、根据代币类型选择兑换路径（包括直接处理SUSHI/WETH、桥接代币兑换等），最终通过Uniswap V2交易对完成兑换。合约包含权限管理功能，仅允许所有者设置桥接代币地址。\n\n函数列表：\n1. bridgeFor(address token)：查询指定代币的桥接代币地址，默认返回WETH。\n2. setBridge(address token, address bridge)：所有者设置代币的桥接代币地址。\n3. convert(address token0, address token1)：外部EOA调用，处理单个交易对的代币转换。\n4. convertMultiple(address[] token0, address[] token1)：外部EOA调用，批量处理多个交易对的转换。\n5. _convert(address token0, address token1)：内部函数，执行LP代币销毁和基础代币提取。\n6. _convertStep(address token0, address token1, uint256 amount0, uint256 amount1)：内部函数，处理多路径代币兑换逻辑。\n7. _swap(address fromToken, address toToken, uint256 amountIn, address to)：内部函数，执行Uniswap V2交易对的实际兑换操作。\n8. _toSUSHI(address token, uint256 amountIn)：内部函数，将任意代币兑换为SUSHI并发送至Bar合约。', '该智能合约名为SushiRoll，核心功能是帮助用户将Uniswap V2的流动性池（LP）代币迁移至SushiSwap。合约通过移除用户在Uniswap的流动性，并将代币重新注入SushiSwap的新流动性池中，完成LP代币的转换。迁移过程支持两种方式：带许可签名（permit）的授权迁移和常规授权迁移。合约关键点包括：1. 移除旧路由器的流动性时，需满足最小代币数量（amountAMin/amountBMin）和截止时间（deadline）；2. 添加流动性到新路由器时，自动计算最优代币比例，确保符合SushiSwap池的储备要求；3. 迁移后剩余代币会返还用户。合约通过UniswapV2Library进行地址排序、储备量查询等操作，并采用CREATE2方式计算旧路由器的Pair合约地址，避免外部调用。\n\n函数列表：\n1. 构造函数：初始化新旧路由器的地址（oldRouter和router）\n2. migrateWithPermit：通过许可签名授权后执行迁移，参数包含tokenA/B、流动性数量、最小代币量、截止时间及签名v/r/s\n3. migrate：核心迁移函数，处理流动性移除、添加及剩余代币返还\n4. removeLiquidity（internal）：从旧路由器移除流动性，返回实际获得的代币数量\n5. pairForOldRouter（internal view）：计算旧路由器中指定代币对的Pair合约地址\n6. addLiquidity（internal）：向新路由器添加流动性并铸造LP代币给用户\n7. _addLiquidity（internal）：计算添加流动性的最优代币量，必要时创建新Pair合约', '该智能合约代码为WETH9（Wrapped Ether）的接口定义合约，主要定义了ERC20标准代币与以太币封装交互的规范。合约作为WETH的接口层，允许用户将以太币ETH存入合约以1:1比例兑换为WETH代币，并支持逆向赎回操作。合约遵循ERC20代币标准，包含代币转移、余额查询、总量统计等基础功能，同时扩展了ETH与WETH兑换功能。该接口定义了代币名称、符号、精度等元数据查询方法，并通过事件记录存款、提现、转账等关键操作。\n\n函数列表：\n1. deposit() - 存入ETH兑换WETH（ payable函数）\n2. withdraw(uint wad) - 销毁WETH赎回指定数量的ETH\n3. totalSupply() - 查询代币总供应量（view只读）\n4. approve(address guy, uint wad) - 授权指定地址使用代币额度\n5. transfer(address dst, uint wad) - 转移代币到目标地址\n6. transferFrom(address src, address dst, uint wad) - 从授权地址转移代币\n7. name() - 获取代币名称（view只读）\n8. symbol() - 获取代币符号（view只读）\n9. decimals() - 获取代币精度位数（view只读）\n10. balanceOf(address guy) - 查询指定地址余额（view只读）', '该智能合约是 SushiSwap 的流动性池代币（LP Token）实现，基于 ERC20 标准并扩展了离线授权功能。合约代币名称为"SushiSwap LP Token"(SLP)，提供基础代币转账、授权功能，同时通过 EIP-712 标准实现了 Permit 离线签名授权机制，允许用户通过数字签名完成代币授权操作，无需提前发送链上交易。合约包含代币铸造/销毁功能，但相关方法设为内部函数，需通过继承机制由外部合约调用，体现其作为流动性池代币的设计特性。\n\n函数列表：\n1. 构造函数：初始化代币基础信息并创建 EIP-712 域分隔符\n2. _mint（内部）：向指定地址增发代币并更新总供应量\n3. _burn（内部）：销毁指定地址的代币并减少总供应量\n4. _approve（私有）：处理代币授权逻辑并触发 Approval 事件\n5. _transfer（私有）：执行代币转账逻辑并触发 Transfer 事件\n6. approve（外部）：公开的授权接口，允许第三方操作指定数量的代币\n7. transfer（外部）：标准代币转账功能\n8. transferFrom（外部）：允许被授权方转移代币，支持无限授权优化\n9. permit（外部）：通过验证 EIP-712 签名实现离线授权，规避单独授权交易', '该智能合约被命名为 IERC1155（ERC1155 标准接口），是基于 EIP-1155 标准定义的多代币管理接口合约，继承自 IERC165 接口。其主要功能为实现非同质化代币（NFT）和同质化代币（FT）的统一管理标准，支持批量转账、余额查询及操作员授权机制。合约通过事件记录代币转账、授权状态变更及元数据 URI 更新，要求实现代币接收方的安全验证回调。核心特性包括允许单次/批量转账、批量余额查询、操作员全局授权控制，并强制要求接收合约实现安全转账回调逻辑。\n\n函数列表如下：\n1. balanceOf：查询指定地址中特定代币 ID 的余额数量\n2. balanceOfBatch：批量查询多个地址对应多个代币 ID 的余额（原子性操作，全部成功或回滚）\n3. setApprovalForAll：授权或撤销某操作员对调用者所有代币的管理权限\n4. isApprovedForAll：检查指定操作员是否被授权管理某账户的全部代币\n5. safeTransferFrom：安全转账单个代币类型，需验证接收方合约的回调\n6. safeBatchTransferFrom：批量安全转账多个代币类型，需验证接收方合约的批量回调', 'Monoswap 智能合约总结：该合约是基于 ERC1155 标准实现的去中心化交易所核心合约，采用单边流动性模型并支持多种代币交易。核心功能包括流动性池管理、代币兑换、动态价格调整和手续费机制。合约通过 vCash 虚拟代币实现流动性管理，支持 ETH/WETH 交易对，并包含官方池、合成池等多种池状态管理。关键特性包含：1. 支持创建/移除流动性池 2. 实现基于价格滑点的自动做市算法 3. 可调节的交易手续费和开发者费用 4. 池状态锁定机制防止重入攻击 5. 提供多种兑换路径处理 ETH 与代币交易。\n\n函数列表：\n- initialize：初始化合约基础配置\n- setFeeTo：设置手续费接收地址\n- setFees：设置交易手续费率\n- setDevFee：设置开发者费用率\n- setPoolSizeMinLimit：设置最小池规模限制\n- setTokenInsurance：设置代币保险金额\n- setTokenStatus：设置代币锁定状态\n- updatePoolStatus：更新池状态（仅管理员）\n- updatePoolPrice：更新池价格（需冷却期）\n- updatePriceAdjuster：设置价格调节权限\n- setSynthPoolPrice：设置合成池价格\n- rebalancePool：执行池再平衡\n- addSpecialToken：创建特殊状态池\n- listNewToken：创建新代币池\n- addLiquidityPair：添加双向流动性\n- addLiquidity：添加单边流动性\n- addLiquidityETH：添加 ETH 流动性\n- removeLiquidity：移除流动性\n- removeLiquidityETH：移除 ETH 流动性\n- swapExactETHForToken：ETH 兑换代币\n- swapExactTokenForETH：代币兑换 ETH\n- swapETHForExactToken：指定数量 ETH 兑换\n- swapTokenForExactETH：指定数量代币兑换\n- swapExactTokenForToken：代币间兑换\n- swapTokenForExactToken：指定数量代币兑换\n- getPool：获取池信息\n- getAmountIn：计算输入金额\n- getAmountOut：计算输出金额\n- getConfig：获取系统配置参数', 'ModelInterface 智能合约总结：该合约是一个资金管理模型接口，定义了标准化资金投资与提现机制。核心功能包括查询资金余额、执行投资策略、控制资金流向三大部分。合约通过事件机制记录资金操作日志，要求提现操作必须通过 Forge 合约权限验证，确保资金操作安全性。主要特点体现在：1. 提供实时资金状态查询（已投资/总余额）；2. 强制投资策略执行入口；3. 分级提现控制（全额/指定金额/指定地址）；4. 权限隔离机制（OnlyForge 修饰符）。该接口为具体资金管理模型的实现提供了标准化规范，适用于需要资金托管与策略投资的 DeFi 应用场景。\n\n函数列表：\n1. underlyingBalanceInModel()：查询模型内未投资资金余额\n2. underlyingBalanceWithInvestment()：查询总投资余额（含已投资部分）\n3. invest()：执行投资策略，将未投资资金转入投资\n4. withdrawAllToForge()：全额提现至 Forge 合约\n5. withdrawToForge(uint256)：指定金额提现至 Forge 合约\n6. withdrawTo(uint256, address)：指定金额提现至目标地址', '该智能合约可命名为"Swap流动性池管理合约"，主要实现多代币流动性池的创建、代币兑换及流动性管理功能。合约基于自动化做市商(AMC)机制，包含代币兑换、流动性添加/移除、资金池参数管理等核心功能，支持多代币池配置与白名单机制。关键功能包含：1）通过恒定乘积算法实现代币兑换 2）支持灵活添加/移除流动性的多种模式 3）内置手续费机制（常规费率和管理员费率）4）LP代币的铸造与销毁管理 5）提供多种资金池数据查询接口。\n\n函数列表：\ngetA：获取资金池放大系数\ngetAllowlist：读取白名单合约地址\ngetToken：根据索引获取对应代币\ngetTokenIndex：通过代币地址查询索引号\ngetTokenBalance：查询指定代币的池内余额\ngetVirtualPrice：获取LP代币的虚拟价格\nisGuarded：检查防护状态\ncalculateSwap：计算兑换预期获得量\ncalculateTokenAmount：计算添加流动性对应LP数量\ncalculateRemoveLiquidity：计算全额移除流动性所得代币\ncalculateRemoveLiquidityOneToken：计算单币种移除流动性可得数量\ninitialize：初始化资金池参数\nswap：执行代币兑换交易\naddLiquidity：添加流动性并铸造LP代币\nremoveLiquidity：移除流动性并销毁LP代币\nremoveLiquidityOneToken：单币种移除流动性\nremoveLiquidityImbalance：非对称移除流动性。', '智能合约名称：IERC1155Upgradeable（ERC1155标准接口）。该合约是OpenZeppelin库中定义的ERC1155多代币标准接口，作为遵循EIP-1155规范的合约必须实现的函数集合。核心功能包括管理多种代币类型（含同质化与非同质化代币）、批量操作支持以及代币转移授权机制。合约定义了4个关键事件：TransferSingle（单代币转移）、TransferBatch（批量代币转移）、ApprovalForAll（操作员授权状态变更）和URI（代币元数据地址更新）。其核心特性体现在支持批量查询余额、批量转账功能，并通过安全转账机制验证接收方合约的代币处理能力。\n\n函数列表：\n1. balanceOf：查询指定地址的特定代币余额\n2. balanceOfBatch：批量查询多个地址对应多个代币ID的余额\n3. setApprovalForAll：设置操作员对调用者全部代币的管理权限\n4. isApprovedForAll：查询指定操作员对某账户的代币管理权限状态\n5. safeTransferFrom：执行安全单代币转账（需验证接收方合约）\n6. safeBatchTransferFrom：执行安全批量代币转账（需验证接收方合约）', 'LibAsset 库合约总结：该智能合约是一个用于处理链上资产转账的工具库，主要功能为统一管理原生代币与 ERC20 标准代币的资产操作。合约通过 NATIVE_ASSETID 常量定义原生资产标识符（地址 0），实现了对两种类型资产的兼容处理。核心功能包含资产类型判断、余额查询、安全转账及代币授权四大模块，通过 OpenZeppelin 的 SafeERC20 库处理非常规 ERC20 代币的兼容性问题。合约特色在于采用 MAX_INT 最大授权量模式规避部分代币的授权漏洞，并通过 transferAsset 方法实现资产类型自动判断的统一转账接口，提升了多类型资产操作的安全性。\n\n函数列表：\nisNativeAsset：判断指定资产地址是否为原生代币\ngetOwnBalance：查询当前合约持有的指定资产余额\ntransferNativeAsset：执行原生代币转账至指定地址\napproveERC20：设置 ERC20 代币的第三方操作授权\ntransferERC20：向指定地址转出 ERC20 代币\ntransferFromERC20：从指定地址向目标地址转出 ERC20 代币\nincreaseERC20Allowance：增加 ERC20 代币的授权额度\ndecreaseERC20Allowance：减少 ERC20 代币的授权额度\ntransferAsset：资产类型自适应的统一转账方法', '智能合约名称：UraniumERC20。该合约是基于ERC20标准的流动性池代币合约，主要用于管理代币的基本功能并支持离线授权操作。合约实现了代币名称、符号、小数位的定义，支持代币转账、授权、铸造与销毁功能，并引入EIP-712标准实现免gas费授权签名验证。关键特性包括：1) 使用SafeMath库确保数学运算安全 2) 内置支持EIP-2612规范的permit函数实现链下签名授权 3) 通过DOMAIN_SEPARATOR构建符合EIP-712规范的域分隔符 4) 采用nonces机制防止签名重放攻击。合约包含标准ERC20功能扩展，适用于去中心化交易所流动性池凭证场景。\n\n函数列表：\n1. 构造函数：初始化合约并设置EIP-712域参数\n2. _mint(内部)：向指定地址增发代币并更新总量\n3. _burn(内部)：销毁指定地址代币并减少总量\n4. _approve(私有)：处理代币授权逻辑\n5. _transfer(私有)：执行代币转账核心逻辑\n6. approve(外部)：授权第三方使用指定数量代币\n7. transfer(外部)：执行代币转账\n8. transferFrom(外部)：从授权账户转移代币\n9. permit(外部)：通过数字签名实现离线授权操作', '该智能合约是一个名为 Address 的工具库，主要用于安全地进行地址相关操作和底层调用处理。核心功能包括检测地址类型、替代原生转账方法、执行安全的合约调用等功能。合约通过封装低级调用逻辑并提供安全检查，有效规避常见风险如转账失败、重入攻击等。关键点包括：1. 使用 extcodesize 检测合约地址（注意构造中合约返回 false 的特性）2. 用 call 替代 transfer 突破 2300 gas 限制 3. 提供带错误处理的链式调用方法 4. 实现静态调用和安全验证机制。该库函数普遍采用 require 进行前置条件检查，并通过内联汇编处理错误数据返回，增强了合约调用的安全性和可靠性。\n\n函数列表如下：\nisContract：检测地址是否为合约地址\nsendValue：向指定地址发送 ETH 代币（替代 transfer）\nfunctionCall：执行低级合约调用（带默认错误提示）\nfunctionCall：执行低级合约调用（自定义错误提示）\nfunctionCallWithValue：附带 ETH 转账的合约调用（带默认错误提示）\nfunctionCallWithValue：附带 ETH 转账的合约调用（自定义错误提示）\nfunctionStaticCall：执行静态合约调用（带默认错误提示）\nfunctionStaticCall：执行静态合约调用（自定义错误提示）\n_verifyCallResult：内部函数，验证调用结果并处理错误信息', 'UraniumFactory接口合约总结：该智能合约是一个工厂合约接口，定义了去中心化交易所中代币交易对创建及费用管理的核心功能。合约主要用于创建和管理流动性交易对，包含费用地址设置、交易对查询、动态费用参数控制等机制。通过createPair函数可创建新的代币交易对，同时维护所有已创建交易对的列表。合约包含管理员权限体系，通过feeToSetter和owner进行协议参数控制，支持动态调整手续费接收地址和权限转移功能。该接口遵循类似Uniswap V2的工厂合约模式，但增加了feeAmount费用比例参数，表明可能采用动态手续费机制。\n\n函数列表：\n1. feeTo()：查询手续费接收地址\n2. feeToSetter()：查询手续费设置权限地址\n3. feeAmount()：查询当前交易手续费比例\n4. owner()：查询合约所有者地址\n5. getPair()：根据代币地址查询已存在的交易对\n6. allPairs()：通过索引获取已创建交易对地址\n7. allPairsLength()：获取已创建交易对总数\n8. createPair()：创建新的代币交易对\n9. setFeeTo()：设置新的手续费接收地址\n10. setFeeToSetter()：转移手续费设置权限', 'SafeERC20 库总结：该智能合约是 OpenZeppelin 提供的 SafeERC20 安全操作库，主要用于增强 ERC20 代币操作的安全性。其核心功能是通过封装标准的 ERC20 操作（如转账、授权等），统一处理可能出现的调用失败情况，并对兼容 EIP-2612 的 ERC20Permit 代币提供许可签名验证功能。关键特性包括：1. 对所有 ERC20 操作添加返回值验证，防止忽略返回 false 的失败情况；2. 提供安全的授权额度调整方法，避免常见的前后授权竞争问题；3. 集成 permit 签名验证功能，支持免转账手续费授权操作；4. 通过低级调用实现兼容性处理，支持无返回值类型的代币合约。该库通过引入安全封装方法（如 safeTransfer、safeIncreaseAllowance 等），显著降低开发者直接调用 ERC20 接口时的潜在风险。\n\n函数列表：  \n- safeTransfer(IERC20,address,uint256)：安全转账函数，验证 ERC20 转账操作结果  \n- safeTransferFrom(IERC20,address,address,uint256)：安全跨账户转账，验证 transferFrom 结果  \n- safeApprove(IERC20,address,uint256)：授权操作（已弃用），强制要求从零地址开始授权  \n- safeIncreaseAllowance(IERC20,address,uint256)：安全增加授权额度，采用增量方式避免竞争条件  \n- safeDecreaseAllowance(IERC20,address,uint256)：安全减少授权额度，防止额度减至负数  \n- safePermit(IERC20Permit,address,address,uint256,uint256,uint8,bytes32,bytes32)：执行 EIP-2612 许可签名验证，包含 nonce 校验  \n- _callOptionalReturn(IERC20,bytes)：内部基础方法，执行低级调用并验证返回数据', '智能合约命名：BEP20Upgradeable。该合约是基于 PancakeSwap 的 BEP20 标准和 OpenZeppelin 可升级合约框架实现的代币基础合约，支持代币升级功能。合约核心功能包括代币转账、余额查询、授权管理、供应量铸造/销毁等标准 BEP20 操作，同时通过 OwnableUpgradeable 实现所有权控制。关键特性包含可初始化参数设置（名称/符号/小数位）、安全数学运算防止溢出、支持代币燃烧功能，并通过预留 50 位存储间隙实现可扩展性。合约通过抽象化设计为后续具体代币合约提供基础模板，采用代理模式兼容合约升级需求。\n\n函数列表：\n1. __BEP20__init：初始化代币基础参数（名称/符号/小数位）\n2. getOwner：获取合约所有者地址\n3. decimals：查询代币小数位数\n4. symbol：查询代币符号\n5. name：查询代币名称\n6. totalSupply：获取代币总供应量\n7. balanceOf：查询指定地址余额\n8. transfer：执行代币转账\n9. allowance：查询授权额度\n10. approve：设置代币操作授权\n11. transferFrom：从授权账户执行转账\n12. increaseAllowance：增加授权额度\n13. decreaseAllowance：减少授权额度\n14. burn：销毁指定数量代币', 'Vesting 智能合约总结：该合约是用于管理团队代币线性解锁的归属机制合约，采用两阶段释放模式控制代币解锁进度。核心功能通过三个时间节点（2020/11/20、2021/5/20、2021/11/20）划分归属周期：第一阶段释放总分配量的2/3，按时间线性解锁；第二阶段释放剩余的1/3；全部代币在2021年11月20日完全解锁。合约初始化时向6个预定义地址分配特定数量的代币（以2700 ether、1620 ether等不同额度），实际部署需替换为真实团队地址。用户可通过调用vest函数提取已解锁代币，系统通过两个映射表_total和_vested分别记录用户总配额和已领取数量。\n\n函数列表：\n1. 构造函数：初始化团队地址对应的代币总配额，当前使用测试地址需替换\n2. vest：外部函数，执行代币领取操作，包含启动时间校验、身份校验、额度校验\n3. releasableAmount：视图函数，计算指定地址当前可提取的代币数量\n4. unlockedAmount：视图函数，根据当前区块时间计算指定地址已解锁的代币总量，包含两阶段线性计算逻辑', '智能合约名称：IUraniumPair（铀交易对接口）。该合约是一个定义了去中心化交易所交易对核心功能的接口，同时兼容 ERC20 标准作为流动性代币凭证。合约主要包含四个模块功能：1）ERC20 标准代币功能，用于管理流动性提供者的份额凭证；2）流动性铸造/销毁机制，通过 mint/burn 函数处理流动性增减；3）代币交换功能，支持双向代币兑换并触发 Swap 事件；4）价格预言机相关功能，通过储备量记录和累计价格实现外部价格查询。特色功能包括支持 EIP-2612 离线授权许可（permit）、储备同步机制（sync/skim）以及最小流动性锁定机制（MINIMUM_LIQUIDITY）。\n\n函数列表：\n- ERC20 标准函数：name（代币名称）、symbol（代币符号）、decimals（小数位）、totalSupply（总供应量）、balanceOf（查询余额）、allowance（查询授权额度）、approve（设置授权）、transfer（转账）、transferFrom（授权转账）\n- 许可功能：DOMAIN_SEPARATOR（EIP712 域分隔符）、PERMIT_TYPEHASH（许可类型哈希）、nonces（地址 nonce 值）、permit（离线授权）\n- 流动性管理：mint（铸造流动性代币）、burn（销毁流动性代币）\n- 交易功能：swap（执行代币兑换）\n- 储备管理：sync（同步储备余额）、skim（调整余额差异）\n- 信息查询：factory（查询工厂地址）、token0（查询代币0）、token1（查询代币1）、getReserves（获取储备量）、price0CumulativeLast（代币0累计价格）、price1CumulativeLast（代币1累计价格）、kLast（最后储备乘积）\n- 初始化函数：initialize（初始化交易对）\n- 常量参数：MINIMUM_LIQUIDITY（最小流动性值）', '该智能合约是一个用于高效计算指数激励奖励的库合约，主要功能是通过二项式展开算法避免大数运算溢出问题，实现形如k*(1+1/q)^N的指数表达式近似计算。其核心逻辑是通过预计算迭代次数p优化循环边界，并在循环中累加二项式展开项来逼近指数结果。log_two函数采用汇编代码实现高效的二进制对数计算，为迭代次数提供基础参数。该库针对Gas效率进行深度优化，适用于需要处理复利模型且数值较大的DeFi激励场景。函数列表如下：1. fracExp函数：通过二项式展开算法估算指数激励数值，接收本金k、基数q、指数n、超额迭代系数x作为参数，返回计算结果s。2. log_two函数：使用汇编实现的二进制对数计算函数，通过位操作和预置查找表快速计算log2(x)，为fracExp提供迭代次数计算支持。', 'COVER代币合约总结：该合约是Cover Protocol项目的ERC20代币实现，具有挖矿和迁移功能控制机制。核心功能包括代币初始分配、权限管理和分阶段释放机制。合约部署时向指定地址铸造1枚代币用于创建资金池，通过release函数实现代币正式释放（需达到设定时间戳），向金库地址铸造950枚、归属地址铸造10800枚代币。代币铸造权仅限通过认证的迁移合约和矿工合约调用，且设置黑smith合约和迁移合约地址的权限采用链式验证模式（仅当前合约可修改自身地址）。合约包含严格的时间锁和一次性释放保护，防止重复初始化。\n\n函数列表：\n1. 构造函数：初始化代币名称符号，铸造1枚代币到固定地址\n2. mint：在代币释放后，允许迁移合约或矿工合约铸造代币给指定账户\n3. setBlacksmith：由当前黑smith合约调用，更新黑smith合约地址\n4. setMigrator：由当前迁移合约调用，更新迁移合约地址\n5. release：由合约所有者单次调用，激活代币系统并执行初始分配，设置黑smith和迁移合约地址（需达到设定时间且未释放过）', 'InterestRateModel 智能合约总结：该合约是由 Rifi 开发的利率模型接口合约，主要用于定义去中心化金融市场中的借贷利率计算标准。合约通过两个核心函数抽象化利率计算逻辑，为具体利率模型实现提供接口规范。关键特性包括：1. 包含 isInterestRateModel 标识常量用于合约类型验证；2. 声明借款利率计算函数 getBorrowRate，接收市场现金总量、未偿借款和准备金作为输入参数；3. 声明供应利率计算函数 getSupplyRate，额外接收储备因子参数。该合约作为抽象接口，需要具体实现合约继承后完善实际利率计算逻辑，支持不同利率模型策略的灵活扩展，其返回值均采用 1e18 精度标准，确保计算精度满足 DeFi 应用需求。\n\n函数列表：\n1. getBorrowRate：计算每个区块的借款利率，参数为市场现金总额(cash)、未偿借款总额(borrows)、准备金总额(reserves)，返回经过 1e18 缩放后的借款利率百分比\n2. getSupplyRate：计算每个区块的存款利率，参数增加储备因子(reserveFactorMantissa)，返回经过 1e18 缩放后的存款利率百分比', 'MonoX 流动性池管理合约接口总结：该合约为基于 ERC1155 标准的多代币流动性池管理接口，主要功能涵盖流动性代币铸造销毁、WETH 存取、资产转移及流动性提供者管理。合约通过 ERC1155 基础功能实现多池流动性代币管理，支持 ETH 与 ERC20 代币的安全转账机制，内置 WETH 封装代币操作接口。核心特性包含流动性供应时间记录、顶级流动性持有者查询功能，并设置了白名单权限控制系统，允许通过 _isOfficial 参数区分官方流动性池，实现差异化管理策略。\n\n函数列表如下：\nmint：铸造流动性代币至指定账户\nburn：销毁账户持有的流动性代币\ntotalSupplyOf：查询指定流动性池代币总供应量\ndepositWETH：存入 WETH 代币\nwithdrawWETH：提取 WETH 代币\nsafeTransferETH：安全转账 ETH 至目标地址\nsafeTransferERC20Token：安全转账 ERC20 代币\nWETH：查询 WETH 合约地址\nliquidityLastAddedOf：查询账户最近流动性添加时间\ntopLPHolderOf：查询指定池顶级流动性持有者\nmintLp：铸造流动性代币（带官方标识参数）\nsetWhitelist：设置白名单权限状态', '智能合约名称：UraniumERC20。该合约是基于 ERC20 标准的流动性池代币合约，主要用于管理 LP 代币的铸造、销毁、转账及授权功能。合约实现了标准 ERC20 代币的基础功能，并扩展支持 EIP-712 签名授权机制，允许用户通过链下签名进行代币授权操作。关键特性包括：1. 使用 SafeMath 库防止数值溢出；2. 内置铸造(_mint)和销毁(_burn)功能；3. 实现 Permit 许可功能，支持离线签名授权；4. 构造符合 EIP-712 标准的域分隔符；5. 包含标准代币的基本属性（名称、符号、小数位）。合约通过 nonces 映射防止签名重放攻击，在转账时处理无限授权特殊情况，并通过 DOMAIN_SEPARATOR 确保跨链签名兼容性。\n\n函数列表如下：\n1. constructor()：初始化合约并设置 EIP-712 域分隔符\n2. _mint(address to, uint value)：内部铸造代币到指定地址\n3. _burn(address from, uint value)：内部销毁指定地址的代币\n4. _approve(address owner, address spender, uint value)：内部处理授权额度设置\n5. _transfer(address from, address to, uint value)：内部执行转账逻辑\n6. approve(address spender, uint value)：外部授权函数，设置其他地址可使用额度\n7. transfer(address to, uint value)：外部转账函数，发送代币到指定地址\n8. transferFrom(address from, address to, uint value)：外部代理转账函数，需预先授权\n9. permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s)：离线签名授权函数，支持 EIP-712 标准签名验证', 'UraniumERC20接口合约总结：该智能合约定义了一个符合ERC20标准的代币接口，并扩展实现了EIP-2612许可功能。核心功能包括代币基本信息查询（名称/符号/精度）、余额查询、代币转账授权机制，以及通过链下签名进行授权的免Gas批准功能。合约通过DOMAIN_SEPARATOR和PERMIT_TYPEHASH实现EIP-712结构化签名验证，nonces映射表用于防止签名重放攻击，permit函数允许用户通过数字签名方式授权第三方操作代币。\n\n函数列表：\n1. name() - 获取代币名称\n2. symbol() - 获取代币符号\n3. decimals() - 获取代币精度\n4. totalSupply() - 查询代币总供应量\n5. balanceOf() - 查询指定地址余额\n6. allowance() - 查询授权额度\n7. approve() - 设置第三方操作额度\n8. transfer() - 执行代币转账\n9. transferFrom() - 从指定地址转账代币\n10. DOMAIN_SEPARATOR() - 获取EIP-712域分隔符\n11. PERMIT_TYPEHASH() - 获取许可类型哈希\n12. nonces() - 查询地址的许可计数器\n13. permit() - 通过签名执行授权批准', 'MonoXLibrary 智能合约总结：该智能合约是一个名为 MonoXLibrary 的工具库，主要用于处理虚拟现金（vcash）余额计算及以太币安全转账功能。合约包含三个核心功能模块：(1) safeTransferETH 函数实现安全的 ETH 转账，采用底层调用方式并验证转账结果，确保资金转移可靠性；(2) vcashBalanceAdd 函数处理 vcash 信用与债务的平衡增加逻辑，根据现有债务情况智能分配增量到信用或债务；(3) vcashBalanceSub 函数执行 vcash 余额的扣减操作，优先扣除信用余额并在不足时转换为债务。该库通过 SafeMath 实现安全的数学运算，重点服务于需要管理双账户（信用账户与债务账户）余额变化的 DeFi 场景，典型应用于需要同时处理用户信用和债务平衡的金融协议。\n\n函数列表：\n1. safeTransferETH(address to, uint256 value) - 向指定地址安全转账 ETH，验证转账结果有效性\n2. vcashBalanceAdd(uint256 _credit, uint256 _debt, uint256 delta) - 增加 vcash 余额，根据当前债务情况智能分配信用/债务额度\n3. vcashBalanceSub(uint256 _credit, uint256 _debt, uint256 delta) - 减少 vcash 余额，优先扣除信用额度并在不足时增加债务', 'QBridgeToken 智能合约总结：该合约是基于 BEP20 标准构建的可升级代币合约，主要用于实现跨链桥接场景中的代币铸造和销毁功能。合约核心功能包含权限管理机制，通过维护铸币者白名单实现代币操作权限控制。合约所有者可通过 setMinter 函数动态管理具有铸币权限的地址，授权后的铸币者地址可执行代币铸造 mint 和带授权销毁 burnFrom 操作。合约继承自 BEP20Upgradeable 实现代币基础功能，并采用初始化函数 initialize 支持可升级合约模式，允许在部署后设置代币名称、符号和小数位。销毁功能采用从指定账户扣除授权额度的安全机制，通过校验用户对铸币者的授权额度防止超额燃烧代币。\n\n函数列表：\n1. initialize - 初始化函数，设置代币名称、符号和小数位\n2. setMinter - 设置/取消地址的铸币者权限（仅合约所有者可调用）\n3. mint - 向指定地址铸造代币（仅铸币者可调用）\n4. burnFrom - 从指定账户销毁代币并更新授权额度（仅铸币者可调用）\n5. isMinter - 查询指定地址是否具有铸币者权限', 'WithdrawFacet 智能合约总结：该合约作为钻石标准（Diamond Standard）的模块化组件，专门处理资产提现功能。核心功能允许合约所有者提取 ETH 原生代币或 ERC20 代币资产，关键实现三个核心机制：1. 权限控制机制，通过 LibDiamond 库强制验证调用者为合约所有者；2. 资产适配机制，智能识别原生代币（ETH）与 ERC20 代币的不同处理逻辑；3. 安全转账机制，针对 ERC20 代币使用 OpenZeppelin 的 SafeERC20 安全库进行防重入转账，对 ETH 转账则采用原生 transfer 函数并附带余额验证。合约特别设置地址零（address(0)）作为原生代币标识符，提现时会自动检测接收地址有效性（空地址时默认转给调用者），所有操作均会触发 LogWithdraw 事件记录提现细节。\n\n函数列表：\n- withdraw(address _assetAddress, address _to, uint256 _amount)：核心提现函数，处理 ETH/ERC20 资产提现逻辑，执行权限验证、接收地址处理、资产类型判断、余额验证、安全转账及事件触发等完整流程。', '智能合约名称：IStakingRewards质押奖励接口合约\n\n总结：该合约是一个定义质押奖励机制的接口合约，规定了质押系统中必须实现的核心功能。合约采用0.7.5版本Solidity编写，通过接口形式定义了质押奖励系统的标准交互方法。主要功能包含资金质押、奖励提取、本金赎回等基础操作，同时提供奖励计算、余额查询等视图功能。该接口未包含具体实现逻辑，主要作为其他合约继承和实现的模板框架，适用于流动性挖矿、质押奖励分配等场景。关键功能点包括支持用户质押代币获取奖励、按需提取本金、实时计算应得奖励、批量退出功能等。视图函数组为外部查询提供奖励发放时间、代币收益率、账户收益明细等关键数据接口。\n\n函数列表：\n1. stake(uint256 amount) external：执行代币质押操作，存入指定金额\n2. withdraw(uint256 amount) external：提取已质押的本金\n3. getReward() external：领取已获得的奖励\n4. exit() external：同时执行提现和领取奖励操作\n5. lastTimeRewardApplicable() external view returns (uint256)：查询最近有效的奖励计算时间\n6. rewardPerToken() external view returns (uint256)：计算当前每单位代币的奖励值\n7. earned(address account) external view returns (uint256)：查询指定账户的待领取奖励总额\n8. getRewardForDuration() external view returns (uint256)：获取奖励周期内的总奖励量\n9. totalSupply() external view returns (uint256)：查询合约内质押代币总量\n10. balanceOf(address account) external view returns (uint256)：查询指定账户的质押余额', '智能合约名称：ICBridge（跨链桥接接口合约）。该合约为跨链资产转移定义了标准接口，主要用于不同区块链网络间的代币转移和交易验证。合约包含三个核心功能：1. 支持ERC20代币的跨链转账 2. 支持原生代币(如ETH)的跨链转账 3. 提供多方签名的交易验证中继机制。关键实现包括目标链ID参数指定跨链目的地、nonce防止重复交易、maxSlippage控制交易滑点，以及通过多签验证保障跨链交易安全性。\n\n函数列表：\n1. send：发送ERC20代币到指定跨链网络，需要传入接收地址、代币合约地址、转账金额、目标链ID、交易序号和最大滑点值\n2. sendNative：发送原生代币到指定跨链网络，参数去除了代币合约地址，其他与send函数保持一致\n3. relay：验证并执行跨链中继交易，需提供中继请求数据、签名数组、签名者地址数组和权限数组，实现多方签名验证机制', '该智能合约是一个名为 VaultWithIndirection 的库，主要用于管理通过 Yearn 金库适配器进行资金存取的逻辑。合约通过 Data 结构体记录每个金库适配器实例及其总存款量，List 结构体用于管理多个金库实例集合。核心功能包括存款/取款操作、收益收割及金库列表管理，通过与 YearnVaultAdapterWithIndirection 适配器交互实现资金托管，采用 SafeMath 和 SafeERC20 确保数值计算与代币操作的安全性。存款时资金会转入适配器并更新总存款量，提款时通过直接/间接两种方式处理，harvest 函数可提取超出本金部分的收益。列表管理功能支持添加/查询/遍历多个金库实例。\n\n函数列表如下：\ntotalValue：查看金库总资产价值\ntoken：获取金库接受的代币类型\ndeposit：存入指定数量代币\ndepositAll：存入合约全部代币余额\nwithdraw：向指定地址提取代币并更新总存款量\ndirectWithdraw：直接通过适配器提取代币（不修改总存款量）\nindirectWithdraw：间接通过适配器提取代币（不修改总存款量）\nwithdrawAll：提取全部已存款代币\nharvest：提取超额收益到指定地址\npush：向列表添加新金库实例\nget：通过索引获取列表中的金库实例\nlast：获取列表最后一个金库实例\nlastIndex：获取列表最后一个元素的索引号\nlength：获取列表元素总数', '该智能合约是一个名为 Math 的数学工具库，旨在提供 Solidity 语言中缺失的基础数学计算功能。合约包含三个核心函数：max 用于比较并返回两个数中的较大值，min 用于返回较小值，average 则通过优化计算逻辑实现安全的平均值运算（避免整数溢出问题）。所有函数均定义为 internal pure 类型，意味着它们仅支持合约内部调用且不读取/修改链上状态，适用于需要基础数学运算的智能合约场景。值得注意的是，average 函数采用分段计算（先处理除法余数再求和），有效规避了直接相加可能导致的溢出风险，体现了安全编程思想。\n\n函数列表如下：\n1. max(uint256 a, uint256 b) internal pure：返回两个数中的较大值\n2. min(uint256 a, uint256 b) internal pure：返回两个数中的较小值\n3. average(uint256 a, uint256 b) internal pure：通过防溢出算法计算两数平均值', '该智能合约是一个名为 Decimal 的库合约，用于实现 18 位精度的定点数运算。其主要功能是通过结构体 D256 封装数值，并提供一系列数学运算方法，支持加减乘除、幂运算、比较操作及类型转换。合约依赖 OpenZeppelin 的 SafeMath 库确保运算安全，避免溢出问题。核心逻辑围绕定点数的精度处理展开，例如将普通整数转换为定点数时自动乘以 10^18，除法运算通过预先放大数值保证精度。该库适用于需要高精度小数计算的场景，如金融利率计算或复杂数学建模。\n\n函数列表如下：\n- zero()：返回值为0的D256实例\n- one()：返回值为1的D256实例（实际存储为10^18）\n- from(uint256)：将普通整数转换为定点数\n- ratio(uint256,uint256)：计算两个数的比例值并转换为定点数\n- add()：实现定点数与普通整数/定点数的加法重载函数\n- sub()：实现定点数与普通整数/定点数的减法重载函数（包含带错误提示版本）\n- mul()：实现定点数与普通整数/定点数的乘法重载函数\n- div()：实现定点数与普通整数/定点数的除法重载函数\n- pow()：计算定点数的整数次幂\n- equals()：判断两个定点数是否相等\n- greaterThan()/lessThan()：实现大小比较功能\n- greaterThanOrEqualTo()/lessThanOrEqualTo()：实现复合条件比较\n- isZero()：判断数值是否为0\n- asUint256()：将定点数转换回普通整数（舍弃小数部分）\n- getPartial()：内部核心方法处理分数乘法运算\n- compareTo()：内部方法实现三态比较逻辑', '总结：该智能合约代码定义了一个名为 ITransmuter 的接口，主要功能是声明代币分配机制。合约仅包含一个核心函数 distribute，用于实现某种形式的代币分发逻辑，但接口本身不包含具体实现。该接口可能被其他合约继承调用，实际业务逻辑需在实现合约中完成。关键点在于通过地址参数 origin 和数量参数 amount 构建分发机制，具体分配策略需参考实现该接口的合约代码。\n\n函数列表：\n1. distribute(address origin, uint256 amount) external：声明代币分发功能的外部接口函数，具体实现需在继承合约中完成，参数包含发起地址和分配数量。', '智能合约名称：AddressUpgradeable。该合约是一个用于处理地址相关操作的实用工具库，提供安全检查与增强的底层调用功能。核心功能包括判断地址是否为合约、安全发送ETH、执行底层合约调用三大模块。通过封装低级别调用操作并加入安全校验，解决了直接使用transfer的gas限制问题，防止合约调用中的常见漏洞。关键实现包括：1. 使用extcodesize指令检测合约地址，但需注意构造函数执行期间可能返回误判；2. 采用call方法替代transfer突破2300gas限制，同时严格校验余额和调用结果；3. 提供带值调用与静态调用的统一处理，通过_verifyCallResult内部方法统一处理调用结果，自动解析回滚原因。该库广泛用于可升级合约模式，通过模块化设计提升合约安全性。\n\n函数列表：\nisContract：检查给定地址是否为合约账户，使用extcodesize指令实现\nsendValue：向指定地址发送ETH，替代transfer方法并突破gas限制\nfunctionCall：执行基础合约调用，无ETH转账\nfunctionCall：带自定义错误信息的合约调用重载函数\nfunctionCallWithValue：附带ETH转账的合约调用\nfunctionCallWithValue：带错误信息和ETH转账的调用重载\nfunctionStaticCall：执行不会修改状态的静态调用\nfunctionStaticCall：带错误信息的静态调用重载\n_verifyCallResult：内部方法，验证调用结果并处理回滚信息', '智能合约名称：UraniumPair 接口合约。该合约定义了一个去中心化交易所流动性池配对合约的标准接口，包含代币交易、流动性管理、价格预言机等核心功能。合约继承 ERC20 标准代币基础功能，同时扩展 DEX 流动性池特性，支持铸造/销毁流动性代币、代币兑换、储备量同步等操作。关键功能包括：1. 实现 ERC20 标准代币接口用于流动性代币管理 2. 支持元交易许可（ERC2612）3. 提供代币兑换机制与滑点控制 4. 维护交易对储备量数据及价格累积值 5. 包含最小流动性保护机制。合约通过事件流记录流动性变化（Mint/Burn）、代币交换（Swap）和储备同步（Sync）等关键操作。\n\n函数列表：\nname() - 获取流动性代币名称\nsymbol() - 获取代币符号\ndecimals() - 返回代币精度\ntotalSupply() - 查询总供应量\nbalanceOf() - 查询指定地址余额\nallowance() - 查询授权额度\napprove() - 授权支出额度\ntransfer() - 转账代币\ntransferFrom() - 从指定地址转账\nDOMAIN_SEPARATOR() - 获取许可签名域分隔符\nPERMIT_TYPEHASH() - 返回许可类型哈希\nnonces() - 查询地址的许可随机数\npermit() - 执行离线许可授权\nMINIMUM_LIQUIDITY() - 获取最小流动性限制值\nfactory() - 查询所属工厂合约地址\ntoken0() - 获取交易对中第一种代币地址\ntoken1() - 获取交易对中第二种代币地址\ngetReserves() - 查询当前储备量及时间戳\nprice0CumulativeLast() - 获取代币0价格累积值\nprice1CumulativeLast() - 获取代币1价格累积值\nkLast() - 查询最后一次交易的储备积\nmint() - 铸造流动性代币\nburn() - 销毁流动性代币并提取基础资产\nswap() - 执行代币兑换交易\nskim() - 提取超额代币余额\nsync() - 强制同步储备量\ninitialize() - 初始化交易对代币地址', '智能合约名称：IInterestRateModel（利率模型接口）\n\n总结内容：该智能合约是一个定义利率模型标准的接口合约，主要规定了去中心化金融协议中资金利率计算的核心方法。合约通过四个函数定义了利率模型必须实现的基础功能：1）提供区块链年区块数基准值 2）验证合约身份标识 3）计算实时借款利率 4）计算存款供应利率。其中核心逻辑体现在getBorrowRate和getSupplyRate两个函数，通过输入现金总量、借款总量、准备金量等关键参数，采用特定算法模型输出动态利率。该接口为具体利率模型实现提供了标准化规范，可支持白名单机制、阶梯利率、市场调节利率等多种模型的具体实现。\n\n函数列表：\n1. blocksPerYear() - 获取系统设定的每年区块数量基准值\n2. isInterestRateModel() - 验证合约是否合规利率模型的身份确认函数\n3. getBorrowRate(uint256 cash, uint256 borrows, uint256 reserves) - 根据当前资金状况计算借款利率\n4. getSupplyRate(uint256 cash, uint256 borrows, uint256 reserves, uint256 reserveFactor) - 计算考虑储备金因子后的存款利率', 'UniswapV2Pair 智能合约接口总结：该智能合约定义了 Uniswap V2 去中心化交易所中流动性池的核心功能，作为 ERC20 标准代币实现交易对池化资产管理。合约通过自动化做市商机制实现代币兑换，包含流动性铸造/销毁、代币交换、储备金同步等核心功能，并集成 ERC2612 签名授权特性。关键功能包括通过 mint/burn 函数进行流动性增减管理，swap 函数执行代币兑换，以及通过 getReserves 获取实时资金池状态。合约通过事件流记录资金变动，维护价格累积变量实现链上价格追踪。\n\n函数列表如下：\n1. name() - 获取流动性代币名称\n2. symbol() - 获取代币符号\n3. decimals() - 返回代币精度\n4. totalSupply() - 查询代币总供应量\n5. balanceOf() - 查询指定地址余额\n6. allowance() - 查询授权额度\n7. approve() - 设置代币操作权限\n8. transfer() - 转账代币\n9. transferFrom() - 从指定地址转账\n10. DOMAIN_SEPARATOR() - 获取 EIP712 域分隔符\n11. PERMIT_TYPEHASH() - 返回许可类型哈希\n12. nonces() - 查询地址的许可随机数\n13. permit() - 通过签名执行授权\n14. MINIMUM_LIQUIDITY() - 获取最小流动性限制\n15. factory() - 查询所属工厂地址\n16. token0() - 获取第一个代币地址\n17. token1() - 获取第二个代币地址\n18. getReserves() - 返回当前储备量及时间戳\n19. price0CumulativeLast() - 获取代币0价格累积值\n20. price1CumulativeLast() - 获取代币1价格累积值\n21. kLast() - 查询最后储备乘积值\n22. mint() - 铸造流动性代币\n23. burn() - 销毁流动性代币并提取基础资产\n24. swap() - 执行代币兑换交易\n25. skim() - 调整储备与余额的差异\n26. sync() - 强制同步储备数据\n27. initialize() - 初始化交易对代币地址', '智能合约名称：IUraniumERC20接口合约。该合约为符合ERC20标准的代币接口，定义了代币基本功能及扩展的元交易许可功能。合约包含标准ERC20函数如转账、余额查询、授权机制，并集成EIP-2612许可签名功能，允许用户通过链下签名进行代币授权操作，无需提前发起链上交易。关键功能包括代币信息查询（名称/符号/小数位）、总量查询、转账逻辑、授权额度管理，以及通过签名实现无Gas费授权的permit函数，支持离线签名验证与防重放攻击的非ces机制。\n\n函数列表如下：\n1. name() – 返回代币名称字符串\n2. symbol() – 返回代币符号字符串\n3. decimals() – 返回代币小数位数值\n4. totalSupply() – 查询代币总供应量\n5. balanceOf() – 查询指定地址余额\n6. allowance() – 查询授权额度\n7. approve() – 设置代币操作授权额度\n8. transfer() – 向指定地址转账\n9. transferFrom() – 从指定地址转账\n10. DOMAIN_SEPARATOR() – 获取EIP-712域分隔符\n11. PERMIT_TYPEHASH() – 返回许可类型哈希值\n12. nonces() – 查询地址的许可使用次数\n13. permit() – 通过签名验证处理代币授权', '该智能合约定义了一个名为IWETH的接口，用于封装以太坊的Wrapped ETH（WETH）标准操作。作为ERC-20代币与原生ETH之间的桥梁，该接口提供了基础的资金转换功能，实现ETH与WETH之间的双向转换及代币转账功能。这是DeFi应用中处理ETH包装逻辑的核心接口，常见于去中心化交易所和跨链桥接协议。该接口通过三个核心函数实现：存款操作将ETH转换为等量WETH代币，转账函数实现代币所有权转移，提现功能支持将WETH解包回原生ETH。  \n\n函数列表如下：  \n1. deposit() external payable - 将以太币ETH存入合约并铸造等量WETH代币  \n2. transfer(address to, uint value) external returns (bool) - 向指定地址转移指定数量的WETH代币  \n3. withdraw(uint) external - 销毁指定数量的WETH代币并提取等量ETH到调用者地址', '智能合约名称：UraniumPair接口合约（基于Uniswap模型的DEX交易对接口）\n\n该合约定义了去中心化交易所中流动性池的核心功能接口，采用类似Uniswap V2的自动化做市商机制。合约主要包含ERC20代币标准接口、流动性池操作功能和价格预言机功能三个核心模块。作为交易对合约，它实现了流动性代币的铸造/销毁机制，支持代币互换操作，并通过储备量跟踪实现价格计算。合约包含离线授权功能（EIP-2612标准），允许通过签名进行代币授权操作。关键设计包括最小流动性锁定机制（MINIMUM_LIQUIDITY）、储备量同步机制（sync）以及价格累计值记录（priceXCumulativeLast），这些特性为外部系统提供可靠的价格预言机服务。\n\n函数列表：\n1. ERC20标准函数：\n- name()：获取代币名称\n- symbol()：获取代币符号\n- decimals()：获取代币精度\n- totalSupply()：查询总供应量\n- balanceOf()：查询地址余额\n- allowance()：查询授权额度\n- approve()：设置代币授权\n- transfer()：执行代币转账\n- transferFrom()：执行授权转账\n\n2. 权限管理扩展：\n- DOMAIN_SEPARATOR()：获取EIP-712域分隔符\n- PERMIT_TYPEHASH()：获取授权类型哈希\n- nonces()：查询地址的交易计数\n- permit()：通过签名执行离线授权\n\n3. 流动性池核心功能：\n- MINIMUM_LIQUIDITY()：获取最小流动性阈值\n- factory()：查询所属工厂合约\n- token0()/token1()：获取交易对代币地址\n- getReserves()：获取当前储备量数据\n- price0CumulativeLast()/price1CumulativeLast()：获取累计价格\n- kLast()：获取最后交易后的k值\n- mint()：铸造流动性代币\n- burn()：销毁流动性代币\n- swap()：执行代币互换\n- skim()：调整储备余额\n- sync()：同步储备数据\n- initialize()：初始化交易对代币', '智能合约名称：IERC1155MetadataURI（ERC1155元数据接口合约）。该合约是ERC1155标准的元数据扩展接口，定义了获取代币元数据URI的规范。作为IERC1155接口的扩展，它遵循EIP-1155标准中关于元数据的规范要求，核心功能是为非同质化代币（NFT）和半同质化代币提供外部元数据查询支持。关键代码通过uri()函数实现，允许客户端根据代币ID查询对应的元数据URI地址，URI中可包含{id}占位符供客户端动态替换实际代币ID。此接口需要具体实现合约来返回实际URI路径，通常用于支持OpenSea等平台读取代币元数据信息。合约版本要求Solidity 0.6.2至0.8.0之间，符合ERC1155标准v3.1版本规范。\n\n函数列表：\n1. uri(uint256 id) external view returns (string memory)：查询指定代币ID对应的元数据URI，返回的URI字符串中可包含{id}占位符，客户端需将其替换为实际代币ID数值。该函数为外部只读视图函数，不消耗Gas且不修改链上状态。']], 'uris': None, 'data': None, 'included': ['distances', 'documents']}
------------------------------------------------
重排序结果：
['SushiSwap.sol-SushiMaker.sol', 'SushiSwap.sol-SushiRoll.sol', 'Alchemix.sol-IWETH9.sol', 'SushiSwap.sol-UniswapV2ERC20.sol', 'MonoX.sol-IERC1155.sol', 'MonoX.sol-Monoswap.sol', 'Punk Protocol-2.sol-ModelInterface.sol', 'Saddle Finance.sol-ISwap.sol', 'XCarnival.sol-IERC1155Upgradeable.sol', 'Li.Fi.sol-LibAsset.sol', 'Uranium Finance-2.sol-UraniumERC20.sol', 'SushiSwap.sol-Address.sol', 'Uranium Finance-4.sol-IUraniumFactory.sol', 'Nmbplatform.sol-SafeERC20.sol', 'Qubit Finance.sol-BEP20Upgradeable.sol', 'Cover Protocol.sol-Vesting.sol', 'Uranium Finance-4.sol-IUraniumPair.sol', 'Beanstalk.sol-LibIncentive.sol', 'Cover Protocol.sol-COVER.sol', 'Rikkei Finance.sol-InterestRateModel.sol']
------------------------------------------------
函数切片：

------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-bridgeFor-0
元数据:{'block索引': 0, '函数名': 'bridgeFor', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function bridgeFor(address token) public view returns (address bridge) {
bridge = _bridges[token];
if (bridge == address(0)) {
bridge = weth;
}
}
// F1 - F10: OK
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-setBridge-1
元数据:{'block索引': 1, '函数名': 'setBridge', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token, address bridge', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LogBridgeSet']", '返回值': ''}
函数切片:
function setBridge(address token, address bridge) external onlyOwner {
// Checks
require(token != sushi && token != weth && token != bridge, "SushiMaker: Invalid bridge");
// Effects
_bridges[token] = bridge;
emit LogBridgeSet(token, bridge);
}
// M1 - M5: OK
// C1 - C24: OK
// C6: It's not a fool proof solution, but it prevents flash loans, so here it's ok to use tx.origin
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-onlyEOA-2
元数据:{'block索引': 2, '函数名': 'onlyEOA', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyEOA() {
// Try to make flash-loan exploit harder to do.
require(msg.sender == tx.origin, "SushiMaker: must use EOA");
_;
}
// F1 - F10: OK
// F3: _convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple
// F6: There is an exploit to add lots of SUSHI to the bar, run convert, then remove the SUSHI again.
//     As the size of the SushiBar has grown, this requires large amounts of funds and isn't super profitable anymore
//     The onlyEOA modifier prevents this being done with a flash loan.
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-convert-3
元数据:{'block索引': 3, '函数名': 'convert', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function convert(address token0, address token1) external onlyEOA() {
_convert(token0, token1);
}
// F1 - F10: OK, see convert
// C1 - C24: OK
// C3: Loop is under control of the caller
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-convertMultiple-4
元数据:{'block索引': 4, '函数名': 'convertMultiple', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address[] calldata token0, address[] calldata token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function convertMultiple(address[] calldata token0, address[] calldata token1) external onlyEOA() {
// TODO: This can be optimized a fair bit, but this is safer and simpler for now
uint256 len = token0.length;
for(uint256 i=0; i < len; i++) {
_convert(token0[i], token1[i]);
}
}
// F1 - F10: OK
// C1- C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_convert-5
元数据:{'block索引': 5, '函数名': '_convert', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['LogConvert']", '返回值': ''}
函数切片:
function _convert(address token0, address token1) internal {
// Interactions
// S1 - S4: OK
IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));
require(address(pair) != address(0), "SushiMaker: Invalid pair");
// balanceOf: S1 - S4: OK
// transfer: X1 - X5: OK
IERC20(address(pair)).safeTransfer(address(pair), pair.balanceOf(address(this)));
// X1 - X5: OK
(uint256 amount0, uint256 amount1) = pair.burn(address(this));
if (token0 != pair.token0()) {
(amount0, amount1) = (amount1, amount0);
}
emit LogConvert(msg.sender, token0, token1, amount0, amount1, _convertStep(token0, token1, amount0, amount1));
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, _swap, _toSUSHI, _convertStep: X1 - X5: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_convertStep-6
元数据:{'block索引': 6, '函数名': '_convertStep', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token0, address token1, uint256 amount0, uint256 amount1', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _convertStep(address token0, address token1, uint256 amount0, uint256 amount1) internal returns(uint256 sushiOut) {
// Interactions
if (token0 == token1) {
uint256 amount = amount0.add(amount1);
if (token0 == sushi) {
IERC20(sushi).safeTransfer(bar, amount);
sushiOut = amount;
} else if (token0 == weth) {
sushiOut = _toSUSHI(weth, amount);
} else {
address bridge = bridgeFor(token0);
amount = _swap(token0, bridge, amount, address(this));
sushiOut = _convertStep(bridge, bridge, amount, 0);
}
} else if (token0 == sushi) { // eg. SUSHI - ETH
IERC20(sushi).safeTransfer(bar, amount0);
sushiOut = _toSUSHI(token1, amount1).add(amount0);
} else if (token1 == sushi) { // eg. USDT - SUSHI
IERC20(sushi).safeTransfer(bar, amount1);
sushiOut = _toSUSHI(token0, amount0).add(amount1);
} else if (token0 == weth) { // eg. ETH - USDC
sushiOut = _toSUSHI(weth, _swap(token1, weth, amount1, address(this)).add(amount0));
} else if (token1 == weth) { // eg. USDT - ETH
sushiOut = _toSUSHI(weth, _swap(token0, weth, amount0, address(this)).add(amount1));
} else { // eg. MIC - USDT
address bridge0 = bridgeFor(token0);
address bridge1 = bridgeFor(token1);
if (bridge0 == token1) { // eg. MIC - USDT - and bridgeFor(MIC) = USDT
sushiOut = _convertStep(bridge0, token1,
_swap(token0, bridge0, amount0, address(this)),
amount1
);
} else if (bridge1 == token0) { // eg. WBTC - DSD - and bridgeFor(DSD) = WBTC
sushiOut = _convertStep(token0, bridge1,
amount0,
_swap(token1, bridge1, amount1, address(this))
);
} else {
sushiOut = _convertStep(bridge0, bridge1, // eg. USDT - DSD - and bridgeFor(DSD) = WBTC
_swap(token0, bridge0, amount0, address(this)),
_swap(token1, bridge1, amount1, address(this))
);
}
}
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, swap: X1 - X5: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_swap-7
元数据:{'block索引': 7, '函数名': '_swap', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address fromToken, address toToken, uint256 amountIn, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _swap(address fromToken, address toToken, uint256 amountIn, address to) internal returns (uint256 amountOut) {
// Checks
// X1 - X5: OK
IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(fromToken, toToken));
require(address(pair) != address(0), "SushiMaker: Cannot convert");
// Interactions
// X1 - X5: OK
(uint256 reserve0, uint256 reserve1,) = pair.getReserves();
uint256 amountInWithFee = amountIn.mul(997);
if (fromToken == pair.token0()) {
amountOut = amountIn.mul(997).mul(reserve1) / reserve0.mul(1000).add(amountInWithFee);
IERC20(fromToken).safeTransfer(address(pair), amountIn);
pair.swap(0, amountOut, to, new bytes(0));
// TODO: Add maximum slippage?
} else {
amountOut = amountIn.mul(997).mul(reserve0) / reserve1.mul(1000).add(amountInWithFee);
IERC20(fromToken).safeTransfer(address(pair), amountIn);
pair.swap(amountOut, 0, to, new bytes(0));
// TODO: Add maximum slippage?
}
}
// F1 - F10: OK
// C1 - C24: OK
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiMaker.sol-_toSUSHI-8
元数据:{'block索引': 8, '函数名': '_toSUSHI', '函数所属的合约或接口': 'SushiSwap.sol-SushiMaker.sol', '参数': 'address token, uint256 amountIn', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _toSUSHI(address token, uint256 amountIn) internal returns(uint256 amountOut) {
// X1 - X5: OK
amountOut = _swap(token, sushi, amountIn, bar);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-0
元数据:{'block索引': 0, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function migrateWithPermit(
address tokenA,
address tokenB,
uint256 liquidity,
uint256 amountAMin,
uint256 amountBMin,
uint256 deadline,
uint8 v,
bytes32 r,
bytes32 s
) public {
IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
pair.permit(msg.sender, address(this), liquidity, deadline, v, r, s);
migrate(tokenA, tokenB, liquidity, amountAMin, amountBMin, deadline);
}
// msg.sender should have approved 'liquidity' amount of LP token of 'tokenA' and 'tokenB'
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function migrate(
address tokenA,
address tokenB,
uint256 liquidity,
uint256 amountAMin,
uint256 amountBMin,
uint256 deadline
) public {
require(deadline >= block.timestamp, 'SushiSwap: EXPIRED');
// Remove liquidity from the old router with permit
(uint256 amountA, uint256 amountB) = removeLiquidity(
tokenA,
tokenB,
liquidity,
amountAMin,
amountBMin,
deadline
);
// Add liquidity to the new router
(uint256 pooledAmountA, uint256 pooledAmountB) = addLiquidity(tokenA, tokenB, amountA, amountB);
// Send remaining tokens to msg.sender
if (amountA > pooledAmountA) {
IERC20(tokenA).safeTransfer(msg.sender, amountA - pooledAmountA);
}
if (amountB > pooledAmountB) {
IERC20(tokenB).safeTransfer(msg.sender, amountB - pooledAmountB);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity(
address tokenA,
address tokenB,
uint256 liquidity,
uint256 amountAMin,
uint256 amountBMin,
uint256 deadline
) internal returns (uint256 amountA, uint256 amountB) {
IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
pair.transferFrom(msg.sender, address(pair), liquidity);
(uint256 amount0, uint256 amount1) = pair.burn(address(this));
(address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
(amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
require(amountA >= amountAMin, 'SushiRoll: INSUFFICIENT_A_AMOUNT');
require(amountB >= amountBMin, 'SushiRoll: INSUFFICIENT_B_AMOUNT');
}
// calculates the CREATE2 address for a pair without making any external calls
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-pairForOldRouter-3
元数据:{'block索引': 3, '函数名': 'pairForOldRouter', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function pairForOldRouter(address tokenA, address tokenB) internal view returns (address pair) {
(address token0, address token1) = UniswapV2Library.sortTokens(tokenA, tokenB);
pair = address(uint(keccak256(abi.encodePacked(
hex'ff',
oldRouter.factory(),
keccak256(abi.encodePacked(token0, token1)),
hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
))));
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity(
address tokenA,
address tokenB,
uint256 amountADesired,
uint256 amountBDesired
) internal returns (uint amountA, uint amountB) {
(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired);
address pair = UniswapV2Library.pairFor(router.factory(), tokenA, tokenB);
IERC20(tokenA).safeTransfer(pair, amountA);
IERC20(tokenB).safeTransfer(pair, amountB);
IUniswapV2Pair(pair).mint(msg.sender);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-SushiRoll.sol-5
元数据:{'block索引': 5, '函数名': '', '函数所属的合约或接口': 'SushiSwap.sol-SushiRoll.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _addLiquidity(
address tokenA,
address tokenB,
uint256 amountADesired,
uint256 amountBDesired
) internal returns (uint256 amountA, uint256 amountB) {
// create the pair if it doesn't exist yet
IUniswapV2Factory factory = IUniswapV2Factory(router.factory());
if (factory.getPair(tokenA, tokenB) == address(0)) {
factory.createPair(tokenA, tokenB);
}
(uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(address(factory), tokenA, tokenB);
if (reserveA == 0 && reserveB == 0) {
(amountA, amountB) = (amountADesired, amountBDesired);
} else {
uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
if (amountBOptimal <= amountBDesired) {
(amountA, amountB) = (amountADesired, amountBOptimal);
} else {
uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
assert(amountAOptimal <= amountADesired);
(amountA, amountB) = (amountAOptimal, amountBDesired);
}
}
}
}
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-deposit-0
元数据:{'block索引': 0, '函数名': 'deposit', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function deposit() external payable;
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-withdraw-1
元数据:{'block索引': 1, '函数名': 'withdraw', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': 'uint wad', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdraw(uint wad) external;
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-totalSupply-2
元数据:{'block索引': 2, '函数名': 'totalSupply', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() external view returns (uint);
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-approve-3
元数据:{'block索引': 3, '函数名': 'approve', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': 'address guy, uint wad', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address guy, uint wad) external returns (bool);
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-transfer-4
元数据:{'block索引': 4, '函数名': 'transfer', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': 'address dst, uint wad', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address dst, uint wad) external returns (bool);
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-transferFrom-5
元数据:{'block索引': 5, '函数名': 'transferFrom', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': 'address src, address dst, uint wad', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address src, address dst, uint wad) external returns (bool);
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-name-6
元数据:{'block索引': 6, '函数名': 'name', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function name() external view returns (string memory);
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-symbol-7
元数据:{'block索引': 7, '函数名': 'symbol', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function symbol() external view returns (string memory);
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-decimals-8
元数据:{'block索引': 8, '函数名': 'decimals', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decimals() external view returns (uint8);
------------------------------------------------
函数切片ID: Alchemix.sol-IWETH9.sol-balanceOf-9
元数据:{'block索引': 9, '函数名': 'balanceOf', '函数所属的合约或接口': 'Alchemix.sol-IWETH9.sol', '参数': 'address guy', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address guy) external view returns (uint256);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_mint-0
元数据:{'block索引': 0, '函数名': '_mint', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _mint(address to, uint value) internal {
totalSupply = totalSupply.add(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(address(0), to, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_burn-1
元数据:{'block索引': 1, '函数名': '_burn', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _burn(address from, uint value) internal {
balanceOf[from] = balanceOf[from].sub(value);
totalSupply = totalSupply.sub(value);
emit Transfer(from, address(0), value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_approve-2
元数据:{'block索引': 2, '函数名': '_approve', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address owner, address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Approval']", '返回值': ''}
函数切片:
function _approve(address owner, address spender, uint value) private {
allowance[owner][spender] = value;
emit Approval(owner, spender, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-_transfer-3
元数据:{'block索引': 3, '函数名': '_transfer', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _transfer(address from, address to, uint value) private {
balanceOf[from] = balanceOf[from].sub(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(from, to, value);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-approve-4
元数据:{'block索引': 4, '函数名': 'approve', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool) {
_approve(msg.sender, spender, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-transfer-5
元数据:{'block索引': 5, '函数名': 'transfer', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool) {
_transfer(msg.sender, to, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-transferFrom-6
元数据:{'block索引': 6, '函数名': 'transferFrom', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool) {
if (allowance[from][msg.sender] != uint(-1)) {
allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
}
_transfer(from, to, value);
return true;
}
------------------------------------------------
函数切片ID: SushiSwap.sol-UniswapV2ERC20.sol-permit-7
元数据:{'block索引': 7, '函数名': 'permit', '函数所属的合约或接口': 'SushiSwap.sol-UniswapV2ERC20.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
bytes32 digest = keccak256(
abi.encodePacked(
'\x19\x01',
DOMAIN_SEPARATOR,
keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
)
);
address recoveredAddress = ecrecover(digest, v, r, s);
require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
_approve(owner, spender, value);
}
}
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-balanceOf-0
元数据:{'block索引': 0, '函数名': 'balanceOf', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address account, uint256 id', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address account, uint256 id) external view returns (uint256);
/**
* @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
*
* Requirements:
*
* - `accounts` and `ids` must have the same length.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-balanceOfBatch-1
元数据:{'block索引': 1, '函数名': 'balanceOfBatch', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address[] calldata accounts, uint256[] calldata ids', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
/**
* @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
*
* Emits an {ApprovalForAll} event.
*
* Requirements:
*
* - `operator` cannot be the caller.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-setApprovalForAll-2
元数据:{'block索引': 2, '函数名': 'setApprovalForAll', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address operator, bool approved', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setApprovalForAll(address operator, bool approved) external;
/**
* @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
*
* See {setApprovalForAll}.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-isApprovedForAll-3
元数据:{'block索引': 3, '函数名': 'isApprovedForAll', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address account, address operator', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isApprovedForAll(address account, address operator) external view returns (bool);
/**
* @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
*
* Emits a {TransferSingle} event.
*
* Requirements:
*
* - `to` cannot be the zero address.
* - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
* - `from` must have a balance of tokens of type `id` of at least `amount`.
* - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
* acceptance magic value.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-safeTransferFrom-4
元数据:{'block索引': 4, '函数名': 'safeTransferFrom', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address from, address to, uint256 id, uint256 amount, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
/**
* @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
*
* Emits a {TransferBatch} event.
*
* Requirements:
*
* - `ids` and `amounts` must have the same length.
* - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
* acceptance magic value.
*/
------------------------------------------------
函数切片ID: MonoX.sol-IERC1155.sol-safeBatchTransferFrom-5
元数据:{'block索引': 5, '函数名': 'safeBatchTransferFrom', '函数所属的合约或接口': 'MonoX.sol-IERC1155.sol', '参数': 'address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-mint-0
元数据:{'block索引': 0, '函数名': 'mint', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint (address account, uint256 amount) external;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-burn-1
元数据:{'block索引': 1, '函数名': 'burn', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn (address account, uint256 amount) external;
}
/**
* The Monoswap is ERC1155 contract does this and that...
*/
contract Monoswap is Initializable, OwnableUpgradeable {
using SafeMath for uint256;
using SafeMath for uint112;
using SafeERC20 for IERC20;
using SafeERC20 for IvCash;
IvCash vCash;
address WETH;
address feeTo;
uint16 fees; // over 1e5, 300 means 0.3%
uint16 devFee; // over 1e5, 50 means 0.05%
uint256 constant MINIMUM_LIQUIDITY=100;
struct PoolInfo {
uint256 pid;
uint256 lastPoolValue;
address token;
PoolStatus status;
uint112 vcashDebt;
uint112 vcashCredit;
uint112 tokenBalance;
uint256 price; // over 1e18
uint256 createdAt; // timestamp
}
enum TxType {
SELL,
BUY
}
enum PoolStatus {
UNLISTED,
LISTED,
OFFICIAL,
SYNTHETIC,
PAUSED
}
mapping (address => PoolInfo) public pools;
// tokenStatus is for token lock/transfer. exempt means no need to verify post tx
mapping (address => uint8) private tokenStatus; //0=unlocked, 1=locked, 2=exempt
// token poool status is to track if the pool has already been created for the token
mapping (address => uint8) public tokenPoolStatus; //0=undefined, 1=exists
// negative vCash balance allowed for each token
mapping (address => uint) public tokenInsurance;
uint256 public poolSize;
uint private unlocked;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-lock-2
元数据:{'block索引': 2, '函数名': 'lock', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier lock() {
require(unlocked == 1, 'MonoX:LOCKED');
unlocked = 0;
_;
unlocked = 1;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-lockToken-3
元数据:{'block索引': 3, '函数名': 'lockToken', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier lockToken(address _token) {
uint8 originalState = tokenStatus[_token];
require(originalState!=1, 'MonoX:POOL_LOCKED');
if(originalState==0) {
tokenStatus[_token] = 1;
}
_;
if(originalState==0) {
tokenStatus[_token] = 0;
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-ensure-4
元数据:{'block索引': 4, '函数名': 'ensure', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint deadline', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier ensure(uint deadline) {
require(deadline >= block.timestamp, 'MonoX:EXPIRED');
_;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-onlyPriceAdjuster-5
元数据:{'block索引': 5, '函数名': 'onlyPriceAdjuster', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
modifier onlyPriceAdjuster(){
require(priceAdjusterRole[msg.sender]==true,"MonoX:BAD_ROLE");
_;
}
event AddLiquidity(address indexed provider,
uint indexed pid,
address indexed token,
uint liquidityAmount,
uint vcashAmount, uint tokenAmount, uint price);
event RemoveLiquidity(address indexed provider,
uint indexed pid,
address indexed token,
uint liquidityAmount,
uint vcashAmount, uint tokenAmount, uint price);
event Swap(
address indexed user,
address indexed tokenIn,
address indexed tokenOut,
uint amountIn,
uint amountOut,
uint swapVcashValue
);
// event PriceAdjusterChanged(
//   address indexed priceAdjuster,
//   bool added
// );
event PoolBalanced(
address _token,
uint vcashIn
);
event SyntheticPoolPriceChanged(
address _token,
uint price
);
event PoolStatusChanged(
address _token,
PoolStatus oldStatus,
PoolStatus newStatus
);
IMonoXPool public monoXPool;
// mapping (token address => block number of the last trade)
mapping (address => uint) public lastTradedBlock;
uint256 constant MINIMUM_POOL_VALUE = 10000 * 1e18;
mapping (address=>bool) public priceAdjusterRole;
// ------------
uint public poolSizeMinLimit;
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-initialize-6
元数据:{'block索引': 6, '函数名': 'initialize', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'IMonoXPool _monoXPool, IvCash _vcash', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(IMonoXPool _monoXPool, IvCash _vcash) public initializer {
OwnableUpgradeable.__Ownable_init();
monoXPool = _monoXPool;
vCash = _vcash;
WETH = _monoXPool.WETH();
fees = 300;
devFee = 50;
poolSize = 0;
unlocked = 1;
}
// receive() external payable {
//   assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
// }
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setFeeTo-7
元数据:{'block索引': 7, '函数名': 'setFeeTo', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _feeTo', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo (address _feeTo) onlyOwner external {
feeTo = _feeTo;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setFees-8
元数据:{'block索引': 8, '函数名': 'setFees', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint16 _fees', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFees (uint16 _fees) onlyOwner external {
require(_fees<1e3);
fees = _fees;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setDevFee-9
元数据:{'block索引': 9, '函数名': 'setDevFee', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint16 _devFee', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setDevFee (uint16 _devFee) onlyOwner external {
require(_devFee<1e3);
devFee = _devFee;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setPoolSizeMinLimit-10
元数据:{'block索引': 10, '函数名': 'setPoolSizeMinLimit', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint _poolSizeMinLimit', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setPoolSizeMinLimit(uint _poolSizeMinLimit) onlyOwner external {
poolSizeMinLimit = _poolSizeMinLimit;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setTokenInsurance-11
元数据:{'block索引': 11, '函数名': 'setTokenInsurance', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _insurance', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setTokenInsurance (address _token, uint _insurance) onlyOwner external {
tokenInsurance[_token] = _insurance;
}
// when safu, setting token status to 2 can achieve significant gas savings
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setTokenStatus-12
元数据:{'block索引': 12, '函数名': 'setTokenStatus', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint8 _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setTokenStatus (address _token, uint8 _status) onlyOwner external {
tokenStatus[_token] = _status;
}
// update status of a pool. onlyOwner.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePoolStatus-13
元数据:{'block索引': 13, '函数名': 'updatePoolStatus', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolStatusChanged']", '返回值': ''}
函数切片:
function updatePoolStatus(address _token, PoolStatus _status) external onlyOwner {
PoolStatus poolStatus = pools[_token].status;
if(poolStatus==PoolStatus.PAUSED){
require(block.number > lastTradedBlock[_token].add(6000), "MonoX:TOO_EARLY");
}
else{
// okay to pause an official pool, wait 6k blocks and then convert it to synthetic
require(_status!=PoolStatus.SYNTHETIC,"MonoX:NO_SYNT");
}
emit PoolStatusChanged(_token, poolStatus,_status);
pools[_token].status = _status;
// unlisting a token allows creating a new pool of the same token.
// should move it to PAUSED if the goal is to blacklist the token forever
if(_status==PoolStatus.UNLISTED) {
tokenPoolStatus[_token] = 0;
}
}
/**
@dev update pools price if there were no active trading for the last 6000 blocks
@notice Only owner callable, new price can neither be 0 nor be equal to old one
@param _token pool identifider (token address)
@param _newPrice new price in wei (uint112)
*/
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePoolPrice-14
元数据:{'block索引': 14, '函数名': 'updatePoolPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _newPrice', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function updatePoolPrice(address _token, uint _newPrice) external onlyOwner {
require(_newPrice > 0, 'MonoX:0_PRICE');
require(tokenPoolStatus[_token] != 0, "MonoX:NO_POOL");
require(block.number > lastTradedBlock[_token].add(6000), "MonoX:TOO_EARLY");
pools[_token].price = _newPrice;
lastTradedBlock[_token] = block.number;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-updatePriceAdjuster-15
元数据:{'block索引': 15, '函数名': 'updatePriceAdjuster', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address account, bool _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PriceAdjusterChanged']", '返回值': ''}
函数切片:
function updatePriceAdjuster(address account, bool _status) external onlyOwner{
priceAdjusterRole[account]=_status;
//emit PriceAdjusterChanged(account,_status);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-setSynthPoolPrice-16
元数据:{'block索引': 16, '函数名': 'setSynthPoolPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint price', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['SyntheticPoolPriceChanged']", '返回值': ''}
函数切片:
function setSynthPoolPrice(address _token, uint price) external onlyPriceAdjuster {
require(pools[_token].status==PoolStatus.SYNTHETIC,"MonoX:NOT_SYNT");
require(price > 0, "MonoX:ZERO_PRICE");
pools[_token].price=price;
emit SyntheticPoolPriceChanged(_token,price);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-rebalancePool-17
元数据:{'block索引': 17, '函数名': 'rebalancePool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolBalanced']", '返回值': ''}
函数切片:
function rebalancePool(address _token) external lockToken(_token) onlyOwner{
// // PoolInfo memory pool = pools[_token];
// uint poolPrice = pools[_token].price;
// require(vcashIn <= pools[_token].vcashDebt,"MonoX:NO_CREDIT");
// require((pools[_token].tokenBalance * poolPrice).div(1e18) >= vcashIn,"MonoX:INSUF_TOKEN_VAL");
// // uint rebalancedAmount = vcashIn.mul(1e18).div(pool.price);
// monoXPool.safeTransferERC20Token(_token, msg.sender, vcashIn.mul(1e18).div(poolPrice));
// _syncPoolInfo(_token, vcashIn, 0);
// emit PoolBalanced(_token, vcashIn);
_internalRebalance(_token);
}
// must be called from a method with token lock to prevent reentry
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_internalRebalance-18
元数据:{'block索引': 18, '函数名': '_internalRebalance', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['PoolBalanced']", '返回值': ''}
函数切片:
function _internalRebalance(address _token) internal {
uint poolPrice = pools[_token].price;
uint vcashIn = pools[_token].vcashDebt;
if(poolPrice.mul(pools[_token].tokenBalance) / 1e18 < vcashIn){
vcashIn = poolPrice.mul(pools[_token].tokenBalance) / 1e18;
}
if(tokenStatus[_token]==2){
monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));
}else{
uint256 balanceIn0 = IERC20(_token).balanceOf(address(monoXPool));
monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));
uint256 balanceIn1 = IERC20(_token).balanceOf(address(monoXPool));
uint realAmount = balanceIn0.sub(balanceIn1);
vcashIn = realAmount.mul(poolPrice) / 1e18;
}
_syncPoolInfo(_token, vcashIn, 0);
emit PoolBalanced(_token,vcashIn);
}
// creates a pool
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_createPool-19
元数据:{'block索引': 19, '函数名': '_createPool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _price, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _createPool (address _token, uint _price, PoolStatus _status) lock internal returns(uint256 _pid)  {
require(tokenPoolStatus[_token]==0, "MonoX:POOL_EXISTS");
require (_token != address(vCash), "MonoX:NO_vCash");
_pid = poolSize;
pools[_token] = PoolInfo({
token: _token,
pid: _pid,
vcashCredit: 0,
vcashDebt: 0,
tokenBalance: 0,
lastPoolValue: 0,
status: _status,
price: _price,
createdAt: block.timestamp
});
poolSize = _pid.add(1);
tokenPoolStatus[_token]=1;
// initialze pool's lasttradingblocknumber as the block number on which the pool is created
lastTradedBlock[_token] = block.number;
}
// creates a pool with special status
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addSpecialToken-20
元数据:{'block索引': 20, '函数名': 'addSpecialToken', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint _price, PoolStatus _status', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addSpecialToken (address _token, uint _price, PoolStatus _status) onlyOwner external returns(uint256 _pid)  {
_pid = _createPool(_token, _price, _status);
}
// internal func to pay contract owner
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_mintFee-21
元数据:{'block索引': 21, '函数名': '_mintFee', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint256 pid, uint256 lastPoolValue, uint256 newPoolValue', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _mintFee (uint256 pid, uint256 lastPoolValue, uint256 newPoolValue) internal {
// dropping tx fees for now
return;
}
// util func to get some basic pool info
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-getPool-22
元数据:{'block索引': 22, '函数名': 'getPool', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPool (address _token) view public returns (uint256 poolValue,
uint256 tokenBalanceVcashValue, uint256 vcashCredit, uint256 vcashDebt) {
// PoolInfo memory pool = pools[_token];
vcashCredit = pools[_token].vcashCredit;
vcashDebt = pools[_token].vcashDebt;
tokenBalanceVcashValue = pools[_token].price.mul(pools[_token].tokenBalance)/1e18;
poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
}
// trustless listing pool creation. always creates unofficial pool
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-23
元数据:{'block索引': 23, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function listNewToken (address _token, uint _price,
uint256 vcashAmount,
uint256 tokenAmount,
address to) external returns(uint _pid, uint256 liquidity) {
_pid = _createPool(_token, _price, PoolStatus.LISTED);
liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);
}
// add liquidity pair to a pool. allows adding vcash.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-24
元数据:{'block索引': 24, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityPair (address _token,
uint256 vcashAmount,
uint256 tokenAmount,
address to) external returns(uint256 liquidity) {
liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);
}
// add liquidity pair to a pool. allows adding vcash.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-25
元数据:{'block索引': 25, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['AddLiquidity']", '返回值': ''}
函数切片:
function _addLiquidityPair (address _token,
uint256 vcashAmount,
uint256 tokenAmount,
address from,
address to) internal lockToken(_token) returns(uint256 liquidity) {
require (tokenAmount>0, "MonoX:BAD_AMOUNT");
require(tokenPoolStatus[_token]==1, "MonoX:NO_POOL");
// (uint256 poolValue, , ,) = getPool(_token);
PoolInfo memory pool = pools[_token];
IMonoXPool monoXPoolLocal = monoXPool;
uint256 poolValue = pool.price.mul(pool.tokenBalance)/1e18;
poolValue = poolValue.add(pool.vcashCredit).sub(pool.vcashDebt);
_mintFee(pool.pid, pool.lastPoolValue, poolValue);
tokenAmount = transferAndCheck(from,address(monoXPoolLocal),_token,tokenAmount);
if(vcashAmount>0){
vCash.safeTransferFrom(msg.sender, address(monoXPoolLocal), vcashAmount);
vCash.burn(address(monoXPool), vcashAmount);
}
// this is to avoid stack too deep
{
uint256 _totalSupply = monoXPoolLocal.totalSupplyOf(pool.pid);
uint256 liquidityVcashValue = vcashAmount.add(tokenAmount.mul(pool.price)/1e18);
if(_totalSupply==0){
liquidityVcashValue = liquidityVcashValue/1e6; // so $1m would get you 1e18
liquidity = liquidityVcashValue.sub(MINIMUM_LIQUIDITY);
// sorry, oz doesn't allow minting to address(0)
monoXPoolLocal.mintLp(feeTo, pool.pid, MINIMUM_LIQUIDITY, pool.status == PoolStatus.LISTED);
}else{
liquidity = _totalSupply.mul(liquidityVcashValue).div(poolValue);
}
}
monoXPoolLocal.mintLp(to, pool.pid, liquidity, pool.status == PoolStatus.LISTED);
_syncPoolInfo(_token, vcashAmount, 0);
emit AddLiquidity(to,
pool.pid,
_token,
liquidity,
vcashAmount, tokenAmount, pool.price);
}
// add one-sided liquidity to a pool. no vcash
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addLiquidity-26
元数据:{'block索引': 26, '函数名': 'addLiquidity', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint256 _amount, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity (address _token, uint256 _amount, address to) external returns(uint256 liquidity)  {
liquidity = _addLiquidityPair(_token, 0, _amount, msg.sender, to);
}
// add one-sided ETH liquidity to a pool. no vcash
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-addLiquidityETH-27
元数据:{'block索引': 27, '函数名': 'addLiquidityETH', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidityETH (address to) external payable returns(uint256 liquidity)  {
MonoXLibrary.safeTransferETH(address(monoXPool), msg.value);
monoXPool.depositWETH(msg.value);
liquidity = _addLiquidityPair(WETH, 0, msg.value, address(this), to);
}
// updates pool vcash balance, token balance and last pool value.
// this function requires others to do the input validation
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_syncPoolInfo-28
元数据:{'block索引': 28, '函数名': '_syncPoolInfo', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address _token, uint256 vcashIn, uint256 vcashOut', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _syncPoolInfo (address _token, uint256 vcashIn, uint256 vcashOut) internal {
// PoolInfo memory pool = pools[_token];
uint256 tokenPoolPrice = pools[_token].price;
(uint256 vcashCredit, uint256 vcashDebt) = _updateVcashBalance(_token, vcashIn, vcashOut);
uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));
uint256 tokenBalanceVcashValue = tokenPoolPrice.mul(tokenReserve)/1e18;
require(tokenReserve <= uint112(-1));
pools[_token].tokenBalance = uint112(tokenReserve);
// poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
pools[_token].lastPoolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);
}
// view func for removing liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-29
元数据:{'block索引': 29, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _removeLiquidity (address _token, uint256 liquidity,
address to) view public returns(
uint256 poolValue, uint256 liquidityIn, uint256 vcashOut, uint256 tokenOut) {
require (liquidity>0, "MonoX:BAD_AMOUNT");
uint256 tokenBalanceVcashValue;
uint256 vcashCredit;
uint256 vcashDebt;
PoolInfo memory pool = pools[_token];
IMonoXPool monoXPoolLocal = monoXPool;
uint256 lastAdded = monoXPoolLocal.liquidityLastAddedOf(pool.pid, msg.sender);
require((lastAdded + (pool.status == PoolStatus.OFFICIAL ? 4 hours : pool.status == PoolStatus.LISTED ? 24 hours : 0)) <= block.timestamp, "MonoX:WRONG_TIME"); // Users are not allowed to remove liquidity right after adding
address topLPHolder = monoXPoolLocal.topLPHolderOf(pool.pid);
require(pool.status != PoolStatus.LISTED || msg.sender != topLPHolder || pool.createdAt + 90 days < block.timestamp, "MonoX:TOP_HOLDER & WRONG_TIME"); // largest LP holder is not allowed to remove LP within 90 days after pool creation
(poolValue, tokenBalanceVcashValue, vcashCredit, vcashDebt) = getPool(_token);
uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);
liquidityIn = monoXPool.balanceOf(to, pool.pid)>liquidity?liquidity:monoXPool.balanceOf(to, pool.pid);
uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));
if(tokenReserve < pool.tokenBalance){
tokenBalanceVcashValue = tokenReserve.mul(pool.price)/1e18;
}
if(vcashDebt>0){
tokenReserve = (tokenBalanceVcashValue.sub(vcashDebt)).mul(1e18).div(pool.price);
}
// if vcashCredit==0, vcashOut will be 0 as well
vcashOut = liquidityIn.mul(vcashCredit).div(_totalSupply);
tokenOut = liquidityIn.mul(tokenReserve).div(_totalSupply);
}
// actually removes liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-30
元数据:{'block索引': 30, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {
(vcashOut, tokenOut) = _removeLiquidityHelper (_token, liquidity, to, minVcashOut, minTokenOut, false);
}
// actually removes liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-31
元数据:{'block索引': 31, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['RemoveLiquidity']", '返回值': ''}
函数切片:
function _removeLiquidityHelper (address _token, uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut,
bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut)  {
require (tokenPoolStatus[_token]==1, "MonoX:NO_TOKEN");
PoolInfo memory pool = pools[_token];
uint256 poolValue;
uint256 liquidityIn;
(poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to);
_mintFee(pool.pid, pool.lastPoolValue, poolValue);
require (vcashOut>=minVcashOut, "MonoX:INSUFF_vCash");
require (tokenOut>=minTokenOut, "MonoX:INSUFF_TOKEN");
if (vcashOut>0){
vCash.mint(to, vcashOut);
}
if (!isETH) {
monoXPool.safeTransferERC20Token(_token, to, tokenOut);
} else {
monoXPool.withdrawWETH(tokenOut);
monoXPool.safeTransferETH(to, tokenOut);
}
monoXPool.burn(to, pool.pid, liquidityIn);
_syncPoolInfo(_token, 0, vcashOut);
emit RemoveLiquidity(to,
pool.pid,
_token,
liquidityIn,
vcashOut, tokenOut, pool.price);
}
// actually removes ETH liquidity
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-32
元数据:{'block索引': 32, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityETH (uint256 liquidity, address to,
uint256 minVcashOut,
uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {
(vcashOut, tokenOut) = _removeLiquidityHelper (WETH, liquidity, to, minVcashOut, minTokenOut, true);
}
// util func to compute new price
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-33
元数据:{'block索引': 33, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getNewPrice (uint256 originalPrice, uint256 reserve,
uint256 delta, uint256 deltaBlocks, TxType txType) pure internal returns(uint256 price) {
if(txType==TxType.SELL) {
// no risk of being div by 0
price = originalPrice.mul(reserve)/(reserve.add(delta));
}else{ // BUY
price = originalPrice.mul(reserve).div(reserve.sub(delta));
}
}
// util func to compute new price
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-_getAvgPrice-34
元数据:{'block索引': 34, '函数名': '_getAvgPrice', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'uint256 originalPrice, uint256 newPrice', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _getAvgPrice (uint256 originalPrice, uint256 newPrice) pure internal returns(uint256 price) {
price = originalPrice.add(newPrice.mul(4))/5;
}
// standard swap interface implementing uniswap router V2
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-35
元数据:{'block索引': 35, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactETHForToken(
address tokenOut,
uint amountOutMin,
address to,
uint deadline
) external virtual payable ensure(deadline) returns (uint amountOut) {
uint amountIn = msg.value;
MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);
monoXPool.depositWETH(amountIn);
amountOut = swapIn(WETH, tokenOut, address(this), to, amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-36
元数据:{'block索引': 36, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokenForETH(
address tokenIn,
uint amountIn,
uint amountOutMin,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountOut) {
IMonoXPool monoXPoolLocal = monoXPool;
amountOut = swapIn(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
monoXPoolLocal.withdrawWETH(amountOut);
monoXPoolLocal.safeTransferETH(to, amountOut);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-37
元数据:{'block索引': 37, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapETHForExactToken(
address tokenOut,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual payable ensure(deadline) returns (uint amountIn) {
uint amountSentIn = msg.value;
( , , amountIn, ) = getAmountIn(WETH, tokenOut, amountOut);
MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);
monoXPool.depositWETH(amountIn);
amountIn = swapOut(WETH, tokenOut, address(this), to, amountOut);
require(amountIn <= amountSentIn, 'MonoX:BAD_INPUT');
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
if (amountSentIn > amountIn) {
MonoXLibrary.safeTransferETH(msg.sender, amountSentIn.sub(amountIn));
}
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-38
元数据:{'block索引': 38, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokenForExactETH(
address tokenIn,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountIn) {
IMonoXPool monoXPoolLocal = monoXPool;
amountIn = swapOut(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountOut);
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
monoXPoolLocal.withdrawWETH(amountOut);
monoXPoolLocal.safeTransferETH(to, amountOut);
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-39
元数据:{'block索引': 39, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapExactTokenForToken(
address tokenIn,
address tokenOut,
uint amountIn,
uint amountOutMin,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountOut) {
amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn);
require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-40
元数据:{'block索引': 40, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swapTokenForExactToken(
address tokenIn,
address tokenOut,
uint amountInMax,
uint amountOut,
address to,
uint deadline
) external virtual ensure(deadline) returns (uint amountIn) {
amountIn = swapOut(tokenIn, tokenOut, msg.sender, to, amountOut);
require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');
}
// util func to manipulate vcash balance
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-41
元数据:{'block索引': 41, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _updateVcashBalance (address _token,
uint _vcashIn, uint _vcashOut) internal returns (uint _vcashCredit, uint _vcashDebt) {
if(_vcashIn>_vcashOut){
_vcashIn = _vcashIn - _vcashOut;
_vcashOut = 0;
}else{
_vcashOut = _vcashOut - _vcashIn;
_vcashIn = 0;
}
// PoolInfo memory _pool = pools[_token];
uint _poolVcashCredit = pools[_token].vcashCredit;
uint _poolVcashDebt = pools[_token].vcashDebt;
PoolStatus _poolStatus = pools[_token].status;
if(_vcashOut>0){
(_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceSub(
_poolVcashCredit, _poolVcashDebt, _vcashOut);
require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));
pools[_token].vcashCredit = uint112(_vcashCredit);
pools[_token].vcashDebt = uint112(_vcashDebt);
}
if(_vcashIn>0){
(_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceAdd(
_poolVcashCredit, _poolVcashDebt, _vcashIn);
require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));
pools[_token].vcashCredit = uint112(_vcashCredit);
pools[_token].vcashDebt = uint112(_vcashDebt);
}
if(_poolStatus == PoolStatus.LISTED){
require (_vcashDebt<=tokenInsurance[_token], "MonoX:INSUFF_vCash");
}
}
// updates pool token balance and price.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-42
元数据:{'block索引': 42, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _updateTokenInfo (address _token, uint256 _price,
uint256 _vcashIn, uint256 _vcashOut, uint256 _ETHDebt) internal {
uint256 _balance = IERC20(_token).balanceOf(address(monoXPool));
_balance = _balance.sub(_ETHDebt);
require(pools[_token].status!=PoolStatus.PAUSED,"MonoX:PAUSED");
require(_balance <= uint112(-1));
(uint initialPoolValue, , ,) = getPool(_token);
pools[_token].tokenBalance = uint112(_balance);
pools[_token].price = _price;
// record last trade's block number in mapping: lastTradedBlock
lastTradedBlock[_token] = block.number;
_updateVcashBalance(_token, _vcashIn, _vcashOut);
(uint poolValue, , ,) = getPool(_token);
require(initialPoolValue <= poolValue || poolValue >= poolSizeMinLimit,
"MonoX:MIN_POOL_SIZE");
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-43
元数据:{'block索引': 43, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function directSwapAllowed(uint tokenInPoolPrice,uint tokenOutPoolPrice,
uint tokenInPoolTokenBalance, uint tokenOutPoolTokenBalance, PoolStatus status, bool getsAmountOut) internal pure returns(bool){
uint tokenInValue  = tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18);
uint tokenOutValue = tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18);
bool priceExists   = getsAmountOut?tokenInPoolPrice>0:tokenOutPoolPrice>0;
// only if it's official pool with similar size
return priceExists&&status==PoolStatus.OFFICIAL&&tokenInValue>0&&tokenOutValue>0&&
((tokenInValue/tokenOutValue)+(tokenOutValue/tokenInValue)==1);
}
// view func to compute amount required for tokenIn to get fixed amount of tokenOut
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-44
元数据:{'block索引': 44, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountIn(address tokenIn, address tokenOut,
uint256 amountOut) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice,
uint256 amountIn, uint256 tradeVcashValue) {
require(amountOut > 0, 'MonoX:INSUFF_INPUT');
uint256 amountOutWithFee = amountOut.mul(1e5).div(1e5 - fees);
address vcashAddress = address(vCash);
uint tokenOutPoolPrice = pools[tokenOut].price;
uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;
if(tokenOut==vcashAddress){
tradeVcashValue = amountOutWithFee;
tokenOutPrice = 1e18;
}else{
require (tokenPoolStatus[tokenOut]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenOutPool = pools[tokenOut];
PoolStatus tokenOutPoolStatus = pools[tokenOut].status;
require (tokenOutPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance,
amountOutWithFee, 0, TxType.BUY);
tradeVcashValue = _getAvgPrice(tokenOutPoolPrice, tokenOutPrice).mul(amountOutWithFee)/1e18;
}
if(tokenIn==vcashAddress){
amountIn = tradeVcashValue;
tokenInPrice = 1e18;
}else{
require (tokenPoolStatus[tokenIn]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenInPool = pools[tokenIn];
PoolStatus tokenInPoolStatus = pools[tokenIn].status;
uint tokenInPoolPrice = pools[tokenIn].price;
uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;
require (tokenInPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
amountIn = tradeVcashValue.add(tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18));
amountIn = tradeVcashValue.mul(tokenInPoolTokenBalance).div(amountIn);
bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenInPoolStatus,false);
// assuming p1*p2 = k, equivalent to uniswap's x * y = k
uint directSwapTokenInPrice = allowDirectSwap?tokenOutPoolPrice.mul(tokenInPoolPrice).div(tokenOutPrice):1;
tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance,
amountIn, 0, TxType.SELL);
tokenInPrice = directSwapTokenInPrice > tokenInPrice?directSwapTokenInPrice:tokenInPrice;
amountIn = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenInPoolPrice, tokenInPrice));
}
}
// view func to compute amount required for tokenOut to get fixed amount of tokenIn
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-45
元数据:{'block索引': 45, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAmountOut(address tokenIn, address tokenOut,
uint256 amountIn) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice,
uint256 amountOut, uint256 tradeVcashValue) {
require(amountIn > 0, 'MonoX:INSUFF_INPUT');
uint256 amountInWithFee = amountIn.mul(1e5-fees)/1e5;
address vcashAddress = address(vCash);
uint tokenInPoolPrice = pools[tokenIn].price;
uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;
if(tokenIn==vcashAddress){
tradeVcashValue = amountInWithFee;
tokenInPrice = 1e18;
}else{
require (tokenPoolStatus[tokenIn]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenInPool = pools[tokenIn];
PoolStatus tokenInPoolStatus = pools[tokenIn].status;
require (tokenInPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance,
amountInWithFee, 0, TxType.SELL);
tradeVcashValue = _getAvgPrice(tokenInPoolPrice, tokenInPrice).mul(amountInWithFee)/1e18;
}
if(tokenOut==vcashAddress){
amountOut = tradeVcashValue;
tokenOutPrice = 1e18;
}else{
require (tokenPoolStatus[tokenOut]==1, "MonoX:NO_POOL");
// PoolInfo memory tokenOutPool = pools[tokenOut];
PoolStatus tokenOutPoolStatus = pools[tokenOut].status;
uint tokenOutPoolPrice = pools[tokenOut].price;
uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;
require (tokenOutPoolStatus != PoolStatus.UNLISTED, "MonoX:POOL_UNLST");
amountOut = tradeVcashValue.add(tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18));
amountOut = tradeVcashValue.mul(tokenOutPoolTokenBalance).div(amountOut);
bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenOutPoolStatus,true);
// assuming p1*p2 = k, equivalent to uniswap's x * y = k
uint directSwapTokenOutPrice = allowDirectSwap?tokenInPoolPrice.mul(tokenOutPoolPrice).div(tokenInPrice):uint(-1);
// prevent the attack where user can use a small pool to update price in a much larger pool
tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance,
amountOut, 0, TxType.BUY);
tokenOutPrice = directSwapTokenOutPrice < tokenOutPrice?directSwapTokenOutPrice:tokenOutPrice;
amountOut = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenOutPoolPrice, tokenOutPrice));
}
}
// swap from tokenIn to tokenOut with fixed tokenIn amount.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-46
元数据:{'block索引': 46, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Swap']", '返回值': ''}
函数切片:
function swapIn (address tokenIn, address tokenOut, address from, address to,
uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {
address monoXPoolLocal = address(monoXPool);
amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);
// uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;
uint256 tokenInPrice;
uint256 tokenOutPrice;
uint256 tradeVcashValue;
(tokenInPrice, tokenOutPrice, amountOut, tradeVcashValue) = getAmountOut(tokenIn, tokenOut, amountIn);
uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;
// trading in
if(tokenIn==address(vCash)){
vCash.burn(monoXPoolLocal, amountIn);
// all fees go to the other side
oneSideFeesInVcash = oneSideFeesInVcash.mul(2);
}else{
_updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);
}
// trading out
if(tokenOut==address(vCash)){
vCash.mint(to, amountOut);
}else{
if (to != monoXPoolLocal) {
IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);
}
_updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0,
to == monoXPoolLocal ? amountOut : 0);
}
if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){
_internalRebalance(tokenIn);
}
emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);
}
// swap from tokenIn to tokenOut with fixed tokenOut amount.
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-47
元数据:{'block索引': 47, '函数名': '', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Swap']", '返回值': ''}
函数切片:
function swapOut (address tokenIn, address tokenOut, address from, address to,
uint256 amountOut) internal lockToken(tokenIn) returns(uint256 amountIn)  {
uint256 tokenInPrice;
uint256 tokenOutPrice;
uint256 tradeVcashValue;
(tokenInPrice, tokenOutPrice, amountIn, tradeVcashValue) = getAmountIn(tokenIn, tokenOut, amountOut);
address monoXPoolLocal = address(monoXPool);
amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);
// uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;
uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;
// trading in
if(tokenIn==address(vCash)){
vCash.burn(monoXPoolLocal, amountIn);
// all fees go to buy side
oneSideFeesInVcash = oneSideFeesInVcash.mul(2);
}else {
_updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);
}
// trading out
if(tokenOut==address(vCash)){
vCash.mint(to, amountOut);
// all fees go to sell side
_updateVcashBalance(tokenIn, oneSideFeesInVcash, 0);
}else{
if (to != monoXPoolLocal) {
IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);
}
_updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0,
to == monoXPoolLocal ? amountOut:0 );
}
if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){
_internalRebalance(tokenIn);
}
emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);
}
// function balanceOf(address account, uint256 id) public view returns (uint256) {
//   return monoXPool.balanceOf(account, id);
// }
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-getConfig-48
元数据:{'block索引': 48, '函数名': 'getConfig', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getConfig() public view returns (address _vCash, address _weth, address _feeTo, uint16 _fees, uint16 _devFee) {
_vCash = address(vCash);
_weth = WETH;
_feeTo = feeTo;
_fees = fees;
_devFee = devFee;
}
------------------------------------------------
函数切片ID: MonoX.sol-Monoswap.sol-transferAndCheck-49
元数据:{'block索引': 49, '函数名': 'transferAndCheck', '函数所属的合约或接口': 'MonoX.sol-Monoswap.sol', '参数': 'address from,address to,address _token,uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferAndCheck(address from,address to,address _token,uint amount) internal returns (uint256){
if(from == address(this)){
return amount; // if it's ETH
}
// if it's not ETH
if(tokenStatus[_token]==2){
IERC20(_token).safeTransferFrom(from, to, amount);
return amount;
}else{
uint256 balanceIn0 = IERC20(_token).balanceOf(to);
IERC20(_token).safeTransferFrom(from, to, amount);
uint256 balanceIn1 = IERC20(_token).balanceOf(to);
return balanceIn1.sub(balanceIn0);
}
}
}
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-ModelInterface.sol-underlyingBalanceInModel-0
元数据:{'block索引': 0, '函数名': 'underlyingBalanceInModel', '函数所属的合约或接口': 'Punk Protocol-2.sol-ModelInterface.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function underlyingBalanceInModel() external view returns ( uint256 );
/**
* @dev Returns the sum of the invested amount and the amount held by the model without investing.
*/
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-ModelInterface.sol-underlyingBalanceWithInvestment-1
元数据:{'block索引': 1, '函数名': 'underlyingBalanceWithInvestment', '函数所属的合约或接口': 'Punk Protocol-2.sol-ModelInterface.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function underlyingBalanceWithInvestment() external view returns ( uint256 );
/**
* @dev Invest uninvested amounts according to your strategy.
*
* Emits a {Invest} event.
*/
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-ModelInterface.sol-invest-2
元数据:{'block索引': 2, '函数名': 'invest', '函数所属的合约或接口': 'Punk Protocol-2.sol-ModelInterface.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function invest() external;
/**
* @dev After withdrawing all the invested amount, all the balance is transferred to 'Forge'.
*
* IMPORTANT: Must use the "OnlyForge" Modifier from "ModelStorage.sol".
*
* Emits a {Withdraw} event.
*/
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-ModelInterface.sol-withdrawAllToForge-3
元数据:{'block索引': 3, '函数名': 'withdrawAllToForge', '函数所属的合约或接口': 'Punk Protocol-2.sol-ModelInterface.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdrawAllToForge() external;
/**
* @dev After withdrawing 'amount', send it to 'Forge'.
*
* IMPORTANT: Must use the "OnlyForge" Modifier from "ModelStorage.sol".
*
* Emits a {Withdraw} event.
*/
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-ModelInterface.sol-withdrawToForge-4
元数据:{'block索引': 4, '函数名': 'withdrawToForge', '函数所属的合约或接口': 'Punk Protocol-2.sol-ModelInterface.sol', '参数': 'uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdrawToForge( uint256 amount ) external;
/**
* @dev After withdrawing 'amount', send it to 'to'.
*
* IMPORTANT: Must use the "OnlyForge" Modifier from "ModelStorage.sol".
*
* Emits a {Withdraw} event.
*/
------------------------------------------------
函数切片ID: Punk Protocol-2.sol-ModelInterface.sol-withdrawTo-5
元数据:{'block索引': 5, '函数名': 'withdrawTo', '函数所属的合约或接口': 'Punk Protocol-2.sol-ModelInterface.sol', '参数': 'uint256 amount, address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function withdrawTo( uint256 amount, address to )  external;
}
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getA-0
元数据:{'block索引': 0, '函数名': 'getA', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getA() external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getAllowlist-1
元数据:{'block索引': 1, '函数名': 'getAllowlist', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getAllowlist() external view returns (IAllowlist);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getToken-2
元数据:{'block索引': 2, '函数名': 'getToken', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint8 index', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getToken(uint8 index) external view returns (IERC20);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getTokenIndex-3
元数据:{'block索引': 3, '函数名': 'getTokenIndex', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'address tokenAddress', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getTokenIndex(address tokenAddress) external view returns (uint8);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getTokenBalance-4
元数据:{'block索引': 4, '函数名': 'getTokenBalance', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint8 index', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getTokenBalance(uint8 index) external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-getVirtualPrice-5
元数据:{'block索引': 5, '函数名': 'getVirtualPrice', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getVirtualPrice() external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-isGuarded-6
元数据:{'block索引': 6, '函数名': 'isGuarded', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isGuarded() external view returns (bool);
// min return calculation functions
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-7
元数据:{'block索引': 7, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateSwap(
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx
) external view returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-calculateTokenAmount-8
元数据:{'block索引': 8, '函数名': 'calculateTokenAmount', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint256[] calldata amounts, bool deposit', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateTokenAmount(uint256[] calldata amounts, bool deposit)
external
view
returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-calculateRemoveLiquidity-9
元数据:{'block索引': 9, '函数名': 'calculateRemoveLiquidity', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': 'uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateRemoveLiquidity(uint256 amount)
external
view
returns (uint256[] memory);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-10
元数据:{'block索引': 10, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function calculateRemoveLiquidityOneToken(
uint256 tokenAmount,
uint8 tokenIndex
) external view returns (uint256 availableTokenAmount);
// state modifying functions
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-11
元数据:{'block索引': 11, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(
IERC20[] memory pooledTokens,
uint8[] memory decimals,
string memory lpTokenName,
string memory lpTokenSymbol,
uint256 a,
uint256 fee,
uint256 adminFee,
address lpTokenTargetAddress
) external;
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-12
元数据:{'block索引': 12, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swap(
uint8 tokenIndexFrom,
uint8 tokenIndexTo,
uint256 dx,
uint256 minDy,
uint256 deadline
) external returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-13
元数据:{'block索引': 13, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function addLiquidity(
uint256[] calldata amounts,
uint256 minToMint,
uint256 deadline
) external returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-14
元数据:{'block索引': 14, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidity(
uint256 amount,
uint256[] calldata minAmounts,
uint256 deadline
) external returns (uint256[] memory);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-15
元数据:{'block索引': 15, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityOneToken(
uint256 tokenAmount,
uint8 tokenIndex,
uint256 minAmount,
uint256 deadline
) external returns (uint256);
------------------------------------------------
函数切片ID: Saddle Finance.sol-ISwap.sol-16
元数据:{'block索引': 16, '函数名': '', '函数所属的合约或接口': 'Saddle Finance.sol-ISwap.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function removeLiquidityImbalance(
uint256[] calldata amounts,
uint256 maxBurnAmount,
uint256 deadline
) external returns (uint256);
}
------------------------------------------------
函数切片ID: XCarnival.sol-IERC1155Upgradeable.sol-balanceOf-0
元数据:{'block索引': 0, '函数名': 'balanceOf', '函数所属的合约或接口': 'XCarnival.sol-IERC1155Upgradeable.sol', '参数': 'address account, uint256 id', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address account, uint256 id) external view returns (uint256);
/**
* @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
*
* Requirements:
*
* - `accounts` and `ids` must have the same length.
*/
------------------------------------------------
函数切片ID: XCarnival.sol-IERC1155Upgradeable.sol-balanceOfBatch-1
元数据:{'block索引': 1, '函数名': 'balanceOfBatch', '函数所属的合约或接口': 'XCarnival.sol-IERC1155Upgradeable.sol', '参数': 'address[] calldata accounts, uint256[] calldata ids', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
external
view
returns (uint256[] memory);
/**
* @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
*
* Emits an {ApprovalForAll} event.
*
* Requirements:
*
* - `operator` cannot be the caller.
*/
------------------------------------------------
函数切片ID: XCarnival.sol-IERC1155Upgradeable.sol-setApprovalForAll-2
元数据:{'block索引': 2, '函数名': 'setApprovalForAll', '函数所属的合约或接口': 'XCarnival.sol-IERC1155Upgradeable.sol', '参数': 'address operator, bool approved', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setApprovalForAll(address operator, bool approved) external;
/**
* @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
*
* See {setApprovalForAll}.
*/
------------------------------------------------
函数切片ID: XCarnival.sol-IERC1155Upgradeable.sol-isApprovedForAll-3
元数据:{'block索引': 3, '函数名': 'isApprovedForAll', '函数所属的合约或接口': 'XCarnival.sol-IERC1155Upgradeable.sol', '参数': 'address account, address operator', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isApprovedForAll(address account, address operator) external view returns (bool);
/**
* @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
*
* Emits a {TransferSingle} event.
*
* Requirements:
*
* - `to` cannot be the zero address.
* - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.
* - `from` must have a balance of tokens of type `id` of at least `amount`.
* - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
* acceptance magic value.
*/
------------------------------------------------
函数切片ID: XCarnival.sol-IERC1155Upgradeable.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'XCarnival.sol-IERC1155Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferFrom(
address from,
address to,
uint256 id,
uint256 amount,
bytes calldata data
) external;
/**
* @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
*
* Emits a {TransferBatch} event.
*
* Requirements:
*
* - `ids` and `amounts` must have the same length.
* - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
* acceptance magic value.
*/
------------------------------------------------
函数切片ID: XCarnival.sol-IERC1155Upgradeable.sol-5
元数据:{'block索引': 5, '函数名': '', '函数所属的合约或接口': 'XCarnival.sol-IERC1155Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeBatchTransferFrom(
address from,
address to,
uint256[] calldata ids,
uint256[] calldata amounts,
bytes calldata data
) external;
}
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-isNativeAsset-0
元数据:{'block索引': 0, '函数名': 'isNativeAsset', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': 'address assetId', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isNativeAsset(address assetId) internal pure returns (bool) {
return assetId == NATIVE_ASSETID;
}
/**
* @notice Gets the balance of the inheriting contract for the given asset
* @param assetId The asset identifier to get the balance of
* @return Balance held by contracts using this library
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-getOwnBalance-1
元数据:{'block索引': 1, '函数名': 'getOwnBalance', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': 'address assetId', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getOwnBalance(address assetId) internal view returns (uint256) {
return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));
}
/**
* @notice Transfers ether from the inheriting contract to a given
*         recipient
* @param recipient Address to send ether to
* @param amount Amount to send to given recipient
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-transferNativeAsset-2
元数据:{'block索引': 2, '函数名': 'transferNativeAsset', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': 'address payable recipient, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferNativeAsset(address payable recipient, uint256 amount) internal {
// solhint-disable-next-line avoid-low-level-calls
(bool success, ) = recipient.call{ value: amount }("");
require(success, "#TNA:028");
}
/**
* @notice Gives approval for another address to spend tokens
* @param assetId Token address to transfer
* @param spender Address to give spend approval to
* @param amount Amount to approve for spending
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approveERC20(
IERC20 assetId,
address spender,
uint256 amount
) internal {
if (isNativeAsset(address(assetId))) return;
uint256 allowance = assetId.allowance(address(this), spender);
if (allowance < amount) {
if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);
SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);
}
}
/**
* @notice Transfers tokens from the inheriting contract to a given
*         recipient
* @param assetId Token address to transfer
* @param recipient Address to send ether to
* @param amount Amount to send to given recipient
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferERC20(
address assetId,
address recipient,
uint256 amount
) internal {
SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);
}
/**
* @notice Transfers tokens from a sender to a given recipient
* @param assetId Token address to transfer
* @param from Address of sender/owner
* @param to Address of recipient/spender
* @param amount Amount to transfer from owner to spender
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-5
元数据:{'block索引': 5, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFromERC20(
address assetId,
address from,
address to,
uint256 amount
) internal {
SafeERC20.safeTransferFrom(IERC20(assetId), from, to, amount);
}
/**
* @notice Increases the allowance of a token to a spender
* @param assetId Token address of asset to increase allowance of
* @param spender Account whos allowance is increased
* @param amount Amount to increase allowance by
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-6
元数据:{'block索引': 6, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function increaseERC20Allowance(
address assetId,
address spender,
uint256 amount
) internal {
require(!isNativeAsset(assetId), "#IA:034");
SafeERC20.safeIncreaseAllowance(IERC20(assetId), spender, amount);
}
/**
* @notice Decreases the allowance of a token to a spender
* @param assetId Token address of asset to decrease allowance of
* @param spender Account whos allowance is decreased
* @param amount Amount to decrease allowance by
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-7
元数据:{'block索引': 7, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decreaseERC20Allowance(
address assetId,
address spender,
uint256 amount
) internal {
require(!isNativeAsset(assetId), "#DA:034");
SafeERC20.safeDecreaseAllowance(IERC20(assetId), spender, amount);
}
/**
* @notice Wrapper function to transfer a given asset (native or erc20) to
*         some recipient. Should handle all non-compliant return value
*         tokens as well by using the SafeERC20 contract by open zeppelin.
* @param assetId Asset id for transfer (address(0) for native asset,
*                token address for erc20s)
* @param recipient Address to send asset to
* @param amount Amount to send to given recipient
*/
------------------------------------------------
函数切片ID: Li.Fi.sol-LibAsset.sol-8
元数据:{'block索引': 8, '函数名': '', '函数所属的合约或接口': 'Li.Fi.sol-LibAsset.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferAsset(
address assetId,
address payable recipient,
uint256 amount
) internal {
isNativeAsset(assetId) ? transferNativeAsset(recipient, amount) : transferERC20(assetId, recipient, amount);
}
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-_mint-0
元数据:{'block索引': 0, '函数名': '_mint', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _mint(address to, uint value) internal {
totalSupply = totalSupply.add(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(address(0), to, value);
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-_burn-1
元数据:{'block索引': 1, '函数名': '_burn', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address from, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _burn(address from, uint value) internal {
balanceOf[from] = balanceOf[from].sub(value);
totalSupply = totalSupply.sub(value);
emit Transfer(from, address(0), value);
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-_approve-2
元数据:{'block索引': 2, '函数名': '_approve', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address owner, address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Approval']", '返回值': ''}
函数切片:
function _approve(address owner, address spender, uint value) private {
allowance[owner][spender] = value;
emit Approval(owner, spender, value);
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-_transfer-3
元数据:{'block索引': 3, '函数名': '_transfer', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _transfer(address from, address to, uint value) private {
balanceOf[from] = balanceOf[from].sub(value);
balanceOf[to] = balanceOf[to].add(value);
emit Transfer(from, to, value);
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-approve-4
元数据:{'block索引': 4, '函数名': 'approve', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool) {
_approve(msg.sender, spender, value);
return true;
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-transfer-5
元数据:{'block索引': 5, '函数名': 'transfer', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool) {
_transfer(msg.sender, to, value);
return true;
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-transferFrom-6
元数据:{'block索引': 6, '函数名': 'transferFrom', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool) {
if (allowance[from][msg.sender] != uint(-1)) {
allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
}
_transfer(from, to, value);
return true;
}
------------------------------------------------
函数切片ID: Uranium Finance-2.sol-UraniumERC20.sol-permit-7
元数据:{'block索引': 7, '函数名': 'permit', '函数所属的合约或接口': 'Uranium Finance-2.sol-UraniumERC20.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
require(deadline >= block.timestamp, 'UraniumSwap: EXPIRED');
bytes32 digest = keccak256(
abi.encodePacked(
'\x19\x01',
DOMAIN_SEPARATOR,
keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
)
);
address recoveredAddress = ecrecover(digest, v, r, s);
require(recoveredAddress != address(0) && recoveredAddress == owner, 'UraniumSwap: INVALID_SIGNATURE');
_approve(owner, spender, value);
}
}
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-isContract-0
元数据:{'block索引': 0, '函数名': 'isContract', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address account', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function isContract(address account) internal view returns (bool) {
// This method relies on extcodesize, which returns 0 for contracts in
// construction, since the code is only stored at the end of the
// constructor execution.
uint256 size;
// solhint-disable-next-line no-inline-assembly
assembly { size := extcodesize(account) }
return size > 0;
}
/**
* @dev Replacement for Solidity's `transfer`: sends `amount` wei to
* `recipient`, forwarding all available gas and reverting on errors.
*
* https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
* of certain opcodes, possibly making contracts go over the 2300 gas limit
* imposed by `transfer`, making them unable to receive funds via
* `transfer`. {sendValue} removes this limitation.
*
* https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
*
* IMPORTANT: because control is transferred to `recipient`, care must be
* taken to not create reentrancy vulnerabilities. Consider using
* {ReentrancyGuard} or the
* https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-sendValue-1
元数据:{'block索引': 1, '函数名': 'sendValue', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address payable recipient, uint256 amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sendValue(address payable recipient, uint256 amount) internal {
require(address(this).balance >= amount, "Address: insufficient balance");
// solhint-disable-next-line avoid-low-level-calls, avoid-call-value
(bool success, ) = recipient.call{ value: amount }("");
require(success, "Address: unable to send value, recipient may have reverted");
}
/**
* @dev Performs a Solidity function call using a low level `call`. A
* plain`call` is an unsafe replacement for a function call: use this
* function instead.
*
* If `target` reverts with a revert reason, it is bubbled up by this
* function (like regular Solidity function calls).
*
* Returns the raw returned data. To convert to the expected return value,
* use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
*
* Requirements:
*
* - `target` must be a contract.
* - calling `target` with `data` must not revert.
*
* _Available since v3.1._
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-functionCall-2
元数据:{'block索引': 2, '函数名': 'functionCall', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address target, bytes memory data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function functionCall(address target, bytes memory data) internal returns (bytes memory) {
return functionCall(target, data, "Address: low-level call failed");
}
/**
* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
* `errorMessage` as a fallback revert reason when `target` reverts.
*
* _Available since v3.1._
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-functionCall-3
元数据:{'block索引': 3, '函数名': 'functionCall', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address target, bytes memory data, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
return functionCallWithValue(target, data, 0, errorMessage);
}
/**
* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
* but also transferring `value` wei to `target`.
*
* Requirements:
*
* - the calling contract must have an ETH balance of at least `value`.
* - the called Solidity function must be `payable`.
*
* _Available since v3.1._
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-functionCallWithValue-4
元数据:{'block索引': 4, '函数名': 'functionCallWithValue', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address target, bytes memory data, uint256 value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
}
/**
* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
* with `errorMessage` as a fallback revert reason when `target` reverts.
*
* _Available since v3.1._
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-functionCallWithValue-5
元数据:{'block索引': 5, '函数名': 'functionCallWithValue', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address target, bytes memory data, uint256 value, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
require(address(this).balance >= value, "Address: insufficient balance for call");
require(isContract(target), "Address: call to non-contract");
// solhint-disable-next-line avoid-low-level-calls
(bool success, bytes memory returndata) = target.call{ value: value }(data);
return _verifyCallResult(success, returndata, errorMessage);
}
/**
* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
* but performing a static call.
*
* _Available since v3.3._
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-functionStaticCall-6
元数据:{'block索引': 6, '函数名': 'functionStaticCall', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address target, bytes memory data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
return functionStaticCall(target, data, "Address: low-level static call failed");
}
/**
* @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
* but performing a static call.
*
* _Available since v3.3._
*/
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-functionStaticCall-7
元数据:{'block索引': 7, '函数名': 'functionStaticCall', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'address target, bytes memory data, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
require(isContract(target), "Address: static call to non-contract");
// solhint-disable-next-line avoid-low-level-calls
(bool success, bytes memory returndata) = target.staticcall(data);
return _verifyCallResult(success, returndata, errorMessage);
}
------------------------------------------------
函数切片ID: SushiSwap.sol-Address.sol-_verifyCallResult-8
元数据:{'block索引': 8, '函数名': '_verifyCallResult', '函数所属的合约或接口': 'SushiSwap.sol-Address.sol', '参数': 'bool success, bytes memory returndata, string memory errorMessage', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
if (success) {
return returndata;
} else {
// Look for revert reason and bubble it up if present
if (returndata.length > 0) {
// The easiest way to bubble the revert reason is using memory via assembly
// solhint-disable-next-line no-inline-assembly
assembly {
let returndata_size := mload(returndata)
revert(add(32, returndata), returndata_size)
}
} else {
revert(errorMessage);
}
}
}
}
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeTo-0
元数据:{'block索引': 0, '函数名': 'feeTo', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeTo() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeToSetter-1
元数据:{'block索引': 1, '函数名': 'feeToSetter', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeToSetter() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-feeAmount-2
元数据:{'block索引': 2, '函数名': 'feeAmount', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function feeAmount() external view returns (uint16);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-owner-3
元数据:{'block索引': 3, '函数名': 'owner', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function owner() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-getPair-4
元数据:{'block索引': 4, '函数名': 'getPair', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getPair(address tokenA, address tokenB) external view returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-allPairs-5
元数据:{'block索引': 5, '函数名': 'allPairs', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'uint', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairs(uint) external view returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-allPairsLength-6
元数据:{'block索引': 6, '函数名': 'allPairsLength', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allPairsLength() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-createPair-7
元数据:{'block索引': 7, '函数名': 'createPair', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address tokenA, address tokenB', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function createPair(address tokenA, address tokenB) external returns (address pair);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-setFeeTo-8
元数据:{'block索引': 8, '函数名': 'setFeeTo', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeTo(address) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumFactory.sol-setFeeToSetter-9
元数据:{'block索引': 9, '函数名': 'setFeeToSetter', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumFactory.sol', '参数': 'address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setFeeToSetter(address) external;
}
------------------------------------------------
函数切片ID: Nmbplatform.sol-SafeERC20.sol-0
元数据:{'block索引': 0, '函数名': '', '函数所属的合约或接口': 'Nmbplatform.sol-SafeERC20.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransfer(
IERC20 token,
address to,
uint256 value
) internal {
_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
}
------------------------------------------------
函数切片ID: Nmbplatform.sol-SafeERC20.sol-1
元数据:{'block索引': 1, '函数名': '', '函数所属的合约或接口': 'Nmbplatform.sol-SafeERC20.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeTransferFrom(
IERC20 token,
address from,
address to,
uint256 value
) internal {
_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
}
/**
* @dev Deprecated. This function has issues similar to the ones found in
* {IERC20-approve}, and its usage is discouraged.
*
* Whenever possible, use {safeIncreaseAllowance} and
* {safeDecreaseAllowance} instead.
*/
------------------------------------------------
函数切片ID: Nmbplatform.sol-SafeERC20.sol-2
元数据:{'block索引': 2, '函数名': '', '函数所属的合约或接口': 'Nmbplatform.sol-SafeERC20.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeApprove(
IERC20 token,
address spender,
uint256 value
) internal {
// safeApprove should only be called when setting an initial allowance,
// or when resetting it to zero. To increase and decrease it, use
// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
require(
(value == 0) || (token.allowance(address(this), spender) == 0),
"SafeERC20: approve from non-zero to non-zero allowance"
);
_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
}
------------------------------------------------
函数切片ID: Nmbplatform.sol-SafeERC20.sol-3
元数据:{'block索引': 3, '函数名': '', '函数所属的合约或接口': 'Nmbplatform.sol-SafeERC20.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeIncreaseAllowance(
IERC20 token,
address spender,
uint256 value
) internal {
uint256 newAllowance = token.allowance(address(this), spender) + value;
_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
}
------------------------------------------------
函数切片ID: Nmbplatform.sol-SafeERC20.sol-4
元数据:{'block索引': 4, '函数名': '', '函数所属的合约或接口': 'Nmbplatform.sol-SafeERC20.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safeDecreaseAllowance(
IERC20 token,
address spender,
uint256 value
) internal {
unchecked {
uint256 oldAllowance = token.allowance(address(this), spender);
require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
uint256 newAllowance = oldAllowance - value;
_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
}
}
------------------------------------------------
函数切片ID: Nmbplatform.sol-SafeERC20.sol-5
元数据:{'block索引': 5, '函数名': '', '函数所属的合约或接口': 'Nmbplatform.sol-SafeERC20.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function safePermit(
IERC20Permit token,
address owner,
address spender,
uint256 value,
uint256 deadline,
uint8 v,
bytes32 r,
bytes32 s
) internal {
uint256 nonceBefore = token.nonces(owner);
token.permit(owner, spender, value, deadline, v, r, s);
uint256 nonceAfter = token.nonces(owner);
require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
}
/**
* @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
* on the return value: the return value is optional (but if data is returned, it must not be false).
* @param token The token targeted by the call.
* @param data The call data (encoded using abi.encode or one of its variants).
*/
------------------------------------------------
函数切片ID: Nmbplatform.sol-SafeERC20.sol-_callOptionalReturn-6
元数据:{'block索引': 6, '函数名': '_callOptionalReturn', '函数所属的合约或接口': 'Nmbplatform.sol-SafeERC20.sol', '参数': 'IERC20 token, bytes memory data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _callOptionalReturn(IERC20 token, bytes memory data) private {
// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
// the target address contains contract code and also asserts for success in the low-level call.
bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
if (returndata.length > 0) {
// Return data is optional
require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
}
}
}
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-0
元数据:{'block索引': 0, '函数名': '', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function __BEP20__init(
string memory name,
string memory symbol,
uint8 decimals
) internal initializer {
__Ownable_init();
_name = name;
_symbol = symbol;
_decimals = decimals;
}
/**
* @dev Returns the bep token owner.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-getOwner-1
元数据:{'block索引': 1, '函数名': 'getOwner', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getOwner() external view override returns (address) {
return owner();
}
/**
* @dev Returns the token decimals.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-decimals-2
元数据:{'block索引': 2, '函数名': 'decimals', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decimals() external view override returns (uint8) {
return _decimals;
}
/**
* @dev Returns the token symbol.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-symbol-3
元数据:{'block索引': 3, '函数名': 'symbol', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function symbol() external view override returns (string memory) {
return _symbol;
}
/**
* @dev Returns the token name.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-name-4
元数据:{'block索引': 4, '函数名': 'name', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function name() external view override returns (string memory) {
return _name;
}
/**
* @dev See {BEP20-totalSupply}.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-totalSupply-5
元数据:{'block索引': 5, '函数名': 'totalSupply', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() public view override returns (uint) {
return _totalSupply;
}
/**
* @dev See {BEP20-balanceOf}.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-balanceOf-6
元数据:{'block索引': 6, '函数名': 'balanceOf', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address account', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address account) public view override returns (uint) {
return _balances[account];
}
/**
* @dev See {BEP20-transfer}.
*
* Requirements:
*
* - `recipient` cannot be the zero address.
* - the caller must have a balance of at least `amount`.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-transfer-7
元数据:{'block索引': 7, '函数名': 'transfer', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address recipient, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address recipient, uint amount) external override returns (bool) {
_transfer(_msgSender(), recipient, amount);
return true;
}
/**
* @dev See {BEP20-allowance}.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-allowance-8
元数据:{'block索引': 8, '函数名': 'allowance', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address owner, address spender', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allowance(address owner, address spender) public view override returns (uint) {
return _allowances[owner][spender];
}
/**
* @dev See {BEP20-approve}.
*
* Requirements:
*
* - `spender` cannot be the zero address.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-approve-9
元数据:{'block索引': 9, '函数名': 'approve', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address spender, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint amount) public override returns (bool) {
_approve(_msgSender(), spender, amount);
return true;
}
/**
* @dev See {BEP20-transferFrom}.
*
* Emits an {Approval} event indicating the updated allowance. This is not
* required by the EIP. See the note at the beginning of {BEP20};
*
* Requirements:
* - `sender` and `recipient` cannot be the zero address.
* - `sender` must have a balance of at least `amount`.
* - the caller must have allowance for `sender`'s tokens of at least
* `amount`.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-10
元数据:{'block索引': 10, '函数名': '', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(
address sender,
address recipient,
uint amount
) external override returns (bool) {
_transfer(sender, recipient, amount);
_approve(
sender,
_msgSender(),
_allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance")
);
return true;
}
/**
* @dev Atomically increases the allowance granted to `spender` by the caller.
*
* This is an alternative to {approve} that can be used as a mitigation for
* problems described in {BEP20-approve}.
*
* Emits an {Approval} event indicating the updated allowance.
*
* Requirements:
*
* - `spender` cannot be the zero address.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-increaseAllowance-11
元数据:{'block索引': 11, '函数名': 'increaseAllowance', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address spender, uint addedValue', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function increaseAllowance(address spender, uint addedValue) public returns (bool) {
_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
return true;
}
/**
* @dev Atomically decreases the allowance granted to `spender` by the caller.
*
* This is an alternative to {approve} that can be used as a mitigation for
* problems described in {BEP20-approve}.
*
* Emits an {Approval} event indicating the updated allowance.
*
* Requirements:
*
* - `spender` cannot be the zero address.
* - `spender` must have allowance for the caller of at least
* `subtractedValue`.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-decreaseAllowance-12
元数据:{'block索引': 12, '函数名': 'decreaseAllowance', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address spender, uint subtractedValue', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {
_approve(
_msgSender(),
spender,
_allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero")
);
return true;
}
/**
* @dev Burn `amount` tokens and decreasing the total supply.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-burn-13
元数据:{'block索引': 13, '函数名': 'burn', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn(uint amount) public returns (bool) {
_burn(_msgSender(), amount);
return true;
}
/**
* @dev Moves tokens `amount` from `sender` to `recipient`.
*
* This is internal function is equivalent to {transfer}, and can be used to
* e.g. implement automatic token fees, slashing mechanisms, etc.
*
* Emits a {Transfer} event.
*
* Requirements:
*
* - `sender` cannot be the zero address.
* - `recipient` cannot be the zero address.
* - `sender` must have a balance of at least `amount`.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-14
元数据:{'block索引': 14, '函数名': '', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _transfer(
address sender,
address recipient,
uint amount
) internal {
require(sender != address(0), "BEP20: transfer from the zero address");
require(recipient != address(0), "BEP20: transfer to the zero address");
_balances[sender] = _balances[sender].sub(amount, "BEP20: transfer amount exceeds balance");
_balances[recipient] = _balances[recipient].add(amount);
emit Transfer(sender, recipient, amount);
}
/** @dev Creates `amount` tokens and assigns them to `account`, increasing
* the total supply.
*
* Emits a {Transfer} event with `from` set to the zero address.
*
* Requirements
*
* - `to` cannot be the zero address.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-_mint-15
元数据:{'block索引': 15, '函数名': '_mint', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address account, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _mint(address account, uint amount) internal {
require(account != address(0), "BEP20: mint to the zero address");
_totalSupply = _totalSupply.add(amount);
_balances[account] = _balances[account].add(amount);
emit Transfer(address(0), account, amount);
}
/**
* @dev Destroys `amount` tokens from `account`, reducing the
* total supply.
*
* Emits a {Transfer} event with `to` set to the zero address.
*
* Requirements
*
* - `account` cannot be the zero address.
* - `account` must have at least `amount` tokens.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-_burn-16
元数据:{'block索引': 16, '函数名': '_burn', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address account, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Transfer']", '返回值': ''}
函数切片:
function _burn(address account, uint amount) internal {
require(account != address(0), "BEP20: burn from the zero address");
_balances[account] = _balances[account].sub(amount, "BEP20: burn amount exceeds balance");
_totalSupply = _totalSupply.sub(amount);
emit Transfer(account, address(0), amount);
}
/**
* @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.
*
* This is internal function is equivalent to `approve`, and can be used to
* e.g. set automatic allowances for certain subsystems, etc.
*
* Emits an {Approval} event.
*
* Requirements:
*
* - `owner` cannot be the zero address.
* - `spender` cannot be the zero address.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-17
元数据:{'block索引': 17, '函数名': '', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': "['Approval']", '返回值': ''}
函数切片:
function _approve(
address owner,
address spender,
uint amount
) internal {
require(owner != address(0), "BEP20: approve from the zero address");
require(spender != address(0), "BEP20: approve to the zero address");
_allowances[owner][spender] = amount;
emit Approval(owner, spender, amount);
}
/**
* @dev Destroys `amount` tokens from `account`.`amount` is then deducted
* from the caller's allowance.
*
* See {_burn} and {_approve}.
*/
------------------------------------------------
函数切片ID: Qubit Finance.sol-BEP20Upgradeable.sol-_burnFrom-18
元数据:{'block索引': 18, '函数名': '_burnFrom', '函数所属的合约或接口': 'Qubit Finance.sol-BEP20Upgradeable.sol', '参数': 'address account, uint amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function _burnFrom(address account, uint amount) internal {
_burn(account, amount);
_approve(
account,
_msgSender(),
_allowances[account][_msgSender()].sub(amount, "BEP20: burn amount exceeds allowance")
);
}
}
------------------------------------------------
函数切片ID: Cover Protocol.sol-Vesting.sol-vest-0
元数据:{'block索引': 0, '函数名': 'vest', '函数所属的合约或接口': 'Cover Protocol.sol-Vesting.sol', '参数': 'IERC20 token', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function vest(IERC20 token) external {
require(block.timestamp >= START_TIME, "Vesting: !started");
require(_total[msg.sender] > 0, "Vesting: not team");
uint256 toBeReleased = releasableAmount(msg.sender);
require(toBeReleased > 0, "Vesting: all vested");
_vested[msg.sender] = _vested[msg.sender].add(toBeReleased);
token.safeTransfer(msg.sender, toBeReleased);
}
------------------------------------------------
函数切片ID: Cover Protocol.sol-Vesting.sol-releasableAmount-1
元数据:{'block索引': 1, '函数名': 'releasableAmount', '函数所属的合约或接口': 'Cover Protocol.sol-Vesting.sol', '参数': 'address _addr', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function releasableAmount(address _addr) public view returns (uint256) {
return unlockedAmount(_addr).sub(_vested[_addr]);
}
------------------------------------------------
函数切片ID: Cover Protocol.sol-Vesting.sol-unlockedAmount-2
元数据:{'block索引': 2, '函数名': 'unlockedAmount', '函数所属的合约或接口': 'Cover Protocol.sol-Vesting.sol', '参数': 'address _addr', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function unlockedAmount(address _addr) public view returns (uint256) {
if (block.timestamp <= MIDDLE_TIME) {
uint256 duration = MIDDLE_TIME.sub(START_TIME);
uint256 firstHalf = _total[_addr].mul(2).div(3);
uint256 timePassed = block.timestamp.sub(START_TIME);
return firstHalf.mul(timePassed).div(duration);
} else if (block.timestamp > MIDDLE_TIME && block.timestamp <= END_TIME) {
uint256 duration = END_TIME.sub(MIDDLE_TIME);
uint256 firstHalf = _total[_addr].mul(2).div(3);
uint256 secondHalf = _total[_addr].div(3);
uint256 timePassed = block.timestamp.sub(MIDDLE_TIME);
return firstHalf.add(secondHalf.mul(timePassed).div(duration));
} else {
return _total[_addr];
}
}
}
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-name-0
元数据:{'block索引': 0, '函数名': 'name', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function name() external pure returns (string memory);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-symbol-1
元数据:{'block索引': 1, '函数名': 'symbol', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function symbol() external pure returns (string memory);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-decimals-2
元数据:{'block索引': 2, '函数名': 'decimals', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function decimals() external pure returns (uint8);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-totalSupply-3
元数据:{'block索引': 3, '函数名': 'totalSupply', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function totalSupply() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-balanceOf-4
元数据:{'block索引': 4, '函数名': 'balanceOf', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function balanceOf(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-allowance-5
元数据:{'block索引': 5, '函数名': 'allowance', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner, address spender', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function allowance(address owner, address spender) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-approve-6
元数据:{'block索引': 6, '函数名': 'approve', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address spender, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function approve(address spender, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-transfer-7
元数据:{'block索引': 7, '函数名': 'transfer', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transfer(address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-transferFrom-8
元数据:{'block索引': 8, '函数名': 'transferFrom', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address from, address to, uint value', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function transferFrom(address from, address to, uint value) external returns (bool);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-DOMAIN_SEPARATOR-9
元数据:{'block索引': 9, '函数名': 'DOMAIN_SEPARATOR', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function DOMAIN_SEPARATOR() external view returns (bytes32);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-PERMIT_TYPEHASH-10
元数据:{'block索引': 10, '函数名': 'PERMIT_TYPEHASH', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function PERMIT_TYPEHASH() external pure returns (bytes32);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-nonces-11
元数据:{'block索引': 11, '函数名': 'nonces', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function nonces(address owner) external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-permit-12
元数据:{'block索引': 12, '函数名': 'permit', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
event Mint(address indexed sender, uint amount0, uint amount1);
event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
event Swap(
address indexed sender,
uint amount0In,
uint amount1In,
uint amount0Out,
uint amount1Out,
address indexed to
);
event Sync(uint112 reserve0, uint112 reserve1);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-MINIMUM_LIQUIDITY-13
元数据:{'block索引': 13, '函数名': 'MINIMUM_LIQUIDITY', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function MINIMUM_LIQUIDITY() external pure returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-factory-14
元数据:{'block索引': 14, '函数名': 'factory', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function factory() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-token0-15
元数据:{'block索引': 15, '函数名': 'token0', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token0() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-token1-16
元数据:{'block索引': 16, '函数名': 'token1', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function token1() external view returns (address);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-getReserves-17
元数据:{'block索引': 17, '函数名': 'getReserves', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-price0CumulativeLast-18
元数据:{'block索引': 18, '函数名': 'price0CumulativeLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price0CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-price1CumulativeLast-19
元数据:{'block索引': 19, '函数名': 'price1CumulativeLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function price1CumulativeLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-kLast-20
元数据:{'block索引': 20, '函数名': 'kLast', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function kLast() external view returns (uint);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-mint-21
元数据:{'block索引': 21, '函数名': 'mint', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address to) external returns (uint liquidity);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-burn-22
元数据:{'block索引': 22, '函数名': 'burn', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function burn(address to) external returns (uint amount0, uint amount1);
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-swap-23
元数据:{'block索引': 23, '函数名': 'swap', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'uint amount0Out, uint amount1Out, address to, bytes calldata data', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-skim-24
元数据:{'block索引': 24, '函数名': 'skim', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address to', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function skim(address to) external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-sync-25
元数据:{'block索引': 25, '函数名': 'sync', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': '', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function sync() external;
------------------------------------------------
函数切片ID: Uranium Finance-4.sol-IUraniumPair.sol-initialize-26
元数据:{'block索引': 26, '函数名': 'initialize', '函数所属的合约或接口': 'Uranium Finance-4.sol-IUraniumPair.sol', '参数': 'address, address', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function initialize(address, address) external;
}
------------------------------------------------
函数切片ID: Beanstalk.sol-LibIncentive.sol-fracExp-0
元数据:{'block索引': 0, '函数名': 'fracExp', '函数所属的合约或接口': 'Beanstalk.sol-LibIncentive.sol', '参数': 'uint k, uint q, uint n, uint x', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function fracExp(uint k, uint q, uint n, uint x) internal pure returns (uint s) {
// The upper bound in which the binomial expansion is expected to converge
// Upon testing with a limit of n <= 300, x = 2, k = 100, q = 100 (parameters Beanstalk currently uses)
// we found this p optimizes for gas and error
uint p = log_two(n) + 1 + x * n / q;
// Solution for binomial expansion in Solidity.
// Motivation: https://ethereum.stackexchange.com/questions/10425
uint N = 1;
uint B = 1;
for (uint i = 0; i < p; ++i){
s += k * N / B / (q**i);
N = N * (n-i);
B = B * (i+1);
}
}
/// @notice log_two calculates the log2 solution in a gas efficient manner
/// Motivation: https://ethereum.stackexchange.com/questions/8086
/// @param x - the base to calculate log2 of
------------------------------------------------
函数切片ID: Beanstalk.sol-LibIncentive.sol-log_two-1
元数据:{'block索引': 1, '函数名': 'log_two', '函数所属的合约或接口': 'Beanstalk.sol-LibIncentive.sol', '参数': 'uint x', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function log_two(uint x) private pure returns (uint y) {
assembly {
let arg := x
x := sub(x,1)
x := or(x, div(x, 0x02))
x := or(x, div(x, 0x04))
x := or(x, div(x, 0x10))
x := or(x, div(x, 0x100))
x := or(x, div(x, 0x10000))
x := or(x, div(x, 0x100000000))
x := or(x, div(x, 0x10000000000000000))
x := or(x, div(x, 0x100000000000000000000000000000000))
x := add(x, 1)
let m := mload(0x40)
mstore(m, 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)
mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)
mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)
mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)
mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)
mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)
mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)
mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)
mstore(0x40, add(m, 0x100))
let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff
let shift := 0x100000000000000000000000000000000000000000000000000000000000000
let a := div(mul(x, magic), shift)
y := div(mload(add(m,sub(255,a))), shift)
y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))
}
}
}
------------------------------------------------
函数切片ID: Cover Protocol.sol-COVER.sol-mint-0
元数据:{'block索引': 0, '函数名': 'mint', '函数所属的合约或接口': 'Cover Protocol.sol-COVER.sol', '参数': 'address _account, uint256 _amount', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function mint(address _account, uint256 _amount) public {
require(isReleased, "$COVER: not released");
require(msg.sender == migrator || msg.sender == blacksmith, "$COVER: caller not migrator or Blacksmith");
_mint(_account, _amount);
}
------------------------------------------------
函数切片ID: Cover Protocol.sol-COVER.sol-setBlacksmith-1
元数据:{'block索引': 1, '函数名': 'setBlacksmith', '函数所属的合约或接口': 'Cover Protocol.sol-COVER.sol', '参数': 'address _newBlacksmith', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setBlacksmith(address _newBlacksmith) external returns (bool) {
require(msg.sender == blacksmith, "$COVER: caller not blacksmith");
blacksmith = _newBlacksmith;
return true;
}
------------------------------------------------
函数切片ID: Cover Protocol.sol-COVER.sol-setMigrator-2
元数据:{'block索引': 2, '函数名': 'setMigrator', '函数所属的合约或接口': 'Cover Protocol.sol-COVER.sol', '参数': 'address _newMigrator', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': True, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function setMigrator(address _newMigrator) external returns (bool) {
require(msg.sender == migrator, "$COVER: caller not migrator");
migrator = _newMigrator;
return true;
}
/// @notice called once and only by owner
------------------------------------------------
函数切片ID: Cover Protocol.sol-COVER.sol-release-3
元数据:{'block索引': 3, '函数名': 'release', '函数所属的合约或接口': 'Cover Protocol.sol-COVER.sol', '参数': 'address _treasury, address _vestor, address _blacksmith, address _migrator', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function release(address _treasury, address _vestor, address _blacksmith, address _migrator) external onlyOwner {
require(block.timestamp >= START_TIME, "$COVER: not started");
require(isReleased == false, "$COVER: already released");
isReleased = true;
blacksmith = _blacksmith;
migrator = _migrator;
_mint(_treasury, 950e18);
_mint(_vestor, 10800e18);
}
}
------------------------------------------------
函数切片ID: Rikkei Finance.sol-InterestRateModel.sol-getBorrowRate-0
元数据:{'block索引': 0, '函数名': 'getBorrowRate', '函数所属的合约或接口': 'Rikkei Finance.sol-InterestRateModel.sol', '参数': 'uint cash, uint borrows, uint reserves', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);
/**
* @notice Calculates the current supply interest rate per block
* @param cash The total amount of cash the market has
* @param borrows The total amount of borrows the market has outstanding
* @param reserves The total amount of reserves the market has
* @param reserveFactorMantissa The current reserve factor the market has
* @return The supply rate per block (as a percentage, and scaled by 1e18)
*/
------------------------------------------------
函数切片ID: Rikkei Finance.sol-InterestRateModel.sol-getSupplyRate-1
元数据:{'block索引': 1, '函数名': 'getSupplyRate', '函数所属的合约或接口': 'Rikkei Finance.sol-InterestRateModel.sol', '参数': 'uint cash, uint borrows, uint reserves, uint reserveFactorMantissa', '可见性': 'public', '外部调用': False, '是否使用防重入锁': False, '是否包含权限校验逻辑': False, '状态变量依赖': '', '状态可变性': '', '触发的事件': '[]', '返回值': ''}
函数切片:
function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);
}
------------------------------------------------
排名结果：
函数切片ID,分数
MonoX.sol-Monoswap.sol-mint-0,0.95
MonoX.sol-Monoswap.sol-burn-1,0.95
SushiSwap.sol-SushiMaker.sol-_swap-7,0.90
MonoX.sol-Monoswap.sol-46,0.90
MonoX.sol-Monoswap.sol-47,0.90
MonoX.sol-Monoswap.sol-setSynthPoolPrice-16,0.85
SushiSwap.sol-SushiMaker.sol-_convert-5,0.85
MonoX.sol-Monoswap.sol-_convertStep-6,0.85
MonoX.sol-Monoswap.sol-_updateTokenInfo-28,0.80
SushiSwap.sol-SushiMaker.sol-setBridge-1,0.75
MonoX.sol-Monoswap.sol-_syncPoolInfo-28,0.75
SushiSwap.sol-UniswapV2ERC20.sol-_mint-0,0.70
SushiSwap.sol-UniswapV2ERC20.sol-_burn-1,0.70
MonoX.sol-Monoswap.sol-42,0.70
MonoX.sol-Monoswap.sol-41,0.65
SushiSwap.sol-SushiMaker.sol-_convertStep-6,0.60
SushiSwap.sol-SushiMaker.sol-convert-3,0.55
SushiSwap.sol-SushiMaker.sol-convertMultiple-4,0.55
MonoX.sol-Monoswap.sol-44,0.50
MonoX.sol-Monoswap.sol-45,0.50