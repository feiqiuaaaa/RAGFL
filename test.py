import json

import chromadb

import llm

if __name__ == '__main__':
    # 调用大模型生成总结信息
    # system_prompt = llm.load_prompt("prompt/bug_summary_system_prompt")
    # variables = {
    #     'tx_hash': "{'fault': {'transaction_hash': ['0x90fb0c9976361f537330a5617a404045ffb3fef5972cf67b531386014eeae7a9']}, 'faultless': {'transaction_hash': ['0x7df39084b561ee2e7809e690f11e8e258dc65b6128399acbacf1f2433308de6a', '0xddd734c1f3e097d3d1cdd7d4c0ffae166b39992a1d055008bf6660b8c0b7582e', '0x5c1d151599bbacc19a09dfee888d3be2ccf3e2fa781679b9e0970e18b3300e44']}}",
    #     'tx_receipt': '0x90fb0c9976361f537330a5617a404045ffb3fef5972cf67b531386014eeae7a9: ### 基础信息\n1. **区块哈希**: 0xccd73a96e9ff96384a3f12bf15b986309560b5f737bc374089a0e76dbceb475e  \n2. **区块高度**: 0xb2f06b (十进制: 11726059)  \n3. **交易哈希**: 0x90fb0c9976361f537330a5617a404045ffb3fef5972cf67b531386014eeae7a9  \n4. **交易发起方 (from)**: 0x51841d9afe10fe55571bdb8f4af1060415003528  \n5. **交易接收方 (to)**: 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50  \n6. **Gas 消耗**: 0x609d5 (十进制: 395,733)  \n7. **Gas 单价**: 0x1bb4f3e600 (十进制: 119 Gwei)  \n8. **交易状态**: 0x1 (成功)  \n9. **交易类型**: 0x0 (传统交易)  \n\n---\n\n### 核心操作分析  \n1. **代币转移事件 (ERC20/ERC721)**  \n   - **合约地址**: 0x9a13867048e01c663ce8ce2fe0cdae69ff9f35e3  \n     - 从 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 转出 `0x240c8716` (十进制: 604,920,086) 代币至 `0x9a13867048e01c663ce8ce2fe0cdae69ff9f35e3`。  \n     - 从零地址铸造 `0xd16c` (十进制: 53,612) 代币至 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50`。  \n     - 销毁 `0x240c8716` 代币至零地址。  \n\n2. **WBTC 和 SUSHI 代币转移**  \n   - **WBTC (0x2260fac5e5542a773aa44fbcfedf7c193bc2c599)**:  \n     - 从 `0x9a13867048e01c663ce8ce2fe0cdae69ff9f35e3` 转出 `0x1489d90c` (十进制: 344,999,692) 至 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50`。  \n     - 从 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 转出 `0x1489d90c` 至 `0xceff51756c56ceffca006cd410b03ffc46dd3a58`。  \n   - **SUSHI (0x6b3595068778dd592e39a122f4f5a5cf09c90fe2)**:  \n     - 从 `0x795065dcc9f64b5614c407a6efdc400da6221fb0` 转出 `0x31ad666fcd1b8d1bb60` (十进制: 35,728,000,000,000,000,000,000) 至 `0x8798249c2e607446efb7ad49ec89dd1865ff4272`。  \n\n3. **WETH 转移**  \n   - **合约地址**: 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2  \n     - 从 `0xceff51756c56ceffca006cd410b03ffc46dd3a58` 转出 `0x47f2692ca1e6cea19` (十进制: 20,700,000,000,000,000,000) 至 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50`。  \n     - 从 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 转出 `0x47f4a25d3a5e4bc8e` (十进制: 20,700,000,000,000,000,000) 至 `0x795065dcc9f64b5614c407a6efdc400da6221fb0`。  \n\n4. **流动性池操作**  \n   - **合约地址**: 0xceff51756c56ceffca006cd410b03ffc46dd3a58  \n     - 触发 `Swap` 事件，涉及 WBTC 和 WETH 的交换。  \n   - **合约地址**: 0xf41e354eb138b328d56957b36b7f814826708724  \n     - 触发 `Swap` 事件，涉及 SUSHI 和 WETH 的交换。  \n\n---\n\n### 关键地址解析  \n1. **交易发起方**:  \n   - `0x51841d9afe10fe55571bdb8f4af1060415003528`  \n2. **核心合约**:  \n   - `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` (交易接收方，可能为路由或代理合约)  \n   - `0x9a13867048e01c663ce8ce2fe0cdae69ff9f35e3` (代币合约，涉及铸造/销毁)  \n3. **流动性池**:  \n   - `0xceff51756c56ceffca006cd410b03ffc46dd3a58` (WBTC/WETH 池)  \n   - `0xf41e354eb138b328d56957b36b7f814826708724` (SUSHI/WETH 池)  \n4. **代币地址**:  \n   - WBTC: `0x2260fac5e5542a773aa44fbcfedf7c193bc2c599`  \n   - WETH: `0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2`  \n   - SUSHI: `0x6b3595068778dd592e39a122f4f5a5cf09c90fe2`  \n\n---\n\n### 交易总结  \n该交易是一笔复杂的多合约交互操作，主要涉及：  \n1. **代币铸造与销毁**：通过 `0x9a13867048e01c663ce8ce2fe0cdae69ff9f35e3` 完成代币的铸造和销毁。  \n2. **代币交换**：通过多个流动性池（WBTC/WETH、SUSHI/WETH）完成代币交换，涉及大额 WETH 和 WBTC 转移。  \n3. **路由合约调用**：交易接收方 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 可能作为代理或路由合约协调多笔操作。  \n4. **高 Gas 消耗**：因涉及多次合约调用和代币转移，Gas 费用较高（约 0.047 ETH，按 119 Gwei 计算）。  \n\n交易状态为成功，所有操作均按预期执行。\n0x7df39084b561ee2e7809e690f11e8e258dc65b6128399acbacf1f2433308de6a: ### 基础信息  \n1. **区块哈希**：0xd73e34881d08472c9e6522eb6d0c43d091f3c4cc3deb6edc7fae1c3cf2af9a41  \n2. **区块高度**：0xb2f067（十进制：11718759）  \n3. **交易发送方（From）**：0xe5350e927b904fdb4d2af55c566e269bb3df1941  \n4. **交易接收方（To）**：0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50  \n5. **交易哈希**：0x7df39084b561ee2e7809e690f11e8e258dc65b6128399acbacf1f2433308de6a  \n6. **交易状态**：0x1（成功）  \n7. **Gas 消耗**：0x40b6d（十进制：265069）  \n8. **Gas 单价**：0x199c82cc00（十进制：110 Gwei）  \n9. **合约地址**：null（非合约创建交易）  \n\n---\n\n### 核心操作分析  \n1. **代币转移事件（ERC20 Transfer）**  \n   - **代币合约**：0xf55c33d94150d93c2cfb833bcca30be388b14964  \n   - **转出方**：0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50  \n   - **接收方**：0xf55c33d94150d93c2cfb833bcca30be388b14964  \n   - **数量**：0x356b7363e67aa6c79（十进制：3.86e18，具体代币需查合约）  \n\n2. **流动性操作（Uniswap/Sushiswap 相关）**  \n   - **路由合约**：0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50  \n   - **涉及代币**：  \n     - WETH（0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2）  \n     - 另一代币（0xa1faa113cbe53436df28ff0aee54275c13b40975）  \n   - **Swap 事件**：  \n     - 转入 WETH：0x17d4bf641c7eac4f（十进制：0.1718 ETH）  \n     - 转出代币：0x80925d17718e3b20c0（十进制：9.28e18）  \n\n3. **SUSHI 代币转移**  \n   - **代币合约**：0x6b3595068778dd592e39a122f4f5a5cf09c90fe2  \n   - **接收方**：0x8798249c2e607446efb7ad49ec89dd1865ff4272（SushiSwap 合约）  \n   - **数量**：0x20dd117cb30c81800f（十进制：2.36e18 SUSHI）  \n\n---\n\n### 关键地址解析  \n1. **交易发起者（From）**：0xe5350e927b904fdb4d2af55c566e269bb3df1941  \n   - 执行了复杂的代币交换和流动性操作。  \n2. **路由合约（To）**：0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50  \n   - 疑似 DeFi 聚合器或 DEX 路由合约，负责多步代币交换。  \n3. **代币合约**：  \n   - 0xf55c33d94150d93c2cfb833bcca30be388b14964（未知代币）  \n   - 0xa1faa113cbe53436df28ff0aee54275c13b40975（ALPHA 代币）  \n   - 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2（WETH）  \n   - 0x6b3595068778dd592e39a122f4f5a5cf09c90fe2（SUSHI 代币）  \n\n---\n\n### 交易总结  \n1. **交易类型**：复杂的 DeFi 操作，涉及代币交换（Swap）和流动性转移。  \n2. **主要动作**：  \n   - 通过路由合约将 WETH 兑换为 ALPHA 代币。  \n   - 转移 SUSHI 代币至 SushiSwap 合约。  \n   - 触发多次代币转账和流动性池事件。  \n3. **费用**：消耗 265069 Gas，Gas 单价 110 Gwei，总成本约 0.029 ETH。  \n4. **状态**：交易成功执行，所有事件日志完整记录。  \n\n（注：具体代币数量需结合合约小数位进一步换算。）\n0xddd734c1f3e097d3d1cdd7d4c0ffae166b39992a1d055008bf6660b8c0b7582e: ### 以太坊交易收据分析报告\n\n#### 基础信息\n- **交易哈希 (transactionHash)**: `0xddd734c1f3e097d3d1cdd7d4c0ffae166b39992a1d055008bf6660b8c0b7582e`\n- **区块哈希 (blockHash)**: `0xd73e34881d08472c9e6522eb6d0c43d091f3c4cc3deb6edc7fae1c3cf2af9a41`\n- **区块高度 (blockNumber)**: `0xb2f067` (十进制: 11,720,295)\n- **发送方 (from)**: `0xe5350e927b904fdb4d2af55c566e269bb3df1941`\n- **接收方 (to)**: `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50`\n- **Gas 消耗 (gasUsed)**: `0x57c64` (十进制: 359,524)\n- **累计 Gas 消耗 (cumulativeGasUsed)**: `0x1e30f0` (十进制: 1,978,608)\n- **Gas 价格 (effectiveGasPrice)**: `0x199c82cc00` (十进制: 110 Gwei)\n- **交易状态 (status)**: `0x1` (成功)\n- **交易类型 (type)**: `0x0` (普通交易)\n- **合约地址 (contractAddress)**: `null` (未部署新合约)\n\n#### 核心操作分析\n1. **代币转移**:\n   - **SNX 代币 (0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f)**:\n     - 从 `0xa1d7b2d891e3a1f9ef4bbc5be20630c2feb1c470` 转出 `0x89967eefd8b3663f8` (十进制: ~8.2e18) 至 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50`。\n   - **WETH 代币 (0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2)**:\n     - 从 `0xa1d7b2d891e3a1f9ef4bbc5be20630c2feb1c470` 转出 `0x19769d1d95144c0d` (十进制: ~1.1e17) 至 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50`。\n   - **SUSHI 代币 (0x6b3595068778dd592e39a122f4f5a5cf09c90fe2)**:\n     - 从 `0x795065dcc9f64b5614c407a6efdc400da6221fb0` 转出 `0x2322b4d780a8fa35e9` (十进制: ~2.5e21) 至 `0x8798249c2e607446efb7ad49ec89dd1865ff4272`。\n\n2. **流动性池操作**:\n   - 地址 `0xa1d7b2d891e3a1f9ef4bbc5be20630c2feb1c470` 触发了 `Swap` 事件，涉及代币转移和流动性调整。\n   - 地址 `0x795065dcc9f64b5614c407a6efdc400da6221fb0` 触发了 `Sync` 事件，更新了流动性池的储备量。\n\n3. **交易路由**:\n   - 通过 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 路由执行了多笔代币交换，最终将 SUSHI 代币发送至 `0x8798249c2e607446efb7ad49ec89dd1865ff4272`。\n\n#### 关键地址解析\n1. **发送方 (from)**: `0xe5350e927b904fdb4d2af55c566e269bb3df1941`\n   - 交易的发起者，可能是个人钱包或合约。\n\n2. **接收方 (to)**: `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50`\n   - 交易的主要执行合约，可能是一个去中心化交易所的路由器或聚合器。\n\n3. **流动性池**:\n   - `0xa1d7b2d891e3a1f9ef4bbc5be20630c2feb1c470`: 涉及 SNX 和 WETH 的交易对。\n   - `0x795065dcc9f64b5614c407a6efdc400da6221fb0`: 涉及 SUSHI 和 WETH 的交易对。\n\n4. **代币地址**:\n   - **SNX**: `0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f`\n   - **WETH**: `0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2`\n   - **SUSHI**: `0x6b3595068778dd592e39a122f4f5a5cf09c90fe2`\n\n#### 交易总结\n- 该交易通过 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 合约执行了一系列复杂的代币交换操作。\n- 主要涉及 SNX 和 WETH 的流动性池操作，最终将 SUSHI 代币发送至 `0x8798249c2e607446efb7ad49ec89dd1865ff4272`。\n- 交易成功完成，消耗了约 359,524 Gas，Gas 价格为 110 Gwei。\n- 交易的核心是代币交换和流动性池的调整，可能是一次去中心化交易所的套利或普通交易操作。\n0x5c1d151599bbacc19a09dfee888d3be2ccf3e2fa781679b9e0970e18b3300e44: ### 以太坊交易收据分析报告\n\n#### 1. 基础信息\n- **区块哈希(blockHash)**: `0xf21fb0fa90d13953cf10d4981c95d8936e6e3035d22cf11c3d415461a42461a2`\n- **区块高度(blockNumber)**: `0xb2f060` (十进制: 11,723,360)\n- **合约地址(contractAddress)**: `null` (无新合约创建)\n- **累计Gas消耗(cumulativeGasUsed)**: `0x5ce411` (十进制: 6,083,089)\n- **实际Gas单价(effectiveGasPrice)**: `0x14f46b0400` (十进制: 90 Gwei)\n- **交易发起方(from)**: `0xe2bb94210b41ce4c01b9b97f3ac62e728e472f9c`\n- **实际Gas消耗(gasUsed)**: `0x44f8c` (十进制: 282,508)\n- **交易目标(to)**: `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` (SushiSwap Router)\n- **交易哈希(transactionHash)**: `0x5c1d151599bbacc19a09dfee888d3be2ccf3e2fa781679b9e0970e18b3300e44`\n- **交易状态(status)**: `0x1` (成功)\n\n#### 2. 核心操作分析\n通过分析`logs`字段，该交易涉及以下关键操作：\n- **代币转移事件** (ERC-20 Transfer):\n  - 从 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 向 `0x397ff1542f962076d0bfe58ea045ffa2d347aca0` 转账 `0x31eb20c08ed5` (约 3.5亿 SUSHI)\n  - 从 `0x397ff1542f962076d0bfe58ea045ffa2d347aca0` 向 `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` 转账 `0x8b24fed9d7` (约 37.3 SUSHI)\n  - USDC (0xa0b869...) 和 WETH (0xc02aaa...) 在流动性池和路由合约间的多次交互\n\n- **流动性池操作**:\n  - 触发了 `0x397ff154...` (SUSHI/WETH 池) 的 `Sync` 事件，更新储备量\n  - 触发了 `0x795065dc...` (USDC/WETH 池) 的 `Swap` 事件，完成代币兑换\n\n#### 3. 关键地址解析\n- **路由合约**: `0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50` (SushiSwap Router)\n- **流动性池**:\n  - `0x397ff1542f962076d0bfe58ea045ffa2d347aca0` (SUSHI/WETH 池)\n  - `0x795065dcc9f64b5614c407a6efdc400da6221fb0` (USDC/WETH 池)\n- **代币合约**:\n  - `0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48` (USDC)\n  - `0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2` (WETH)\n  - `0x6b3595068778dd592e39a122f4f5a5cf09c90fe2` (SUSHI)\n\n#### 4. 交易总结\n该交易是一个典型的 **SushiSwap 多步兑换操作**，主要特征如下：\n1. 通过路由合约 `0xe11fc0...` 发起\n2. 涉及 SUSHI/WETH 和 USDC/WETH 两个流动性池的交互\n3. 最终完成 USDC 和 WETH 的兑换（具体金额见日志数据）\n4. 交易消耗 282,508 Gas，Gas 费用约为 0.025 ETH（按90 Gwei计算）\n5. 交易状态成功（status=1），所有操作均被有效执行\n',
    #     'tx_report': '', 'tx_graph': ''}
    # '0xE5350E927B904FdB4d2AF55C566E269BB3df1941: ```mermaid\n\n```\n\n0xe2Bb94210B41Ce4c01B9B97f3Ac62E728E472f9C: ```mermaid\n\n```\n\n0xE11fc0B43ab98Eb91e9836129d1ee7c3Bc95df50: ```mermaid\n    0xe2bb94210b41ce4c01b9b97f3ac62e728e472f9c["importance: 0.0020269659048622025"]\n    0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50["importance: 0.0025776935368456034"]\n    0xc077dd71187e08003fd91dd01f0a173d93c02184["importance: 0.0020269659048622025"]\n    0xed76187ad1e4f974229ac9a5aeb2aaa427c5a987["importance: 0.0020269659048622025"]\n    0x3d16451a4b73e778bfec126025ba79716a17e32d["importance: 0.0020206681052587364"]\n    0x88c70e2478a321a944815593de80bad83aa3dc4c["importance: 0.0020206681052587364"]\n    0x55b2b4c3bdef7ceb2ecc57a9b91e65b9878dbc81["importance: 0.0020206681052587364"]\n    0x426b3affbbe924e01575d5b3cb9dc640625bbb49["importance: 0.0019921875"]\n    0xcf5d9da2b167ab92d6737770adc70930d9ecc932["importance: 0.0020206681052587364"]\n    0xeda2f39d1fa6c7e3efdfd28ec8a38e808cb062e7["importance: 0.0020103956653225808"]\n    0x10025a49f69ba9445e9b81d0003b235ee629115f["importance: 0.0020206681052587364"]\n    0xd861853a9ce8695f910895490027551f6763db72["importance: 0.0020206681052587364"]\n    0x38bd96dcb6fa20b35ea7558795f0a668487a65ae["importance: 0.002068378324410679"]\n    0x7768ae94dfabbc8da553ebdeb81a788163676477["importance: 0.0020206681052587364"]\n    0xffc699711709ff26664cc5bb2f9fd3b3635e93ff["importance: 0.002074676124014145"]\n    0xcc8f949b05444e2d3803bc892d05ff99d4d18fcc["importance: 0.002053685218580567"]\n    0xe2bb94210b41ce4c01b9b97f3ac62e728e472f9c -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xe2bb94210b41ce4c01b9b97f3ac62e728e472f9c -->|""| 0xe2bb94210b41ce4c01b9b97f3ac62e728e472f9c\n    0xc077dd71187e08003fd91dd01f0a173d93c02184 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xed76187ad1e4f974229ac9a5aeb2aaa427c5a987 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xed76187ad1e4f974229ac9a5aeb2aaa427c5a987 -->|""| 0xed76187ad1e4f974229ac9a5aeb2aaa427c5a987\n    0x3d16451a4b73e778bfec126025ba79716a17e32d -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0x3d16451a4b73e778bfec126025ba79716a17e32d -->|""| 0x3d16451a4b73e778bfec126025ba79716a17e32d\n    0x88c70e2478a321a944815593de80bad83aa3dc4c -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0x55b2b4c3bdef7ceb2ecc57a9b91e65b9878dbc81 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0x426b3affbbe924e01575d5b3cb9dc640625bbb49 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0x426b3affbbe924e01575d5b3cb9dc640625bbb49 -->|""| 0x426b3affbbe924e01575d5b3cb9dc640625bbb49\n    0x426b3affbbe924e01575d5b3cb9dc640625bbb49 -->|""| 0xeda2f39d1fa6c7e3efdfd28ec8a38e808cb062e7\n    0xcf5d9da2b167ab92d6737770adc70930d9ecc932 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xeda2f39d1fa6c7e3efdfd28ec8a38e808cb062e7 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xeda2f39d1fa6c7e3efdfd28ec8a38e808cb062e7 -->|""| 0x426b3affbbe924e01575d5b3cb9dc640625bbb49\n    0x10025a49f69ba9445e9b81d0003b235ee629115f -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xd861853a9ce8695f910895490027551f6763db72 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xd861853a9ce8695f910895490027551f6763db72 -->|""| 0xd861853a9ce8695f910895490027551f6763db72\n    0x38bd96dcb6fa20b35ea7558795f0a668487a65ae -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0x38bd96dcb6fa20b35ea7558795f0a668487a65ae -->|""| 0x7768ae94dfabbc8da553ebdeb81a788163676477\n    0x38bd96dcb6fa20b35ea7558795f0a668487a65ae -->|""| 0x38bd96dcb6fa20b35ea7558795f0a668487a65ae\n    0x7768ae94dfabbc8da553ebdeb81a788163676477 -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0x7768ae94dfabbc8da553ebdeb81a788163676477 -->|""| 0x38bd96dcb6fa20b35ea7558795f0a668487a65ae\n    0xffc699711709ff26664cc5bb2f9fd3b3635e93ff -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xffc699711709ff26664cc5bb2f9fd3b3635e93ff -->|""| 0x7768ae94dfabbc8da553ebdeb81a788163676477\n    0xcc8f949b05444e2d3803bc892d05ff99d4d18fcc -->|""| 0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50\n    0xcc8f949b05444e2d3803bc892d05ff99d4d18fcc -->|""| 0xffc699711709ff26664cc5bb2f9fd3b3635e93ff\n    0xcc8f949b05444e2d3803bc892d05ff99d4d18fcc -->|""| 0xcc8f949b05444e2d3803bc892d05ff99d4d18fcc\n```\n\n0x51841D9AFe10fE55571bDB8f4Af1060415003528: ```mermaid\n    0x51841d9afe10fe55571bdb8f4af1060415003528["importance: 0.0008819781553398056"]\n    0x08abc2ac53c34a32d519d39c8005868078da61f2["importance: 0.0006189320388349514"]\n    0x5b0655f938a72052c46d2e94d206ccb6ff625a3a["importance: 0.0006225890214302627"]\n    0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0["importance: 0.0006225890214302627"]\n    0x72ce9c846789fdb6fc1f34ac4ad25dd9ef7031ef["importance: 0.0006225890214302627"]\n    0x51841d9afe10fe55571bdb8f4af1060415003528 -->|""| 0x08abc2ac53c34a32d519d39c8005868078da61f2\n    0x51841d9afe10fe55571bdb8f4af1060415003528 -->|""| 0x51841d9afe10fe55571bdb8f4af1060415003528\n    0x51841d9afe10fe55571bdb8f4af1060415003528 -->|""| 0x5b0655f938a72052c46d2e94d206ccb6ff625a3a\n    0x51841d9afe10fe55571bdb8f4af1060415003528 -->|""| 0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0\n    0x51841d9afe10fe55571bdb8f4af1060415003528 -->|""| 0x72ce9c846789fdb6fc1f34ac4ad25dd9ef7031ef\n```\n\n'
    # user_prompt = llm.load_prompt("prompt/bug_summary_user_prompt", variables)

    # bug_summary = llm.get_summary_from_llm(system_prompt, user_prompt)
    # if bug_summary[0] != 'stop':
    #     print(' error! message:' + bug_summary[0])
    # bug_summary = bug_summary[1]
    # print(bug_summary)

    client = chromadb.HttpClient(host='47.102.102.136', port=8000)
    contract_collection = client.get_or_create_collection("Contract")
    # collection.add(
    #     documents=[
    #         "// SPDX-License-Identifier: MIT\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n\n// P1 - P3: OK\npragma solidity 0.6.12;\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\n// T1 - T4: OK\ncontract BoringOwnableData {\n    // V1 - V5: OK\n    address public owner;\n    // V1 - V5: OK\n    address public pendingOwner;\n}\n\n// T1 - T4: OK\ncontract BoringOwnable is BoringOwnableData {\n    // E1: OK\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    // F1 - F9: OK\n    // C1 - C21: OK\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    // F1 - F9: OK\n    // C1 - C21: OK\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n        \n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    // M1 - M5: OK\n    // C1 - C21: OK\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}"
    #         ,
    #         "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\ncontract AnyswapFacet is ILiFi {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        if (_anyswapData.token != address(0)) {\n            address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        if (_anyswapData.token != address(0)) {\n            address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n\n        if (_anyswapData.token != address(0)) {\n            // Give Anyswap approval to bridge tokens\n            LibAsset.approveERC20(\n                IERC20(IAnyswapToken(_anyswapData.token).underlying()),\n                _anyswapData.router,\n                _anyswapData.amount\n            );\n\n            IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.amount,\n                _anyswapData.toChainId\n            );\n        } else {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n        }\n    }\n}\n"
    #         ,
    #         "/**\n * SPDX-License-Identifier: MIT\n**/\n\npragma solidity =0.7.6;\npragma experimental ABIEncoderV2;\n\nimport './Bip.sol';\n\n/**\n * @author Publius\n * @title Voting Booth\n**/\ncontract VotingBooth is Bip {\n\n    using SafeMath for uint256;\n    using LibSafeMath32 for uint32;\n    \n    event Vote(address indexed account, uint32 indexed bip, uint256 roots);\n\n    /**\n     * Voting\n    **/\n\n    function _vote(address account, uint32 bipId) internal {\n        recordVote(account, bipId);\n        placeVotedUntil(account, bipId);\n\n        emit Vote(account, bipId, balanceOfRoots(account));\n    }\n\n    function recordVote(address account, uint32 bipId) internal {\n        s.g.voted[bipId][account] = true;\n        s.g.bips[bipId].roots = s.g.bips[bipId].roots.add(balanceOfRoots(account));\n    }\n\n    function unrecordVote(address account, uint32 bipId) internal {\n        s.g.voted[bipId][account] = false;\n        s.g.bips[bipId].roots = s.g.bips[bipId].roots.sub(balanceOfRoots(account));\n    }\n\n    function placeVotedUntil(address account, uint32 bipId) internal {\n        uint32 newLock = startFor(bipId).add(periodFor(bipId));\n        if (newLock > s.a[account].votedUntil) {\n                s.a[account].votedUntil = newLock;\n        }\n    }\n\n    function updateVotedUntil(address account) internal {\n        uint32[] memory actives = activeBips();\n        uint32 lastSeason = 0;\n        for (uint256 i = 0; i < actives.length; i++) {\n            uint32 activeBip = actives[i];\n            if (s.g.voted[activeBip][account]) {\n                uint32 bipEnd = startFor(activeBip).add(periodFor(activeBip));\n                if (bipEnd > lastSeason) lastSeason = bipEnd;\n            }\n        }\n        s.a[account].votedUntil = lastSeason;\n    }\n\n}\n"
    #         ,
    #         "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"hardhat/console.sol\";\nimport \"./interfaces/IMonoXPool.sol\";\nimport './interfaces/IWETH.sol';\nimport './libraries/MonoXLibrary.sol';\n\ninterface IvCash is IERC20 {\n  function mint (address account, uint256 amount) external;\n\n  function burn (address account, uint256 amount) external;\n}\n\n\n/**\n * The Monoswap is ERC1155 contract does this and that...\n */\ncontract Monoswap is Initializable, OwnableUpgradeable {\n  using SafeMath for uint256;\n  using SafeMath for uint112;\n  using SafeERC20 for IERC20;\n  using SafeERC20 for IvCash;\n\n  IvCash vCash;\n  address WETH;\n  address feeTo;\n  uint16 fees; // over 1e5, 300 means 0.3%\n  uint16 devFee; // over 1e5, 50 means 0.05%\n\n  uint256 constant MINIMUM_LIQUIDITY=100;\n  \n  struct PoolInfo {\n    uint256 pid;\n    uint256 lastPoolValue;\n    address token;\n    PoolStatus status;\n    uint112 vcashDebt;\n    uint112 vcashCredit;\n    uint112 tokenBalance;\n    uint256 price; // over 1e18\n    uint256 createdAt; // timestamp\n  }\n\n  enum TxType {\n    SELL,\n    BUY\n  }\n\n  enum PoolStatus {\n    UNLISTED,\n    LISTED,\n    OFFICIAL,\n    SYNTHETIC,\n    PAUSED\n  }\n  \n  mapping (address => PoolInfo) public pools;\n  // tokenStatus is for token lock/transfer. exempt means no need to verify post tx\n  mapping (address => uint8) private tokenStatus; //0=unlocked, 1=locked, 2=exempt\n\n  // token poool status is to track if the pool has already been created for the token\n  mapping (address => uint8) public tokenPoolStatus; //0=undefined, 1=exists\n  \n  // negative vCash balance allowed for each token\n  mapping (address => uint) public tokenInsurance;\n\n  uint256 public poolSize;\n\n  uint private unlocked;\n  modifier lock() {\n    require(unlocked == 1, 'MonoX:LOCKED');\n    unlocked = 0;\n    _;\n    unlocked = 1;\n  }\n\n  modifier lockToken(address _token) { \n    uint8 originalState = tokenStatus[_token];\n    require(originalState!=1, 'MonoX:POOL_LOCKED');\n    if(originalState==0) {\n      tokenStatus[_token] = 1;\n    }\n    _;\n    if(originalState==0) {\n      tokenStatus[_token] = 0;\n    }\n  }\n\n  modifier ensure(uint deadline) {\n    require(deadline >= block.timestamp, 'MonoX:EXPIRED');\n    _;\n  }  \n\n  modifier onlyPriceAdjuster(){\n    require(priceAdjusterRole[msg.sender]==true,\"MonoX:BAD_ROLE\");\n    _;\n  }\n\n  event AddLiquidity(address indexed provider, \n    uint indexed pid,\n    address indexed token,\n    uint liquidityAmount,\n    uint vcashAmount, uint tokenAmount, uint price);\n\n  event RemoveLiquidity(address indexed provider, \n    uint indexed pid,\n    address indexed token,\n    uint liquidityAmount,\n    uint vcashAmount, uint tokenAmount, uint price);\n\n  event Swap(\n    address indexed user,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint amountIn,\n    uint amountOut,\n    uint swapVcashValue\n  );\n\n  // event PriceAdjusterChanged(\n  //   address indexed priceAdjuster,\n  //   bool added\n  // );\n\n  event PoolBalanced(\n    address _token,\n    uint vcashIn\n  );\n\n  event SyntheticPoolPriceChanged(\n    address _token,\n    uint price\n  );\n\n  event PoolStatusChanged(\n    address _token,\n    PoolStatus oldStatus,\n    PoolStatus newStatus\n  );\n\n  IMonoXPool public monoXPool;\n  \n  // mapping (token address => block number of the last trade)\n  mapping (address => uint) public lastTradedBlock; \n\n  uint256 constant MINIMUM_POOL_VALUE = 10000 * 1e18;\n  mapping (address=>bool) public priceAdjusterRole;\n\n  // ------------\n  uint public poolSizeMinLimit;\n\n\n  function initialize(IMonoXPool _monoXPool, IvCash _vcash) public initializer {\n    OwnableUpgradeable.__Ownable_init();\n    monoXPool = _monoXPool;\n    vCash = _vcash;\n    WETH = _monoXPool.WETH();\n    fees = 300;\n    devFee = 50;\n    poolSize = 0;\n    unlocked = 1;\n  }\n\n  // receive() external payable {\n  //   assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n  // }\n\n  function setFeeTo (address _feeTo) onlyOwner external {\n    feeTo = _feeTo;\n  }\n  \n  function setFees (uint16 _fees) onlyOwner external {\n    require(_fees<1e3);\n    fees = _fees;\n  }\n\n  function setDevFee (uint16 _devFee) onlyOwner external {\n    require(_devFee<1e3);\n    devFee = _devFee;\n  }\n\n  function setPoolSizeMinLimit(uint _poolSizeMinLimit) onlyOwner external {\n    poolSizeMinLimit = _poolSizeMinLimit;\n  }\n\n  function setTokenInsurance (address _token, uint _insurance) onlyOwner external {\n    tokenInsurance[_token] = _insurance;\n  }\n\n  // when safu, setting token status to 2 can achieve significant gas savings \n  function setTokenStatus (address _token, uint8 _status) onlyOwner external {\n    tokenStatus[_token] = _status;\n  } \n\n  // update status of a pool. onlyOwner.\n  function updatePoolStatus(address _token, PoolStatus _status) external onlyOwner {    \n\n    PoolStatus poolStatus = pools[_token].status;\n    if(poolStatus==PoolStatus.PAUSED){\n      require(block.number > lastTradedBlock[_token].add(6000), \"MonoX:TOO_EARLY\");\n    }\n    else{\n      // okay to pause an official pool, wait 6k blocks and then convert it to synthetic\n      require(_status!=PoolStatus.SYNTHETIC,\"MonoX:NO_SYNT\");\n    }\n      \n    emit PoolStatusChanged(_token, poolStatus,_status);\n    pools[_token].status = _status;\n\n    // unlisting a token allows creating a new pool of the same token. \n    // should move it to PAUSED if the goal is to blacklist the token forever\n    if(_status==PoolStatus.UNLISTED) {\n      tokenPoolStatus[_token] = 0;\n    }\n  }\n  \n  /**\n    @dev update pools price if there were no active trading for the last 6000 blocks\n    @notice Only owner callable, new price can neither be 0 nor be equal to old one\n    @param _token pool identifider (token address)\n    @param _newPrice new price in wei (uint112)\n   */\n  function updatePoolPrice(address _token, uint _newPrice) external onlyOwner {\n    require(_newPrice > 0, 'MonoX:0_PRICE');\n    require(tokenPoolStatus[_token] != 0, \"MonoX:NO_POOL\");\n\n    require(block.number > lastTradedBlock[_token].add(6000), \"MonoX:TOO_EARLY\");\n    pools[_token].price = _newPrice;\n    lastTradedBlock[_token] = block.number;\n  }\n\n  function updatePriceAdjuster(address account, bool _status) external onlyOwner{\n    priceAdjusterRole[account]=_status;\n    //emit PriceAdjusterChanged(account,_status);\n  }\n\n  function setSynthPoolPrice(address _token, uint price) external onlyPriceAdjuster {\n    require(pools[_token].status==PoolStatus.SYNTHETIC,\"MonoX:NOT_SYNT\");\n    require(price > 0, \"MonoX:ZERO_PRICE\");\n    pools[_token].price=price;\n    emit SyntheticPoolPriceChanged(_token,price);\n  }\n\n  function rebalancePool(address _token) external lockToken(_token) onlyOwner{\n      // // PoolInfo memory pool = pools[_token];\n      // uint poolPrice = pools[_token].price;\n      // require(vcashIn <= pools[_token].vcashDebt,\"MonoX:NO_CREDIT\");\n      // require((pools[_token].tokenBalance * poolPrice).div(1e18) >= vcashIn,\"MonoX:INSUF_TOKEN_VAL\");\n      // // uint rebalancedAmount = vcashIn.mul(1e18).div(pool.price);\n      // monoXPool.safeTransferERC20Token(_token, msg.sender, vcashIn.mul(1e18).div(poolPrice));\n      // _syncPoolInfo(_token, vcashIn, 0);\n      // emit PoolBalanced(_token, vcashIn);\n\n      _internalRebalance(_token);\n  }\n\n  // must be called from a method with token lock to prevent reentry\n  function _internalRebalance(address _token) internal {\n    uint poolPrice = pools[_token].price;\n    uint vcashIn = pools[_token].vcashDebt;\n    if(poolPrice.mul(pools[_token].tokenBalance) / 1e18 < vcashIn){\n      vcashIn = poolPrice.mul(pools[_token].tokenBalance) / 1e18;\n    }\n\n    if(tokenStatus[_token]==2){\n      monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));\n    }else{\n      uint256 balanceIn0 = IERC20(_token).balanceOf(address(monoXPool));\n      monoXPool.safeTransferERC20Token(_token, feeTo, vcashIn.mul(1e18).div(poolPrice));\n      uint256 balanceIn1 = IERC20(_token).balanceOf(address(monoXPool));\n      uint realAmount = balanceIn0.sub(balanceIn1);\n\n      vcashIn = realAmount.mul(poolPrice) / 1e18;\n    }\n    \n    _syncPoolInfo(_token, vcashIn, 0);\n    emit PoolBalanced(_token,vcashIn);\n  }\n\n  // creates a pool\n  function _createPool (address _token, uint _price, PoolStatus _status) lock internal returns(uint256 _pid)  {\n    require(tokenPoolStatus[_token]==0, \"MonoX:POOL_EXISTS\");\n    require (_token != address(vCash), \"MonoX:NO_vCash\");\n    _pid = poolSize;\n    pools[_token] = PoolInfo({\n      token: _token,\n      pid: _pid,\n      vcashCredit: 0,\n      vcashDebt: 0,\n      tokenBalance: 0,\n      lastPoolValue: 0,\n      status: _status,\n      price: _price,\n      createdAt: block.timestamp\n    });\n\n    poolSize = _pid.add(1);\n    tokenPoolStatus[_token]=1;\n\n    // initialze pool's lasttradingblocknumber as the block number on which the pool is created\n    lastTradedBlock[_token] = block.number;\n  }\n\n  // creates a pool with special status\n  function addSpecialToken (address _token, uint _price, PoolStatus _status) onlyOwner external returns(uint256 _pid)  {\n    _pid = _createPool(_token, _price, _status);\n  }\n\n  // internal func to pay contract owner\n  function _mintFee (uint256 pid, uint256 lastPoolValue, uint256 newPoolValue) internal {\n    \n    // dropping tx fees for now\n    return;\n    \n  }\n\n  // util func to get some basic pool info\n  function getPool (address _token) view public returns (uint256 poolValue, \n    uint256 tokenBalanceVcashValue, uint256 vcashCredit, uint256 vcashDebt) {\n    // PoolInfo memory pool = pools[_token];\n    vcashCredit = pools[_token].vcashCredit;\n    vcashDebt = pools[_token].vcashDebt;\n    tokenBalanceVcashValue = pools[_token].price.mul(pools[_token].tokenBalance)/1e18;\n\n    poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);\n  }\n\n  // trustless listing pool creation. always creates unofficial pool\n  function listNewToken (address _token, uint _price, \n    uint256 vcashAmount, \n    uint256 tokenAmount,\n    address to) external returns(uint _pid, uint256 liquidity) {\n    _pid = _createPool(_token, _price, PoolStatus.LISTED);\n    liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);\n  }\n\n  // add liquidity pair to a pool. allows adding vcash.\n  function addLiquidityPair (address _token, \n    uint256 vcashAmount, \n    uint256 tokenAmount,\n    address to) external returns(uint256 liquidity) {\n    liquidity = _addLiquidityPair(_token, vcashAmount, tokenAmount, msg.sender, to);\n  }\n\n    // add liquidity pair to a pool. allows adding vcash.\n  function _addLiquidityPair (address _token, \n    uint256 vcashAmount, \n    uint256 tokenAmount,\n    address from,\n    address to) internal lockToken(_token) returns(uint256 liquidity) {\n    require (tokenAmount>0, \"MonoX:BAD_AMOUNT\");\n\n    require(tokenPoolStatus[_token]==1, \"MonoX:NO_POOL\");\n    \n    // (uint256 poolValue, , ,) = getPool(_token);\n    PoolInfo memory pool = pools[_token];\n    IMonoXPool monoXPoolLocal = monoXPool;\n    \n    uint256 poolValue = pool.price.mul(pool.tokenBalance)/1e18;\n    poolValue = poolValue.add(pool.vcashCredit).sub(pool.vcashDebt);\n\n    \n    _mintFee(pool.pid, pool.lastPoolValue, poolValue);\n\n    tokenAmount = transferAndCheck(from,address(monoXPoolLocal),_token,tokenAmount);\n\n    if(vcashAmount>0){\n      vCash.safeTransferFrom(msg.sender, address(monoXPoolLocal), vcashAmount);\n      vCash.burn(address(monoXPool), vcashAmount);\n    }\n\n    // this is to avoid stack too deep\n    {\n      uint256 _totalSupply = monoXPoolLocal.totalSupplyOf(pool.pid);\n      uint256 liquidityVcashValue = vcashAmount.add(tokenAmount.mul(pool.price)/1e18);\n\n      if(_totalSupply==0){\n        liquidityVcashValue = liquidityVcashValue/1e6; // so $1m would get you 1e18\n        liquidity = liquidityVcashValue.sub(MINIMUM_LIQUIDITY);\n        // sorry, oz doesn't allow minting to address(0)\n        monoXPoolLocal.mintLp(feeTo, pool.pid, MINIMUM_LIQUIDITY, pool.status == PoolStatus.LISTED); \n      }else{\n        liquidity = _totalSupply.mul(liquidityVcashValue).div(poolValue);\n      }\n    }\n    \n    monoXPoolLocal.mintLp(to, pool.pid, liquidity, pool.status == PoolStatus.LISTED);\n    _syncPoolInfo(_token, vcashAmount, 0);\n\n    emit AddLiquidity(to, \n    pool.pid,\n    _token,\n    liquidity, \n    vcashAmount, tokenAmount, pool.price);\n  }\n  \n  // add one-sided liquidity to a pool. no vcash\n  function addLiquidity (address _token, uint256 _amount, address to) external returns(uint256 liquidity)  {\n    liquidity = _addLiquidityPair(_token, 0, _amount, msg.sender, to);\n  }  \n\n  // add one-sided ETH liquidity to a pool. no vcash\n  function addLiquidityETH (address to) external payable returns(uint256 liquidity)  {\n    MonoXLibrary.safeTransferETH(address(monoXPool), msg.value);\n    monoXPool.depositWETH(msg.value);\n    liquidity = _addLiquidityPair(WETH, 0, msg.value, address(this), to);\n  }  \n\n  // updates pool vcash balance, token balance and last pool value.\n  // this function requires others to do the input validation\n  function _syncPoolInfo (address _token, uint256 vcashIn, uint256 vcashOut) internal {\n    // PoolInfo memory pool = pools[_token];\n    uint256 tokenPoolPrice = pools[_token].price;\n    (uint256 vcashCredit, uint256 vcashDebt) = _updateVcashBalance(_token, vcashIn, vcashOut);\n\n    uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));\n    uint256 tokenBalanceVcashValue = tokenPoolPrice.mul(tokenReserve)/1e18;\n\n    require(tokenReserve <= uint112(-1));\n    pools[_token].tokenBalance = uint112(tokenReserve);\n    // poolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);\n    pools[_token].lastPoolValue = tokenBalanceVcashValue.add(vcashCredit).sub(vcashDebt);\n  }\n  \n  // view func for removing liquidity\n  function _removeLiquidity (address _token, uint256 liquidity,\n    address to) view public returns(\n    uint256 poolValue, uint256 liquidityIn, uint256 vcashOut, uint256 tokenOut) {\n    \n    require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n    uint256 tokenBalanceVcashValue;\n    uint256 vcashCredit;\n    uint256 vcashDebt;\n    PoolInfo memory pool = pools[_token];\n    IMonoXPool monoXPoolLocal = monoXPool;\n    uint256 lastAdded = monoXPoolLocal.liquidityLastAddedOf(pool.pid, msg.sender);\n    \n    require((lastAdded + (pool.status == PoolStatus.OFFICIAL ? 4 hours : pool.status == PoolStatus.LISTED ? 24 hours : 0)) <= block.timestamp, \"MonoX:WRONG_TIME\"); // Users are not allowed to remove liquidity right after adding\n    address topLPHolder = monoXPoolLocal.topLPHolderOf(pool.pid);\n    require(pool.status != PoolStatus.LISTED || msg.sender != topLPHolder || pool.createdAt + 90 days < block.timestamp, \"MonoX:TOP_HOLDER & WRONG_TIME\"); // largest LP holder is not allowed to remove LP within 90 days after pool creation\n\n    (poolValue, tokenBalanceVcashValue, vcashCredit, vcashDebt) = getPool(_token);\n    uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);\n\n    liquidityIn = monoXPool.balanceOf(to, pool.pid)>liquidity?liquidity:monoXPool.balanceOf(to, pool.pid);\n    uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));\n    \n    if(tokenReserve < pool.tokenBalance){\n      tokenBalanceVcashValue = tokenReserve.mul(pool.price)/1e18;\n    }\n\n    if(vcashDebt>0){\n      tokenReserve = (tokenBalanceVcashValue.sub(vcashDebt)).mul(1e18).div(pool.price);\n    }\n\n    // if vcashCredit==0, vcashOut will be 0 as well\n    vcashOut = liquidityIn.mul(vcashCredit).div(_totalSupply);\n\n    tokenOut = liquidityIn.mul(tokenReserve).div(_totalSupply);\n\n  }\n  \n  // actually removes liquidity\n  function removeLiquidity (address _token, uint256 liquidity, address to, \n    uint256 minVcashOut, \n    uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {\n    (vcashOut, tokenOut) = _removeLiquidityHelper (_token, liquidity, to, minVcashOut, minTokenOut, false);\n  }\n\n  // actually removes liquidity\n  function _removeLiquidityHelper (address _token, uint256 liquidity, address to, \n    uint256 minVcashOut, \n    uint256 minTokenOut,\n    bool isETH) lockToken(_token) internal returns(uint256 vcashOut, uint256 tokenOut)  {\n    require (tokenPoolStatus[_token]==1, \"MonoX:NO_TOKEN\");\n    PoolInfo memory pool = pools[_token];\n    uint256 poolValue;\n    uint256 liquidityIn;\n    (poolValue, liquidityIn, vcashOut, tokenOut) = _removeLiquidity(_token, liquidity, to);\n    _mintFee(pool.pid, pool.lastPoolValue, poolValue);\n    require (vcashOut>=minVcashOut, \"MonoX:INSUFF_vCash\");\n    require (tokenOut>=minTokenOut, \"MonoX:INSUFF_TOKEN\");\n\n    if (vcashOut>0){\n      vCash.mint(to, vcashOut);\n    }\n    if (!isETH) {\n      monoXPool.safeTransferERC20Token(_token, to, tokenOut);\n    } else {\n      monoXPool.withdrawWETH(tokenOut);\n      monoXPool.safeTransferETH(to, tokenOut);\n    }\n\n    monoXPool.burn(to, pool.pid, liquidityIn);\n\n    _syncPoolInfo(_token, 0, vcashOut);\n\n    emit RemoveLiquidity(to, \n      pool.pid,\n      _token,\n      liquidityIn, \n      vcashOut, tokenOut, pool.price);\n  }\n\n  // actually removes ETH liquidity\n  function removeLiquidityETH (uint256 liquidity, address to, \n    uint256 minVcashOut, \n    uint256 minTokenOut) external returns(uint256 vcashOut, uint256 tokenOut)  {\n\n    (vcashOut, tokenOut) = _removeLiquidityHelper (WETH, liquidity, to, minVcashOut, minTokenOut, true);\n  }\n\n  // util func to compute new price\n  function _getNewPrice (uint256 originalPrice, uint256 reserve, \n    uint256 delta, uint256 deltaBlocks, TxType txType) pure internal returns(uint256 price) {\n    if(txType==TxType.SELL) {\n      // no risk of being div by 0\n      price = originalPrice.mul(reserve)/(reserve.add(delta));\n    }else{ // BUY\n      price = originalPrice.mul(reserve).div(reserve.sub(delta));\n    }\n  }\n\n  // util func to compute new price\n  function _getAvgPrice (uint256 originalPrice, uint256 newPrice) pure internal returns(uint256 price) {\n    price = originalPrice.add(newPrice.mul(4))/5;\n  }\n\n  // standard swap interface implementing uniswap router V2\n  \n  function swapExactETHForToken(\n    address tokenOut,\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external virtual payable ensure(deadline) returns (uint amountOut) {\n    uint amountIn = msg.value;\n    MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);\n    monoXPool.depositWETH(amountIn);\n    amountOut = swapIn(WETH, tokenOut, address(this), to, amountIn);\n    require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');\n  }\n  \n  function swapExactTokenForETH(\n    address tokenIn,\n    uint amountIn,\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external virtual ensure(deadline) returns (uint amountOut) {\n    IMonoXPool monoXPoolLocal = monoXPool;\n    amountOut = swapIn(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountIn);\n    require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');\n    monoXPoolLocal.withdrawWETH(amountOut);\n    monoXPoolLocal.safeTransferETH(to, amountOut);\n  }\n\n  function swapETHForExactToken(\n    address tokenOut,\n    uint amountInMax,\n    uint amountOut,\n    address to,\n    uint deadline\n  ) external virtual payable ensure(deadline) returns (uint amountIn) {\n    uint amountSentIn = msg.value;\n    ( , , amountIn, ) = getAmountIn(WETH, tokenOut, amountOut);\n    MonoXLibrary.safeTransferETH(address(monoXPool), amountIn);\n    monoXPool.depositWETH(amountIn);\n    amountIn = swapOut(WETH, tokenOut, address(this), to, amountOut);\n    require(amountIn <= amountSentIn, 'MonoX:BAD_INPUT');\n    require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');\n    if (amountSentIn > amountIn) {\n      MonoXLibrary.safeTransferETH(msg.sender, amountSentIn.sub(amountIn));\n    }\n  }\n\n  function swapTokenForExactETH(\n    address tokenIn,\n    uint amountInMax,\n    uint amountOut,\n    address to,\n    uint deadline\n  ) external virtual ensure(deadline) returns (uint amountIn) {\n    IMonoXPool monoXPoolLocal = monoXPool;\n    amountIn = swapOut(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountOut);\n    require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');\n    monoXPoolLocal.withdrawWETH(amountOut);\n    monoXPoolLocal.safeTransferETH(to, amountOut);\n  }\n\n  function swapExactTokenForToken(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint amountOutMin,\n    address to,\n    uint deadline\n  ) external virtual ensure(deadline) returns (uint amountOut) {\n    amountOut = swapIn(tokenIn, tokenOut, msg.sender, to, amountIn);\n    require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');\n  }\n\n  function swapTokenForExactToken(\n    address tokenIn,\n    address tokenOut,\n    uint amountInMax,\n    uint amountOut,\n    address to,\n    uint deadline\n  ) external virtual ensure(deadline) returns (uint amountIn) {\n    amountIn = swapOut(tokenIn, tokenOut, msg.sender, to, amountOut);\n    require(amountIn <= amountInMax, 'MonoX:EXCESSIVE_INPUT');\n  }\n\n  // util func to manipulate vcash balance\n  function _updateVcashBalance (address _token, \n    uint _vcashIn, uint _vcashOut) internal returns (uint _vcashCredit, uint _vcashDebt) {\n    if(_vcashIn>_vcashOut){\n      _vcashIn = _vcashIn - _vcashOut;\n      _vcashOut = 0;\n    }else{\n      _vcashOut = _vcashOut - _vcashIn;\n      _vcashIn = 0;\n    }\n\n    // PoolInfo memory _pool = pools[_token];\n    uint _poolVcashCredit = pools[_token].vcashCredit;\n    uint _poolVcashDebt = pools[_token].vcashDebt;\n    PoolStatus _poolStatus = pools[_token].status;\n    \n    if(_vcashOut>0){\n      (_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceSub(\n        _poolVcashCredit, _poolVcashDebt, _vcashOut);\n      require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));\n      pools[_token].vcashCredit = uint112(_vcashCredit);\n      pools[_token].vcashDebt = uint112(_vcashDebt);\n    }\n\n    if(_vcashIn>0){\n      (_vcashCredit, _vcashDebt) = MonoXLibrary.vcashBalanceAdd(\n        _poolVcashCredit, _poolVcashDebt, _vcashIn);\n      require(_vcashCredit <= uint112(-1) && _vcashDebt <= uint112(-1));\n      pools[_token].vcashCredit = uint112(_vcashCredit);\n      pools[_token].vcashDebt = uint112(_vcashDebt);\n    }\n\n    if(_poolStatus == PoolStatus.LISTED){\n\n      require (_vcashDebt<=tokenInsurance[_token], \"MonoX:INSUFF_vCash\");\n    }\n  }\n  \n  // updates pool token balance and price.\n  function _updateTokenInfo (address _token, uint256 _price,\n      uint256 _vcashIn, uint256 _vcashOut, uint256 _ETHDebt) internal {\n    uint256 _balance = IERC20(_token).balanceOf(address(monoXPool));\n    _balance = _balance.sub(_ETHDebt);\n    require(pools[_token].status!=PoolStatus.PAUSED,\"MonoX:PAUSED\");\n    require(_balance <= uint112(-1));\n    (uint initialPoolValue, , ,) = getPool(_token);\n    pools[_token].tokenBalance = uint112(_balance);\n    pools[_token].price = _price;\n\n    // record last trade's block number in mapping: lastTradedBlock\n    lastTradedBlock[_token] = block.number;\n\n    _updateVcashBalance(_token, _vcashIn, _vcashOut);\n\n    (uint poolValue, , ,) = getPool(_token);\n\n    require(initialPoolValue <= poolValue || poolValue >= poolSizeMinLimit,\n      \"MonoX:MIN_POOL_SIZE\");\n    \n    \n  }\n\n  function directSwapAllowed(uint tokenInPoolPrice,uint tokenOutPoolPrice, \n                              uint tokenInPoolTokenBalance, uint tokenOutPoolTokenBalance, PoolStatus status, bool getsAmountOut) internal pure returns(bool){\n      uint tokenInValue  = tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18);\n      uint tokenOutValue = tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18);\n      bool priceExists   = getsAmountOut?tokenInPoolPrice>0:tokenOutPoolPrice>0;\n      \n      // only if it's official pool with similar size\n      return priceExists&&status==PoolStatus.OFFICIAL&&tokenInValue>0&&tokenOutValue>0&&\n        ((tokenInValue/tokenOutValue)+(tokenOutValue/tokenInValue)==1);\n        \n  }\n\n  // view func to compute amount required for tokenIn to get fixed amount of tokenOut\n  function getAmountIn(address tokenIn, address tokenOut, \n    uint256 amountOut) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice, \n    uint256 amountIn, uint256 tradeVcashValue) {\n    require(amountOut > 0, 'MonoX:INSUFF_INPUT');\n    \n    uint256 amountOutWithFee = amountOut.mul(1e5).div(1e5 - fees);\n    address vcashAddress = address(vCash);\n    uint tokenOutPoolPrice = pools[tokenOut].price;\n    uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;\n    if(tokenOut==vcashAddress){\n      tradeVcashValue = amountOutWithFee;\n      tokenOutPrice = 1e18;\n    }else{\n      require (tokenPoolStatus[tokenOut]==1, \"MonoX:NO_POOL\");\n      // PoolInfo memory tokenOutPool = pools[tokenOut];\n      PoolStatus tokenOutPoolStatus = pools[tokenOut].status;\n      \n      require (tokenOutPoolStatus != PoolStatus.UNLISTED, \"MonoX:POOL_UNLST\");\n      tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance, \n        amountOutWithFee, 0, TxType.BUY);\n\n      tradeVcashValue = _getAvgPrice(tokenOutPoolPrice, tokenOutPrice).mul(amountOutWithFee)/1e18;\n    }\n\n    if(tokenIn==vcashAddress){\n      amountIn = tradeVcashValue;\n      tokenInPrice = 1e18;\n    }else{\n      require (tokenPoolStatus[tokenIn]==1, \"MonoX:NO_POOL\");\n      // PoolInfo memory tokenInPool = pools[tokenIn];\n      PoolStatus tokenInPoolStatus = pools[tokenIn].status;\n      uint tokenInPoolPrice = pools[tokenIn].price;\n      uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;\n      require (tokenInPoolStatus != PoolStatus.UNLISTED, \"MonoX:POOL_UNLST\");\n\n      amountIn = tradeVcashValue.add(tokenInPoolTokenBalance.mul(tokenInPoolPrice).div(1e18));\n      amountIn = tradeVcashValue.mul(tokenInPoolTokenBalance).div(amountIn);\n\n\n      bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenInPoolStatus,false);\n\n      // assuming p1*p2 = k, equivalent to uniswap's x * y = k\n      uint directSwapTokenInPrice = allowDirectSwap?tokenOutPoolPrice.mul(tokenInPoolPrice).div(tokenOutPrice):1;\n\n      tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance, \n        amountIn, 0, TxType.SELL);\n\n      tokenInPrice = directSwapTokenInPrice > tokenInPrice?directSwapTokenInPrice:tokenInPrice;\n\n      amountIn = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenInPoolPrice, tokenInPrice));\n    }\n  }\n\n  // view func to compute amount required for tokenOut to get fixed amount of tokenIn\n  function getAmountOut(address tokenIn, address tokenOut, \n    uint256 amountIn) public view returns (uint256 tokenInPrice, uint256 tokenOutPrice, \n    uint256 amountOut, uint256 tradeVcashValue) {\n    require(amountIn > 0, 'MonoX:INSUFF_INPUT');\n    \n    uint256 amountInWithFee = amountIn.mul(1e5-fees)/1e5;\n    address vcashAddress = address(vCash);\n    uint tokenInPoolPrice = pools[tokenIn].price;\n    uint tokenInPoolTokenBalance = pools[tokenIn].tokenBalance;\n\n    if(tokenIn==vcashAddress){\n      tradeVcashValue = amountInWithFee;\n      tokenInPrice = 1e18;\n    }else{\n      require (tokenPoolStatus[tokenIn]==1, \"MonoX:NO_POOL\");\n      // PoolInfo memory tokenInPool = pools[tokenIn];\n      PoolStatus tokenInPoolStatus = pools[tokenIn].status;\n      \n      require (tokenInPoolStatus != PoolStatus.UNLISTED, \"MonoX:POOL_UNLST\");\n      \n      tokenInPrice = _getNewPrice(tokenInPoolPrice, tokenInPoolTokenBalance, \n        amountInWithFee, 0, TxType.SELL);\n      tradeVcashValue = _getAvgPrice(tokenInPoolPrice, tokenInPrice).mul(amountInWithFee)/1e18;\n    }\n\n    if(tokenOut==vcashAddress){\n      amountOut = tradeVcashValue;\n      tokenOutPrice = 1e18;\n    }else{\n      require (tokenPoolStatus[tokenOut]==1, \"MonoX:NO_POOL\");\n      // PoolInfo memory tokenOutPool = pools[tokenOut];\n      PoolStatus tokenOutPoolStatus = pools[tokenOut].status;\n      uint tokenOutPoolPrice = pools[tokenOut].price;\n      uint tokenOutPoolTokenBalance = pools[tokenOut].tokenBalance;\n\n      require (tokenOutPoolStatus != PoolStatus.UNLISTED, \"MonoX:POOL_UNLST\");\n      \n      amountOut = tradeVcashValue.add(tokenOutPoolTokenBalance.mul(tokenOutPoolPrice).div(1e18));\n      amountOut = tradeVcashValue.mul(tokenOutPoolTokenBalance).div(amountOut);\n\n      bool allowDirectSwap=directSwapAllowed(tokenInPoolPrice,tokenOutPoolPrice,tokenInPoolTokenBalance,tokenOutPoolTokenBalance,tokenOutPoolStatus,true);\n\n      // assuming p1*p2 = k, equivalent to uniswap's x * y = k\n      uint directSwapTokenOutPrice = allowDirectSwap?tokenInPoolPrice.mul(tokenOutPoolPrice).div(tokenInPrice):uint(-1);\n\n      // prevent the attack where user can use a small pool to update price in a much larger pool\n      tokenOutPrice = _getNewPrice(tokenOutPoolPrice, tokenOutPoolTokenBalance, \n        amountOut, 0, TxType.BUY);\n      tokenOutPrice = directSwapTokenOutPrice < tokenOutPrice?directSwapTokenOutPrice:tokenOutPrice;\n\n      amountOut = tradeVcashValue.mul(1e18).div(_getAvgPrice(tokenOutPoolPrice, tokenOutPrice));\n    }\n  }\n\n\n  // swap from tokenIn to tokenOut with fixed tokenIn amount.\n  function swapIn (address tokenIn, address tokenOut, address from, address to,\n      uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {\n\n    address monoXPoolLocal = address(monoXPool);\n\n    amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn); \n    \n    // uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;\n\n    uint256 tokenInPrice;\n    uint256 tokenOutPrice;\n    uint256 tradeVcashValue;\n    \n    (tokenInPrice, tokenOutPrice, amountOut, tradeVcashValue) = getAmountOut(tokenIn, tokenOut, amountIn);\n\n    uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;\n\n    // trading in\n    if(tokenIn==address(vCash)){\n      vCash.burn(monoXPoolLocal, amountIn);\n      // all fees go to the other side\n      oneSideFeesInVcash = oneSideFeesInVcash.mul(2);\n    }else{\n      _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);\n    }\n\n    // trading out\n    if(tokenOut==address(vCash)){\n      vCash.mint(to, amountOut);\n    }else{\n      if (to != monoXPoolLocal) {\n        IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);\n      }\n      _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, \n        to == monoXPoolLocal ? amountOut : 0);\n    }\n\n    if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){\n      _internalRebalance(tokenIn);\n    }\n\n    emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);\n    \n  }\n\n  \n  // swap from tokenIn to tokenOut with fixed tokenOut amount.\n  function swapOut (address tokenIn, address tokenOut, address from, address to, \n      uint256 amountOut) internal lockToken(tokenIn) returns(uint256 amountIn)  {\n    uint256 tokenInPrice;\n    uint256 tokenOutPrice;\n    uint256 tradeVcashValue;\n    (tokenInPrice, tokenOutPrice, amountIn, tradeVcashValue) = getAmountIn(tokenIn, tokenOut, amountOut);\n    \n    address monoXPoolLocal = address(monoXPool);\n\n    amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn);\n\n    // uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;\n\n    uint256 oneSideFeesInVcash = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;\n\n    // trading in\n    if(tokenIn==address(vCash)){\n      vCash.burn(monoXPoolLocal, amountIn);\n      // all fees go to buy side\n      oneSideFeesInVcash = oneSideFeesInVcash.mul(2);\n    }else {\n      _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVcashValue.add(oneSideFeesInVcash), 0);\n    }\n\n    // trading out\n    if(tokenOut==address(vCash)){\n      vCash.mint(to, amountOut);\n      // all fees go to sell side\n      _updateVcashBalance(tokenIn, oneSideFeesInVcash, 0);\n    }else{\n      if (to != monoXPoolLocal) {\n        IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);\n      }\n      _updateTokenInfo(tokenOut, tokenOutPrice, tradeVcashValue.add(oneSideFeesInVcash), 0, \n        to == monoXPoolLocal ? amountOut:0 );\n    }\n\n     \n    if(pools[tokenIn].vcashDebt > 0 && pools[tokenIn].status == PoolStatus.OFFICIAL){\n      _internalRebalance(tokenIn);\n    }\n  \n\n    emit Swap(to, tokenIn, tokenOut, amountIn, amountOut, tradeVcashValue);\n\n  }\n  // function balanceOf(address account, uint256 id) public view returns (uint256) {\n  //   return monoXPool.balanceOf(account, id);\n  // }\n\n  function getConfig() public view returns (address _vCash, address _weth, address _feeTo, uint16 _fees, uint16 _devFee) {\n    _vCash = address(vCash);\n    _weth = WETH;\n    _feeTo = feeTo;\n    _fees = fees;\n    _devFee = devFee;\n  }\n\n  function transferAndCheck(address from,address to,address _token,uint amount) internal returns (uint256){\n    if(from == address(this)){\n      return amount; // if it's ETH\n    }\n\n    // if it's not ETH\n    if(tokenStatus[_token]==2){\n      IERC20(_token).safeTransferFrom(from, to, amount);\n      return amount;\n    }else{\n      uint256 balanceIn0 = IERC20(_token).balanceOf(to);\n      IERC20(_token).safeTransferFrom(from, to, amount);\n      uint256 balanceIn1 = IERC20(_token).balanceOf(to);\n      return balanceIn1.sub(balanceIn0);\n    }   \n\n  }\n}\n"
    #         ,
    #         "pragma solidity 0.5.16;\r\n\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Detailed.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\r\n\r\ncontract ForceProfitSharing is ERC20, ERC20Detailed, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    IERC20 public force;\r\n\r\n    event Withdraw(address indexed beneficiary, uint256 amount);\r\n    event Deposit(address indexed beneficiary, uint256 amount);\r\n\r\n    // Define the Force token contract\r\n    constructor(address _underlying) public {\r\n        force = IERC20(_underlying);\r\n        ERC20Detailed.initialize(\r\n            \"xFORCE\",\r\n            \"xFORCE\",\r\n            ERC20Detailed(_underlying).decimals()\r\n        );\r\n        ReentrancyGuard.initialize();\r\n    }\r\n\r\n    function deposit(uint256 amount) external nonReentrant {\r\n        // Gets the amount of Force locked in the contract\r\n        uint256 totalForce = force.balanceOf(address(this));\r\n        // Gets the amount of xForce in existence\r\n        uint256 totalShares = totalSupply();\r\n        // If no xForce exists, mint it 1:1 to the amount put in\r\n        if (totalShares == 0 || totalForce == 0) {\r\n            _mint(msg.sender, amount);\r\n        }\r\n        // Calculate and mint the amount of xForce the Force is worth. The ratio will change overtime, as xForce is burned/minted and Force deposited + gained from fees / withdrawn.\r\n        else {\r\n            uint256 what = amount.mul(totalShares).div(totalForce);\r\n            _mint(msg.sender, what);\r\n        }\r\n        // Lock the Force in the contract\r\n        force.transferFrom(msg.sender, address(this), amount);\r\n\r\n        emit Deposit(msg.sender, amount);\r\n    }\r\n\r\n    function withdraw(uint256 numberOfShares) external nonReentrant {\r\n        // Gets the amount of xForce in existence\r\n        uint256 totalShares = totalSupply();\r\n        // Calculates the amount of Force the xForce is worth\r\n        uint256 what =\r\n            numberOfShares.mul(force.balanceOf(address(this))).div(totalShares);\r\n        _burn(msg.sender, numberOfShares);\r\n        force.transfer(msg.sender, what);\r\n\r\n        emit Withdraw(msg.sender, what);\r\n    }\r\n}\r\n"],
    #     ids=["Sushi-BoringOwnable.sol", "Li.Fi-AnyswapFacet.sol", "Beanstalk-VotingBooth.sol", "MonoX-Monoswap.sol",
    #          "Force DAO-ForceProfitSharing.sol"]
    # )

    # Which contracts use the ReentrancyGuard anti-reentrancy lock?
    # What is the function of the startBridgeTokensViaAnyswap?

    # res = collection.get()
    # print(res)

    bug_summary = "交易故障分析：问题/异常点：该故障交易（0x90fb0c9976...）存在异常代币流转路径，通过流动性池操作实现大额资金转移，最终导致约8.13 ETH被转移至外部合约地址。关键异常点包括：1. 自定义ERC-20代币（0x9a13...f35e3）的铸造-销毁循环（铸造53,612单位后立即销毁605,567,254单位）；2. WBTC流动性池（0xceff...3a58）中异常兑换比例（输入1,532,192,467单位代币仅换取0.00063 ETH）；3. SUSHI/WETH流动性池（0x7950...1fb0）出现超大规模代币兑换（3.1e+19单位）。原因分析：该漏洞本质上是闪电贷攻击与流动性池价格操纵的组合利用。攻击者通过以下步骤实施攻击：1. 利用路由合约0xe11fc0...df50调用多个流动性池，首先在低流动性的自定义代币池（0x9a13...f35e3）通过铸造-销毁操作人为制造代币供应量波动；2. 通过WBTC/WETH池的swap函数注入大量WBTC（345,346,828单位），利用该池的恒定乘积公式缺陷拉高WETH相对价格；3. 在SUSHI/WETH池执行反向兑换，将虚高的WETH兑换为异常数量的SUSHI代币（1.46e+22单位）。根本原因是目标合约未对跨池交易进行滑点控制，且代币池的流动性算法未能防御大额单边交易带来的价格偏移。攻击者利用的核心漏洞包括：1. 代币合约的铸造权限未隔离（任何地址可触发铸造）；2. 流动性池的swap函数未引入时间加权平均价格（TWAP）保护；3. 路由合约的跨交易验证缺失，允许单笔交易内完成自循环的价格操纵。同类非故障交易（如0x7df39084b5...）显示正常swap操作中代币输入输出量级比例合理，进一步验证故障交易中存在异常价格计算。"

    query_results = contract_collection.query(
        query_texts=[bug_summary],
        n_results=40,
        include=["distances", "documents"]
    )

    print("正在进行重排序...\n")
    code_summary_list_str = ""
    code_summary_list = query_results['documents']
    _id_list = query_results['ids']
    for _id, code_summary in zip(_id_list[0], code_summary_list[0]):
        code_summary_list_str = code_summary_list_str + "\n-----------------------------\n" + _id + ":\n" + code_summary

    rerank_variables = {
        "bug_summary": bug_summary,
        "code_summary_list": code_summary_list_str
    }
    system_prompt = llm.load_prompt("prompt/rerank_summary_system_prompt")
    user_prompt = llm.load_prompt("prompt/rerank_summary_user_prompt", rerank_variables)
    rerank_result = llm.get_summary_from_llm(system_prompt, user_prompt, 2)
    if rerank_result[0] != 'stop':
        print(' error! message:' + rerank_result[0])
    rerank_result = rerank_result[1]
    std_rerank_result = json.loads(rerank_result)
    final_contracts = []
    if std_rerank_result is not None:
        rerank_list = std_rerank_result['result']
        for rerank in rerank_list:
            final_contracts.append(rerank['name'])

    # contract_list = query_results.get('ids')
    function_collection = client.get_or_create_collection("Function")
    function_str = ""
    for contract_name in final_contracts:
        function_list = function_collection.get(
            where={"函数所属的合约或接口": {"$eq": contract_name}}
        )
        if len(function_list.get('documents')) == 0:
            continue
        ids = function_list.get('ids')
        metadatas = function_list.get('metadatas')
        documents = function_list.get('documents')
        for fid, metadata, document in zip(ids, metadatas, documents):
            function_str += "\n------------------------------------------------\n函数切片ID: " + fid + "\n元数据:" + str(metadata) + "\n函数切片:\n" + document
    print(function_str)
